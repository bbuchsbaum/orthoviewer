!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).surfview={},e.THREE)}(this,(function(e,t){"use strict";function i(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e)for(const i in e)if("default"!==i){const r=Object.getOwnPropertyDescriptor(e,i);Object.defineProperty(t,i,r.get?r:{enumerable:!0,get:()=>e[i]})}return t.default=e,Object.freeze(t)}const r=i(t),s={type:"change"},n={type:"start"},a={type:"end"},o=1e-6,l=-1,h=0,c=1,d=2,u=3,p=4,m=new t.Vector2,f=new t.Vector2,g=new t.Vector3,v=new t.Vector3,y=new t.Vector3,b=new t.Quaternion,w=new t.Vector3,x=new t.Vector3,M=new t.Vector3,C=new t.Vector3;class S extends t.Controls{constructor(e,i=null){super(e,i),this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.keys=["KeyA","KeyS","KeyD"],this.mouseButtons={LEFT:t.MOUSE.ROTATE,MIDDLE:t.MOUSE.DOLLY,RIGHT:t.MOUSE.PAN},this.target=new t.Vector3,this.state=l,this.keyState=l,this._lastPosition=new t.Vector3,this._lastZoom=1,this._touchZoomDistanceStart=0,this._touchZoomDistanceEnd=0,this._lastAngle=0,this._eye=new t.Vector3,this._movePrev=new t.Vector2,this._moveCurr=new t.Vector2,this._lastAxis=new t.Vector3,this._zoomStart=new t.Vector2,this._zoomEnd=new t.Vector2,this._panStart=new t.Vector2,this._panEnd=new t.Vector2,this._pointers=[],this._pointerPositions={},this._onPointerMove=T.bind(this),this._onPointerDown=_.bind(this),this._onPointerUp=A.bind(this),this._onPointerCancel=P.bind(this),this._onContextMenu=F.bind(this),this._onMouseWheel=k.bind(this),this._onKeyDown=L.bind(this),this._onKeyUp=E.bind(this),this._onTouchStart=V.bind(this),this._onTouchMove=B.bind(this),this._onTouchEnd=O.bind(this),this._onMouseDown=I.bind(this),this._onMouseMove=R.bind(this),this._onMouseUp=D.bind(this),this._target0=this.target.clone(),this._position0=this.object.position.clone(),this._up0=this.object.up.clone(),this._zoom0=this.object.zoom,null!==i&&(this.connect(i),this.handleResize()),this.update()}connect(e){super.connect(e),window.addEventListener("keydown",this._onKeyDown),window.addEventListener("keyup",this._onKeyUp),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerCancel),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="none"}disconnect(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp),this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerCancel),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}handleResize(){const e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}update(){this._eye.subVectors(this.object.position,this.target),this.noRotate||this._rotateCamera(),this.noZoom||this._zoomCamera(),this.noPan||this._panCamera(),this.object.position.addVectors(this.target,this._eye),this.object.isPerspectiveCamera?(this._checkDistances(),this.object.lookAt(this.target),this._lastPosition.distanceToSquared(this.object.position)>o&&(this.dispatchEvent(s),this._lastPosition.copy(this.object.position))):this.object.isOrthographicCamera?(this.object.lookAt(this.target),(this._lastPosition.distanceToSquared(this.object.position)>o||this._lastZoom!==this.object.zoom)&&(this.dispatchEvent(s),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type.")}reset(){this.state=l,this.keyState=l,this.target.copy(this._target0),this.object.position.copy(this._position0),this.object.up.copy(this._up0),this.object.zoom=this._zoom0,this.object.updateProjectionMatrix(),this._eye.subVectors(this.object.position,this.target),this.object.lookAt(this.target),this.dispatchEvent(s),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom}_panCamera(){if(f.copy(this._panEnd).sub(this._panStart),f.lengthSq()){if(this.object.isOrthographicCamera){const e=(this.object.right-this.object.left)/this.object.zoom/this.domElement.clientWidth,t=(this.object.top-this.object.bottom)/this.object.zoom/this.domElement.clientWidth;f.x*=e,f.y*=t}f.multiplyScalar(this._eye.length()*this.panSpeed),v.copy(this._eye).cross(this.object.up).setLength(f.x),v.add(g.copy(this.object.up).setLength(f.y)),this.object.position.add(v),this.target.add(v),this.staticMoving?this._panStart.copy(this._panEnd):this._panStart.add(f.subVectors(this._panEnd,this._panStart).multiplyScalar(this.dynamicDampingFactor))}}_rotateCamera(){C.set(this._moveCurr.x-this._movePrev.x,this._moveCurr.y-this._movePrev.y,0);let e=C.length();e?(this._eye.copy(this.object.position).sub(this.target),w.copy(this._eye).normalize(),x.copy(this.object.up).normalize(),M.crossVectors(x,w).normalize(),x.setLength(this._moveCurr.y-this._movePrev.y),M.setLength(this._moveCurr.x-this._movePrev.x),C.copy(x.add(M)),y.crossVectors(C,this._eye).normalize(),e*=this.rotateSpeed,b.setFromAxisAngle(y,e),this._eye.applyQuaternion(b),this.object.up.applyQuaternion(b),this._lastAxis.copy(y),this._lastAngle=e):!this.staticMoving&&this._lastAngle&&(this._lastAngle*=Math.sqrt(1-this.dynamicDampingFactor),this._eye.copy(this.object.position).sub(this.target),b.setFromAxisAngle(this._lastAxis,this._lastAngle),this._eye.applyQuaternion(b),this.object.up.applyQuaternion(b)),this._movePrev.copy(this._moveCurr)}_zoomCamera(){let e;this.state===p?(e=this._touchZoomDistanceStart/this._touchZoomDistanceEnd,this._touchZoomDistanceStart=this._touchZoomDistanceEnd,this.object.isPerspectiveCamera?this._eye.multiplyScalar(e):this.object.isOrthographicCamera?(this.object.zoom=t.MathUtils.clamp(this.object.zoom/e,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(e=1+(this._zoomEnd.y-this._zoomStart.y)*this.zoomSpeed,1!==e&&e>0&&(this.object.isPerspectiveCamera?this._eye.multiplyScalar(e):this.object.isOrthographicCamera?(this.object.zoom=t.MathUtils.clamp(this.object.zoom/e,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),this.staticMoving?this._zoomStart.copy(this._zoomEnd):this._zoomStart.y+=(this._zoomEnd.y-this._zoomStart.y)*this.dynamicDampingFactor)}_getMouseOnScreen(e,t){return m.set((e-this.screen.left)/this.screen.width,(t-this.screen.top)/this.screen.height),m}_getMouseOnCircle(e,t){return m.set((e-.5*this.screen.width-this.screen.left)/(.5*this.screen.width),(this.screen.height+2*(this.screen.top-t))/this.screen.width),m}_addPointer(e){this._pointers.push(e)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t].pointerId==e.pointerId)return void this._pointers.splice(t,1)}_trackPointer(e){let i=this._pointerPositions[e.pointerId];void 0===i&&(i=new t.Vector2,this._pointerPositions[e.pointerId]=i),i.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0].pointerId?this._pointers[1]:this._pointers[0];return this._pointerPositions[t.pointerId]}_checkDistances(){this.noZoom&&this.noPan||(this._eye.lengthSq()>this.maxDistance*this.maxDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.maxDistance)),this._zoomStart.copy(this._zoomEnd)),this._eye.lengthSq()<this.minDistance*this.minDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.minDistance)),this._zoomStart.copy(this._zoomEnd)))}}function _(e){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(e.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._addPointer(e),"touch"===e.pointerType?this._onTouchStart(e):this._onMouseDown(e))}function T(e){!1!==this.enabled&&("touch"===e.pointerType?this._onTouchMove(e):this._onMouseMove(e))}function A(e){!1!==this.enabled&&("touch"===e.pointerType?this._onTouchEnd(e):this._onMouseUp(),this._removePointer(e),0===this._pointers.length&&(this.domElement.releasePointerCapture(e.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp)))}function P(e){this._removePointer(e)}function E(){!1!==this.enabled&&(this.keyState=l,window.addEventListener("keydown",this._onKeyDown))}function L(e){!1!==this.enabled&&(window.removeEventListener("keydown",this._onKeyDown),this.keyState===l&&(e.code!==this.keys[h]||this.noRotate?e.code!==this.keys[c]||this.noZoom?e.code!==this.keys[d]||this.noPan||(this.keyState=d):this.keyState=c:this.keyState=h))}function I(e){let i;switch(e.button){case 0:i=this.mouseButtons.LEFT;break;case 1:i=this.mouseButtons.MIDDLE;break;case 2:i=this.mouseButtons.RIGHT;break;default:i=-1}switch(i){case t.MOUSE.DOLLY:this.state=c;break;case t.MOUSE.ROTATE:this.state=h;break;case t.MOUSE.PAN:this.state=d;break;default:this.state=l}const r=this.keyState!==l?this.keyState:this.state;r!==h||this.noRotate?r!==c||this.noZoom?r!==d||this.noPan||(this._panStart.copy(this._getMouseOnScreen(e.pageX,e.pageY)),this._panEnd.copy(this._panStart)):(this._zoomStart.copy(this._getMouseOnScreen(e.pageX,e.pageY)),this._zoomEnd.copy(this._zoomStart)):(this._moveCurr.copy(this._getMouseOnCircle(e.pageX,e.pageY)),this._movePrev.copy(this._moveCurr)),this.dispatchEvent(n)}function R(e){const t=this.keyState!==l?this.keyState:this.state;t!==h||this.noRotate?t!==c||this.noZoom?t!==d||this.noPan||this._panEnd.copy(this._getMouseOnScreen(e.pageX,e.pageY)):this._zoomEnd.copy(this._getMouseOnScreen(e.pageX,e.pageY)):(this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(e.pageX,e.pageY)))}function D(){this.state=l,this.dispatchEvent(a)}function k(e){if(!1!==this.enabled&&!0!==this.noZoom){switch(e.preventDefault(),e.deltaMode){case 2:this._zoomStart.y-=.025*e.deltaY;break;case 1:this._zoomStart.y-=.01*e.deltaY;break;default:this._zoomStart.y-=25e-5*e.deltaY}this.dispatchEvent(n),this.dispatchEvent(a)}}function F(e){!1!==this.enabled&&e.preventDefault()}function V(e){if(this._trackPointer(e),1===this._pointers.length)this.state=u,this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX,this._pointers[0].pageY)),this._movePrev.copy(this._moveCurr);else{this.state=p;const e=this._pointers[0].pageX-this._pointers[1].pageX,t=this._pointers[0].pageY-this._pointers[1].pageY;this._touchZoomDistanceEnd=this._touchZoomDistanceStart=Math.sqrt(e*e+t*t);const i=(this._pointers[0].pageX+this._pointers[1].pageX)/2,r=(this._pointers[0].pageY+this._pointers[1].pageY)/2;this._panStart.copy(this._getMouseOnScreen(i,r)),this._panEnd.copy(this._panStart)}this.dispatchEvent(n)}function B(e){if(this._trackPointer(e),1===this._pointers.length)this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(e.pageX,e.pageY));else{const t=this._getSecondPointerPosition(e),i=e.pageX-t.x,r=e.pageY-t.y;this._touchZoomDistanceEnd=Math.sqrt(i*i+r*r);const s=(e.pageX+t.x)/2,n=(e.pageY+t.y)/2;this._panEnd.copy(this._getMouseOnScreen(s,n))}}function O(e){switch(this._pointers.length){case 0:this.state=l;break;case 1:this.state=u,this._moveCurr.copy(this._getMouseOnCircle(e.pageX,e.pageY)),this._movePrev.copy(this._moveCurr);break;case 2:this.state=p;for(let t=0;t<this._pointers.length;t++)if(this._pointers[t].pointerId!==e.pointerId){const e=this._pointerPositions[this._pointers[t].pointerId];this._moveCurr.copy(this._getMouseOnCircle(e.x,e.y)),this._movePrev.copy(this._moveCurr);break}}this.dispatchEvent(a)}class N extends t.EventDispatcher{constructor(e,t,i={}){super(),this.mouseButtons={LEFT:r.MOUSE.ROTATE,MIDDLE:r.MOUSE.DOLLY,RIGHT:r.MOUSE.PAN},this.state={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},this.camera=e,this.domElement=t,this.enabled=!0,this.rotateSpeed=i.rotateSpeed||1,this.zoomSpeed=i.zoomSpeed||1,this.panSpeed=i.panSpeed||1,this.enableRotate=!1!==i.enableRotate,this.enableZoom=!1!==i.enableZoom,this.enablePan=!1!==i.enablePan,this.enableDamping=!1,this.dampingFactor=.05,this.minDistance=.05,this.maxDistance=1/0,this.target=new r.Vector3,this.currentState=this.state.NONE,this.rotateStart=new r.Vector2,this.rotateEnd=new r.Vector2,this.panStart=new r.Vector2,this.panEnd=new r.Vector2,this.panDelta=new r.Vector2,this.dollyStart=new r.Vector2,this.dollyEnd=new r.Vector2,this.dollyDelta=new r.Vector2,this.screen={left:0,top:0,width:0,height:0},this.rotateStartVec=new r.Vector3,this.rotateEndVec=new r.Vector3,this.rotationAxis=new r.Vector3,this.onMouseDown=this.onMouseDown.bind(this),this.onMouseMove=this.onMouseMove.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.onMouseWheel=this.onMouseWheel.bind(this),this.onTouchStart=this.onTouchStart.bind(this),this.onTouchMove=this.onTouchMove.bind(this),this.onTouchEnd=this.onTouchEnd.bind(this),this.onContextMenu=this.onContextMenu.bind(this),this.domElement.addEventListener("contextmenu",this.onContextMenu),this.domElement.addEventListener("mousedown",this.onMouseDown),this.domElement.addEventListener("wheel",this.onMouseWheel),this.domElement.addEventListener("touchstart",this.onTouchStart),this.domElement.addEventListener("touchmove",this.onTouchMove),this.domElement.addEventListener("touchend",this.onTouchEnd),this.handleResize(),this.update()}handleResize(){const e=this.domElement.getBoundingClientRect();this.screen.left=e.left,this.screen.top=e.top,this.screen.width=e.width,this.screen.height=e.height}getMouseOnBall(e,t){const i=new r.Vector3,s=this.domElement.getBoundingClientRect();i.x=(e-s.left)/s.width*2-1,i.y=-(t-s.top)/s.height*2+1;const n=i.x*i.x+i.y*i.y;return n<=1?i.z=Math.sqrt(1-n):(i.normalize(),i.z=0),i}rotateCamera(){if(!this.enableRotate)return;const e=this.domElement.getBoundingClientRect(),t=this.rotateEnd.x-this.rotateStart.x,i=this.rotateEnd.y-this.rotateStart.y;if(Math.abs(t)<.25&&Math.abs(i)<.25)return;const s=Math.max(.5,Math.min(e.width,e.height)/800),n=.005*t*this.rotateSpeed*s,a=.005*i*this.rotateSpeed*s,o=this.camera.position.clone().sub(this.target),l=(new r.Quaternion).setFromAxisAngle(new r.Vector3(0,1,0),n);o.applyQuaternion(l),this.camera.up.applyQuaternion(l);const h=new r.Vector3(1,0,0),c=(new r.Quaternion).setFromAxisAngle(h,a);o.applyQuaternion(c),this.camera.up.applyQuaternion(c),this.camera.up.normalize(),this.camera.position.copy(this.target).add(o),this.camera.lookAt(this.target),this.rotateStart.copy(this.rotateEnd)}panCamera(){if(!this.enablePan)return;const e=this.domElement.getBoundingClientRect();this.panDelta.set(this.panEnd.x-this.panStart.x,this.panEnd.y-this.panStart.y);const t=2*(this.camera.position.clone().sub(this.target).length()*Math.tan(this.camera.fov/2*Math.PI/180))/e.height,i=new r.Vector3,s=new r.Vector3;i.setFromMatrixColumn(this.camera.matrix,0),i.multiplyScalar(-this.panDelta.x*t*this.panSpeed),s.setFromMatrixColumn(this.camera.matrix,1),s.multiplyScalar(this.panDelta.y*t*this.panSpeed);const n=(new r.Vector3).addVectors(i,s);this.camera.position.add(n),this.target.add(n),this.panStart.copy(this.panEnd)}dollyCamera(){if(!this.enableZoom)return;const e=Math.pow(.95,this.dollyDelta.y*this.zoomSpeed),t=this.camera.position.clone().sub(this.target),i=t.length()*e,r=Math.min(this.maxDistance,Math.max(this.minDistance,i));t.setLength(r),this.camera.position.copy(this.target).add(t),this.dollyStart.copy(this.dollyEnd)}update(){this.dispatchEvent({type:"change"})}onContextMenu(e){"preventDefault"in e&&e.preventDefault()}onMouseDown(e){if(this.enabled){switch(e.preventDefault(),e.button){case 0:this.enableRotate&&(this.currentState=this.state.ROTATE,this.rotateStart.set(e.clientX,e.clientY));break;case 1:this.enableZoom&&(this.currentState=this.state.DOLLY,this.dollyStart.set(e.clientX,e.clientY));break;case 2:this.enablePan&&(this.currentState=this.state.PAN,this.panStart.set(e.clientX,e.clientY))}this.currentState!==this.state.NONE&&(document.addEventListener("mousemove",this.onMouseMove),document.addEventListener("mouseup",this.onMouseUp))}}onMouseMove(e){if(this.enabled)switch(e.preventDefault(),this.currentState){case this.state.ROTATE:this.rotateEnd.set(e.clientX,e.clientY),this.rotateCamera(),this.update();break;case this.state.DOLLY:this.dollyEnd.set(e.clientX,e.clientY),this.dollyDelta.subVectors(this.dollyEnd,this.dollyStart),this.dollyCamera(),this.dollyDelta.set(0,0),this.update();break;case this.state.PAN:this.panEnd.set(e.clientX,e.clientY),this.panCamera(),this.update()}}onMouseUp(e){this.enabled&&(document.removeEventListener("mousemove",this.onMouseMove),document.removeEventListener("mouseup",this.onMouseUp),this.currentState=this.state.NONE)}onMouseWheel(e){this.enabled&&this.enableZoom&&(e.preventDefault(),e.stopPropagation(),this.dollyDelta.y=.01*e.deltaY,this.dollyCamera(),this.dollyDelta.set(0,0),this.update())}onTouchStart(e){if(this.enabled)switch(e.preventDefault(),e.touches.length){case 1:this.enableRotate&&(this.currentState=this.state.TOUCH_ROTATE,this.rotateStart.set(e.touches[0].pageX,e.touches[0].pageY));break;case 2:if(this.enableZoom||this.enablePan){const t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY,r=Math.sqrt(t*t+i*i);this.currentState=this.state.TOUCH_DOLLY_PAN,this.dollyStart.set(0,r);const s=.5*(e.touches[0].pageX+e.touches[1].pageX),n=.5*(e.touches[0].pageY+e.touches[1].pageY);this.panStart.set(s,n)}}}onTouchMove(e){if(this.enabled)switch(e.preventDefault(),e.stopPropagation(),this.currentState){case this.state.TOUCH_ROTATE:this.enableRotate&&(this.rotateEnd.set(e.touches[0].pageX,e.touches[0].pageY),this.rotateCamera(),this.update());break;case this.state.TOUCH_DOLLY_PAN:if(this.enableZoom||this.enablePan){const t=e.touches[0].pageX-e.touches[1].pageX,i=e.touches[0].pageY-e.touches[1].pageY,r=Math.sqrt(t*t+i*i);if(this.enableZoom&&(this.dollyEnd.set(0,r),this.dollyDelta.set(0,.01*(this.dollyEnd.y-this.dollyStart.y)),this.dollyCamera()),this.enablePan){const t=.5*(e.touches[0].pageX+e.touches[1].pageX),i=.5*(e.touches[0].pageY+e.touches[1].pageY);this.panEnd.set(t,i),this.panCamera()}this.update()}}}onTouchEnd(e){this.enabled&&(this.currentState=this.state.NONE)}dispose(){this.domElement.removeEventListener("contextmenu",this.onContextMenu),this.domElement.removeEventListener("mousedown",this.onMouseDown),this.domElement.removeEventListener("wheel",this.onMouseWheel),this.domElement.removeEventListener("touchstart",this.onTouchStart),this.domElement.removeEventListener("touchmove",this.onTouchMove),this.domElement.removeEventListener("touchend",this.onTouchEnd),document.removeEventListener("mousemove",this.onMouseMove),document.removeEventListener("mouseup",this.onMouseUp)}reset(){this.target.set(0,0,0),this.camera.position.set(0,0,100),this.camera.up.set(0,1,0),this.camera.lookAt(this.target),this.update()}saveState(){this.target0=this.target.clone(),this.position0=this.camera.position.clone(),this.up0=this.camera.up.clone()}restoreState(){this.target0&&this.target.copy(this.target0),this.position0&&this.camera.position.copy(this.position0),this.up0&&this.camera.up.copy(this.up0),this.camera.lookAt(this.target),this.update()}getTarget(){return this.target}}const U={name:"CopyShader",uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}"};class z{constructor(){this.isPass=!0,this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const j=new t.OrthographicCamera(-1,1,1,-1,0,1);class $ extends t.BufferGeometry{constructor(){super(),this.setAttribute("position",new t.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([0,2,0,0,2,0],2))}}const G=new $;class q{constructor(e){this._mesh=new t.Mesh(G,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,j)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class Y extends z{constructor(e,i="tDiffuse"){super(),this.textureID=i,this.uniforms=null,this.material=null,e instanceof t.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=t.UniformsUtils.clone(e.uniforms),this.material=new t.ShaderMaterial({name:void 0!==e.name?e.name:"unspecified",defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this._fsQuad=new q(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this._fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this._fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this._fsQuad.render(e))}dispose(){this.material.dispose(),this._fsQuad.dispose()}}class W extends z{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const r=e.getContext(),s=e.state;let n,a;s.buffers.color.setMask(!1),s.buffers.depth.setMask(!1),s.buffers.color.setLocked(!0),s.buffers.depth.setLocked(!0),this.inverse?(n=0,a=1):(n=1,a=0),s.buffers.stencil.setTest(!0),s.buffers.stencil.setOp(r.REPLACE,r.REPLACE,r.REPLACE),s.buffers.stencil.setFunc(r.ALWAYS,n,4294967295),s.buffers.stencil.setClear(a),s.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),s.buffers.color.setLocked(!1),s.buffers.depth.setLocked(!1),s.buffers.color.setMask(!0),s.buffers.depth.setMask(!0),s.buffers.stencil.setLocked(!1),s.buffers.stencil.setFunc(r.EQUAL,1,4294967295),s.buffers.stencil.setOp(r.KEEP,r.KEEP,r.KEEP),s.buffers.stencil.setLocked(!0)}}class X extends z{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class H{constructor(e,i){if(this.renderer=e,this._pixelRatio=e.getPixelRatio(),void 0===i){const r=e.getSize(new t.Vector2);this._width=r.width,this._height=r.height,(i=new t.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:t.HalfFloatType})).texture.name="EffectComposer.rt1"}else this._width=i.width,this._height=i.height;this.renderTarget1=i,this.renderTarget2=i.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new Y(U),this.copyPass.material.blending=t.NoBlending,this.clock=new t.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);-1!==t&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){void 0===e&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let r=0,s=this.passes.length;r<s;r++){const t=this.passes[r];if(!1!==t.enabled){if(t.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(r),t.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),t.needsSwap){if(i){const t=this.renderer.getContext(),i=this.renderer.state.buffers.stencil;i.setFunc(t.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),i.setFunc(t.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==W&&(t instanceof W?i=!0:t instanceof X&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(void 0===e){const i=this.renderer.getSize(new t.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=i.width,this._height=i.height,(e=this.renderTarget1.clone()).setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,r=this._height*this._pixelRatio;this.renderTarget1.setSize(i,r),this.renderTarget2.setSize(i,r);for(let s=0;s<this.passes.length;s++)this.passes[s].setSize(i,r)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}class J extends z{constructor(e,i,r=null,s=null,n=null){super(),this.scene=e,this.camera=i,this.overrideMaterial=r,this.clearColor=s,this.clearAlpha=n,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1,this._oldClearColor=new t.Color}render(e,t,i){const r=e.autoClear;let s,n;e.autoClear=!1,null!==this.overrideMaterial&&(n=this.scene.overrideMaterial,this.scene.overrideMaterial=this.overrideMaterial),null!==this.clearColor&&(e.getClearColor(this._oldClearColor),e.setClearColor(this.clearColor,e.getClearAlpha())),null!==this.clearAlpha&&(s=e.getClearAlpha(),e.setClearAlpha(this.clearAlpha)),1==this.clearDepth&&e.clearDepth(),e.setRenderTarget(this.renderToScreen?null:i),!0===this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),e.render(this.scene,this.camera),null!==this.clearColor&&e.setClearColor(this._oldClearColor),null!==this.clearAlpha&&e.setClearAlpha(s),null!==this.overrideMaterial&&(this.scene.overrideMaterial=n),e.autoClear=r}}class Z{constructor(e=Math){this.grad3=[[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],[1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],[0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]],this.grad4=[[0,1,1,1],[0,1,1,-1],[0,1,-1,1],[0,1,-1,-1],[0,-1,1,1],[0,-1,1,-1],[0,-1,-1,1],[0,-1,-1,-1],[1,0,1,1],[1,0,1,-1],[1,0,-1,1],[1,0,-1,-1],[-1,0,1,1],[-1,0,1,-1],[-1,0,-1,1],[-1,0,-1,-1],[1,1,0,1],[1,1,0,-1],[1,-1,0,1],[1,-1,0,-1],[-1,1,0,1],[-1,1,0,-1],[-1,-1,0,1],[-1,-1,0,-1],[1,1,1,0],[1,1,-1,0],[1,-1,1,0],[1,-1,-1,0],[-1,1,1,0],[-1,1,-1,0],[-1,-1,1,0],[-1,-1,-1,0]],this.p=[];for(let t=0;t<256;t++)this.p[t]=Math.floor(256*e.random());this.perm=[];for(let t=0;t<512;t++)this.perm[t]=this.p[255&t];this.simplex=[[0,1,2,3],[0,1,3,2],[0,0,0,0],[0,2,3,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,3,0],[0,2,1,3],[0,0,0,0],[0,3,1,2],[0,3,2,1],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,3,2,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[1,2,0,3],[0,0,0,0],[1,3,0,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,3,0,1],[2,3,1,0],[1,0,2,3],[1,0,3,2],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,3,1],[0,0,0,0],[2,1,3,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0],[2,0,1,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,0,1,2],[3,0,2,1],[0,0,0,0],[3,1,2,0],[2,1,0,3],[0,0,0,0],[0,0,0,0],[0,0,0,0],[3,1,0,2],[0,0,0,0],[3,2,0,1],[3,2,1,0]]}noise(e,t){let i,r,s;const n=(e+t)*(.5*(Math.sqrt(3)-1)),a=Math.floor(e+n),o=Math.floor(t+n),l=(3-Math.sqrt(3))/6,h=(a+o)*l,c=e-(a-h),d=t-(o-h);let u,p;c>d?(u=1,p=0):(u=0,p=1);const m=c-u+l,f=d-p+l,g=c-1+2*l,v=d-1+2*l,y=255&a,b=255&o,w=this.perm[y+this.perm[b]]%12,x=this.perm[y+u+this.perm[b+p]]%12,M=this.perm[y+1+this.perm[b+1]]%12;let C=.5-c*c-d*d;C<0?i=0:(C*=C,i=C*C*this._dot(this.grad3[w],c,d));let S=.5-m*m-f*f;S<0?r=0:(S*=S,r=S*S*this._dot(this.grad3[x],m,f));let _=.5-g*g-v*v;return _<0?s=0:(_*=_,s=_*_*this._dot(this.grad3[M],g,v)),70*(i+r+s)}noise3d(e,t,i){let r,s,n,a;const o=(e+t+i)*(1/3),l=Math.floor(e+o),h=Math.floor(t+o),c=Math.floor(i+o),d=1/6,u=(l+h+c)*d,p=e-(l-u),m=t-(h-u),f=i-(c-u);let g,v,y,b,w,x;p>=m?m>=f?(g=1,v=0,y=0,b=1,w=1,x=0):p>=f?(g=1,v=0,y=0,b=1,w=0,x=1):(g=0,v=0,y=1,b=1,w=0,x=1):m<f?(g=0,v=0,y=1,b=0,w=1,x=1):p<f?(g=0,v=1,y=0,b=0,w=1,x=1):(g=0,v=1,y=0,b=1,w=1,x=0);const M=p-g+d,C=m-v+d,S=f-y+d,_=p-b+2*d,T=m-w+2*d,A=f-x+2*d,P=p-1+.5,E=m-1+.5,L=f-1+.5,I=255&l,R=255&h,D=255&c,k=this.perm[I+this.perm[R+this.perm[D]]]%12,F=this.perm[I+g+this.perm[R+v+this.perm[D+y]]]%12,V=this.perm[I+b+this.perm[R+w+this.perm[D+x]]]%12,B=this.perm[I+1+this.perm[R+1+this.perm[D+1]]]%12;let O=.6-p*p-m*m-f*f;O<0?r=0:(O*=O,r=O*O*this._dot3(this.grad3[k],p,m,f));let N=.6-M*M-C*C-S*S;N<0?s=0:(N*=N,s=N*N*this._dot3(this.grad3[F],M,C,S));let U=.6-_*_-T*T-A*A;U<0?n=0:(U*=U,n=U*U*this._dot3(this.grad3[V],_,T,A));let z=.6-P*P-E*E-L*L;return z<0?a=0:(z*=z,a=z*z*this._dot3(this.grad3[B],P,E,L)),32*(r+s+n+a)}noise4d(e,t,i,r){const s=this.grad4,n=this.simplex,a=this.perm,o=(Math.sqrt(5)-1)/4,l=(5-Math.sqrt(5))/20;let h,c,d,u,p;const m=(e+t+i+r)*o,f=Math.floor(e+m),g=Math.floor(t+m),v=Math.floor(i+m),y=Math.floor(r+m),b=(f+g+v+y)*l,w=e-(f-b),x=t-(g-b),M=i-(v-b),C=r-(y-b),S=(w>x?32:0)+(w>M?16:0)+(x>M?8:0)+(w>C?4:0)+(x>C?2:0)+(M>C?1:0),_=n[S][0]>=3?1:0,T=n[S][1]>=3?1:0,A=n[S][2]>=3?1:0,P=n[S][3]>=3?1:0,E=n[S][0]>=2?1:0,L=n[S][1]>=2?1:0,I=n[S][2]>=2?1:0,R=n[S][3]>=2?1:0,D=n[S][0]>=1?1:0,k=n[S][1]>=1?1:0,F=n[S][2]>=1?1:0,V=n[S][3]>=1?1:0,B=w-_+l,O=x-T+l,N=M-A+l,U=C-P+l,z=w-E+2*l,j=x-L+2*l,$=M-I+2*l,G=C-R+2*l,q=w-D+3*l,Y=x-k+3*l,W=M-F+3*l,X=C-V+3*l,H=w-1+4*l,J=x-1+4*l,Z=M-1+4*l,K=C-1+4*l,Q=255&f,ee=255&g,te=255&v,ie=255&y,re=a[Q+a[ee+a[te+a[ie]]]]%32,se=a[Q+_+a[ee+T+a[te+A+a[ie+P]]]]%32,ne=a[Q+E+a[ee+L+a[te+I+a[ie+R]]]]%32,ae=a[Q+D+a[ee+k+a[te+F+a[ie+V]]]]%32,oe=a[Q+1+a[ee+1+a[te+1+a[ie+1]]]]%32;let le=.6-w*w-x*x-M*M-C*C;le<0?h=0:(le*=le,h=le*le*this._dot4(s[re],w,x,M,C));let he=.6-B*B-O*O-N*N-U*U;he<0?c=0:(he*=he,c=he*he*this._dot4(s[se],B,O,N,U));let ce=.6-z*z-j*j-$*$-G*G;ce<0?d=0:(ce*=ce,d=ce*ce*this._dot4(s[ne],z,j,$,G));let de=.6-q*q-Y*Y-W*W-X*X;de<0?u=0:(de*=de,u=de*de*this._dot4(s[ae],q,Y,W,X));let ue=.6-H*H-J*J-Z*Z-K*K;return ue<0?p=0:(ue*=ue,p=ue*ue*this._dot4(s[oe],H,J,Z,K)),27*(h+c+d+u+p)}_dot(e,t,i){return e[0]*t+e[1]*i}_dot3(e,t,i,r){return e[0]*t+e[1]*i+e[2]*r}_dot4(e,t,i,r,s){return e[0]*t+e[1]*i+e[2]*r+e[3]*s}}const K={defines:{PERSPECTIVE_CAMERA:1,KERNEL_SIZE:32},uniforms:{tNormal:{value:null},tDepth:{value:null},tNoise:{value:null},kernel:{value:null},cameraNear:{value:null},cameraFar:{value:null},resolution:{value:new t.Vector2},cameraProjectionMatrix:{value:new t.Matrix4},cameraInverseProjectionMatrix:{value:new t.Matrix4},kernelRadius:{value:8},minDistance:{value:.005},maxDistance:{value:.05}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\t\tuniform highp sampler2D tNormal;\n\t\tuniform highp sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getDepth( const in vec2 screenPosition ) {\n\n\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t}\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getDepth( vUv );\n\n\t\t\tif ( depth == 1.0 ) {\n\n\t\t\t\tgl_FragColor = vec4( 1.0 ); // don't influence background\n\n\t\t\t} else {\n\n\t\t\t\tfloat viewZ = getViewZ( depth );\n\n\t\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\t\t\t\tvec3 viewNormal = getViewNormal( vUv );\n\n\t\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\n\n\t\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t\t\tfloat occlusion = 0.0;\n\n\t\t\t\tfor ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 ); // project point and calculate NDC\n\t\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar ); // compute linear depth of the sample view Z value\n\t\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\t\tif ( delta > minDistance && delta < maxDistance ) { // if fragment is before sample point, increase occlusion\n\n\t\t\t\t\t\tocclusion += 1.0;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\t\tgl_FragColor = vec4( vec3( 1.0 - occlusion ), 1.0 );\n\n\t\t\t}\n\n\t\t}"},Q={defines:{PERSPECTIVE_CAMERA:1},uniforms:{tDepth:{value:null},cameraNear:{value:null},cameraFar:{value:null}},vertexShader:"varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"uniform sampler2D tDepth;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\tfloat fragCoordZ = texture2D( tDepth, screenPosition ).x;\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat depth = getLinearDepth( vUv );\n\t\t\tgl_FragColor = vec4( vec3( 1.0 - depth ), 1.0 );\n\n\t\t}"},ee={uniforms:{tDiffuse:{value:null},resolution:{value:new t.Vector2}},vertexShader:"varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}"};class te extends z{constructor(e,i,r=512,s=512,n=32){super(),this.width=r,this.height=s,this.clear=!0,this.needsSwap=!1,this.camera=i,this.scene=e,this.kernelRadius=8,this.kernel=[],this.noiseTexture=null,this.output=0,this.minDistance=.005,this.maxDistance=.1,this._visibilityCache=[],this._generateSampleKernel(n),this._generateRandomKernelRotations();const a=new t.DepthTexture;a.format=t.DepthStencilFormat,a.type=t.UnsignedInt248Type,this.normalRenderTarget=new t.WebGLRenderTarget(this.width,this.height,{minFilter:t.NearestFilter,magFilter:t.NearestFilter,type:t.HalfFloatType,depthTexture:a}),this.ssaoRenderTarget=new t.WebGLRenderTarget(this.width,this.height,{type:t.HalfFloatType}),this.blurRenderTarget=this.ssaoRenderTarget.clone(),this.ssaoMaterial=new t.ShaderMaterial({defines:Object.assign({},K.defines),uniforms:t.UniformsUtils.clone(K.uniforms),vertexShader:K.vertexShader,fragmentShader:K.fragmentShader,blending:t.NoBlending}),this.ssaoMaterial.defines.KERNEL_SIZE=n,this.ssaoMaterial.uniforms.tNormal.value=this.normalRenderTarget.texture,this.ssaoMaterial.uniforms.tDepth.value=this.normalRenderTarget.depthTexture,this.ssaoMaterial.uniforms.tNoise.value=this.noiseTexture,this.ssaoMaterial.uniforms.kernel.value=this.kernel,this.ssaoMaterial.uniforms.cameraNear.value=this.camera.near,this.ssaoMaterial.uniforms.cameraFar.value=this.camera.far,this.ssaoMaterial.uniforms.resolution.value.set(this.width,this.height),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.normalMaterial=new t.MeshNormalMaterial,this.normalMaterial.blending=t.NoBlending,this.blurMaterial=new t.ShaderMaterial({defines:Object.assign({},ee.defines),uniforms:t.UniformsUtils.clone(ee.uniforms),vertexShader:ee.vertexShader,fragmentShader:ee.fragmentShader}),this.blurMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.blurMaterial.uniforms.resolution.value.set(this.width,this.height),this.depthRenderMaterial=new t.ShaderMaterial({defines:Object.assign({},Q.defines),uniforms:t.UniformsUtils.clone(Q.uniforms),vertexShader:Q.vertexShader,fragmentShader:Q.fragmentShader,blending:t.NoBlending}),this.depthRenderMaterial.uniforms.tDepth.value=this.normalRenderTarget.depthTexture,this.depthRenderMaterial.uniforms.cameraNear.value=this.camera.near,this.depthRenderMaterial.uniforms.cameraFar.value=this.camera.far,this.copyMaterial=new t.ShaderMaterial({uniforms:t.UniformsUtils.clone(U.uniforms),vertexShader:U.vertexShader,fragmentShader:U.fragmentShader,transparent:!0,depthTest:!1,depthWrite:!1,blendSrc:t.DstColorFactor,blendDst:t.ZeroFactor,blendEquation:t.AddEquation,blendSrcAlpha:t.DstAlphaFactor,blendDstAlpha:t.ZeroFactor,blendEquationAlpha:t.AddEquation}),this._fsQuad=new q(null),this._originalClearColor=new t.Color}dispose(){this.normalRenderTarget.dispose(),this.ssaoRenderTarget.dispose(),this.blurRenderTarget.dispose(),this.normalMaterial.dispose(),this.blurMaterial.dispose(),this.copyMaterial.dispose(),this.depthRenderMaterial.dispose(),this._fsQuad.dispose()}render(e,i,r){switch(this._overrideVisibility(),this._renderOverride(e,this.normalMaterial,this.normalRenderTarget,7829503,1),this._restoreVisibility(),this.ssaoMaterial.uniforms.kernelRadius.value=this.kernelRadius,this.ssaoMaterial.uniforms.minDistance.value=this.minDistance,this.ssaoMaterial.uniforms.maxDistance.value=this.maxDistance,this._renderPass(e,this.ssaoMaterial,this.ssaoRenderTarget),this._renderPass(e,this.blurMaterial,this.blurRenderTarget),this.output){case te.OUTPUT.SSAO:this.copyMaterial.uniforms.tDiffuse.value=this.ssaoRenderTarget.texture,this.copyMaterial.blending=t.NoBlending,this._renderPass(e,this.copyMaterial,this.renderToScreen?null:r);break;case te.OUTPUT.Blur:this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=t.NoBlending,this._renderPass(e,this.copyMaterial,this.renderToScreen?null:r);break;case te.OUTPUT.Depth:this._renderPass(e,this.depthRenderMaterial,this.renderToScreen?null:r);break;case te.OUTPUT.Normal:this.copyMaterial.uniforms.tDiffuse.value=this.normalRenderTarget.texture,this.copyMaterial.blending=t.NoBlending,this._renderPass(e,this.copyMaterial,this.renderToScreen?null:r);break;case te.OUTPUT.Default:this.copyMaterial.uniforms.tDiffuse.value=this.blurRenderTarget.texture,this.copyMaterial.blending=t.CustomBlending,this._renderPass(e,this.copyMaterial,this.renderToScreen?null:r);break;default:console.warn("THREE.SSAOPass: Unknown output type.")}}setSize(e,t){this.width=e,this.height=t,this.ssaoRenderTarget.setSize(e,t),this.normalRenderTarget.setSize(e,t),this.blurRenderTarget.setSize(e,t),this.ssaoMaterial.uniforms.resolution.value.set(e,t),this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(this.camera.projectionMatrix),this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(this.camera.projectionMatrixInverse),this.blurMaterial.uniforms.resolution.value.set(e,t)}_renderPass(e,t,i,r,s){e.getClearColor(this._originalClearColor);const n=e.getClearAlpha(),a=e.autoClear;e.setRenderTarget(i),e.autoClear=!1,null!=r&&(e.setClearColor(r),e.setClearAlpha(s||0),e.clear()),this._fsQuad.material=t,this._fsQuad.render(e),e.autoClear=a,e.setClearColor(this._originalClearColor),e.setClearAlpha(n)}_renderOverride(e,t,i,r,s){e.getClearColor(this._originalClearColor);const n=e.getClearAlpha(),a=e.autoClear;e.setRenderTarget(i),e.autoClear=!1,r=t.clearColor||r,s=t.clearAlpha||s,null!=r&&(e.setClearColor(r),e.setClearAlpha(s||0),e.clear()),this.scene.overrideMaterial=t,e.render(this.scene,this.camera),this.scene.overrideMaterial=null,e.autoClear=a,e.setClearColor(this._originalClearColor),e.setClearAlpha(n)}_generateSampleKernel(e){const i=this.kernel;for(let r=0;r<e;r++){const s=new t.Vector3;s.x=2*Math.random()-1,s.y=2*Math.random()-1,s.z=Math.random(),s.normalize();let n=r/e;n=t.MathUtils.lerp(.1,1,n*n),s.multiplyScalar(n),i.push(s)}}_generateRandomKernelRotations(){const e=new Z,i=new Float32Array(16);for(let t=0;t<16;t++){const r=2*Math.random()-1,s=2*Math.random()-1,n=0;i[t]=e.noise3d(r,s,n)}this.noiseTexture=new t.DataTexture(i,4,4,t.RedFormat,t.FloatType),this.noiseTexture.wrapS=t.RepeatWrapping,this.noiseTexture.wrapT=t.RepeatWrapping,this.noiseTexture.needsUpdate=!0}_overrideVisibility(){const e=this.scene,t=this._visibilityCache;e.traverse((function(e){(e.isPoints||e.isLine||e.isLine2)&&e.visible&&(e.visible=!1,t.push(e))}))}_restoreVisibility(){const e=this._visibilityCache;for(let t=0;t<e.length;t++)e[t].visible=!0;e.length=0}}function ie(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}te.OUTPUT={Default:0,SSAO:1,Blur:2,Depth:3,Normal:4};var re={jet:[{index:0,rgb:[0,0,131]},{index:.125,rgb:[0,60,170]},{index:.375,rgb:[5,255,255]},{index:.625,rgb:[255,255,0]},{index:.875,rgb:[250,0,0]},{index:1,rgb:[128,0,0]}],hsv:[{index:0,rgb:[255,0,0]},{index:.169,rgb:[253,255,2]},{index:.173,rgb:[247,255,2]},{index:.337,rgb:[0,252,4]},{index:.341,rgb:[0,252,10]},{index:.506,rgb:[1,249,255]},{index:.671,rgb:[2,0,253]},{index:.675,rgb:[8,0,253]},{index:.839,rgb:[255,0,251]},{index:.843,rgb:[255,0,245]},{index:1,rgb:[255,0,6]}],hot:[{index:0,rgb:[0,0,0]},{index:.3,rgb:[230,0,0]},{index:.6,rgb:[255,210,0]},{index:1,rgb:[255,255,255]}],spring:[{index:0,rgb:[255,0,255]},{index:1,rgb:[255,255,0]}],summer:[{index:0,rgb:[0,128,102]},{index:1,rgb:[255,255,102]}],autumn:[{index:0,rgb:[255,0,0]},{index:1,rgb:[255,255,0]}],winter:[{index:0,rgb:[0,0,255]},{index:1,rgb:[0,255,128]}],bone:[{index:0,rgb:[0,0,0]},{index:.376,rgb:[84,84,116]},{index:.753,rgb:[169,200,200]},{index:1,rgb:[255,255,255]}],copper:[{index:0,rgb:[0,0,0]},{index:.804,rgb:[255,160,102]},{index:1,rgb:[255,199,127]}],greys:[{index:0,rgb:[0,0,0]},{index:1,rgb:[255,255,255]}],yignbu:[{index:0,rgb:[8,29,88]},{index:.125,rgb:[37,52,148]},{index:.25,rgb:[34,94,168]},{index:.375,rgb:[29,145,192]},{index:.5,rgb:[65,182,196]},{index:.625,rgb:[127,205,187]},{index:.75,rgb:[199,233,180]},{index:.875,rgb:[237,248,217]},{index:1,rgb:[255,255,217]}],greens:[{index:0,rgb:[0,68,27]},{index:.125,rgb:[0,109,44]},{index:.25,rgb:[35,139,69]},{index:.375,rgb:[65,171,93]},{index:.5,rgb:[116,196,118]},{index:.625,rgb:[161,217,155]},{index:.75,rgb:[199,233,192]},{index:.875,rgb:[229,245,224]},{index:1,rgb:[247,252,245]}],yiorrd:[{index:0,rgb:[128,0,38]},{index:.125,rgb:[189,0,38]},{index:.25,rgb:[227,26,28]},{index:.375,rgb:[252,78,42]},{index:.5,rgb:[253,141,60]},{index:.625,rgb:[254,178,76]},{index:.75,rgb:[254,217,118]},{index:.875,rgb:[255,237,160]},{index:1,rgb:[255,255,204]}],bluered:[{index:0,rgb:[0,0,255]},{index:1,rgb:[255,0,0]}],rdbu:[{index:0,rgb:[5,10,172]},{index:.35,rgb:[106,137,247]},{index:.5,rgb:[190,190,190]},{index:.6,rgb:[220,170,132]},{index:.7,rgb:[230,145,90]},{index:1,rgb:[178,10,28]}],picnic:[{index:0,rgb:[0,0,255]},{index:.1,rgb:[51,153,255]},{index:.2,rgb:[102,204,255]},{index:.3,rgb:[153,204,255]},{index:.4,rgb:[204,204,255]},{index:.5,rgb:[255,255,255]},{index:.6,rgb:[255,204,255]},{index:.7,rgb:[255,153,255]},{index:.8,rgb:[255,102,204]},{index:.9,rgb:[255,102,102]},{index:1,rgb:[255,0,0]}],rainbow:[{index:0,rgb:[150,0,90]},{index:.125,rgb:[0,0,200]},{index:.25,rgb:[0,25,255]},{index:.375,rgb:[0,152,255]},{index:.5,rgb:[44,255,150]},{index:.625,rgb:[151,255,0]},{index:.75,rgb:[255,234,0]},{index:.875,rgb:[255,111,0]},{index:1,rgb:[255,0,0]}],portland:[{index:0,rgb:[12,51,131]},{index:.25,rgb:[10,136,186]},{index:.5,rgb:[242,211,56]},{index:.75,rgb:[242,143,56]},{index:1,rgb:[217,30,30]}],blackbody:[{index:0,rgb:[0,0,0]},{index:.2,rgb:[230,0,0]},{index:.4,rgb:[230,210,0]},{index:.7,rgb:[255,255,255]},{index:1,rgb:[160,200,255]}],earth:[{index:0,rgb:[0,0,130]},{index:.1,rgb:[0,180,180]},{index:.2,rgb:[40,210,40]},{index:.4,rgb:[230,230,50]},{index:.6,rgb:[120,70,20]},{index:1,rgb:[255,255,255]}],electric:[{index:0,rgb:[0,0,0]},{index:.15,rgb:[30,0,100]},{index:.4,rgb:[120,0,100]},{index:.6,rgb:[160,90,0]},{index:.8,rgb:[230,200,0]},{index:1,rgb:[255,250,220]}],alpha:[{index:0,rgb:[255,255,255,0]},{index:1,rgb:[255,255,255,1]}],viridis:[{index:0,rgb:[68,1,84]},{index:.13,rgb:[71,44,122]},{index:.25,rgb:[59,81,139]},{index:.38,rgb:[44,113,142]},{index:.5,rgb:[33,144,141]},{index:.63,rgb:[39,173,129]},{index:.75,rgb:[92,200,99]},{index:.88,rgb:[170,220,50]},{index:1,rgb:[253,231,37]}],inferno:[{index:0,rgb:[0,0,4]},{index:.13,rgb:[31,12,72]},{index:.25,rgb:[85,15,109]},{index:.38,rgb:[136,34,106]},{index:.5,rgb:[186,54,85]},{index:.63,rgb:[227,89,51]},{index:.75,rgb:[249,140,10]},{index:.88,rgb:[249,201,50]},{index:1,rgb:[252,255,164]}],magma:[{index:0,rgb:[0,0,4]},{index:.13,rgb:[28,16,68]},{index:.25,rgb:[79,18,123]},{index:.38,rgb:[129,37,129]},{index:.5,rgb:[181,54,122]},{index:.63,rgb:[229,80,100]},{index:.75,rgb:[251,135,97]},{index:.88,rgb:[254,194,135]},{index:1,rgb:[252,253,191]}],plasma:[{index:0,rgb:[13,8,135]},{index:.13,rgb:[75,3,161]},{index:.25,rgb:[125,3,168]},{index:.38,rgb:[168,34,150]},{index:.5,rgb:[203,70,121]},{index:.63,rgb:[229,107,93]},{index:.75,rgb:[248,148,65]},{index:.88,rgb:[253,195,40]},{index:1,rgb:[240,249,33]}],warm:[{index:0,rgb:[125,0,179]},{index:.13,rgb:[172,0,187]},{index:.25,rgb:[219,0,170]},{index:.38,rgb:[255,0,130]},{index:.5,rgb:[255,63,74]},{index:.63,rgb:[255,123,0]},{index:.75,rgb:[234,176,0]},{index:.88,rgb:[190,228,0]},{index:1,rgb:[147,255,0]}],cool:[{index:0,rgb:[125,0,179]},{index:.13,rgb:[116,0,218]},{index:.25,rgb:[98,74,237]},{index:.38,rgb:[68,146,231]},{index:.5,rgb:[0,204,197]},{index:.63,rgb:[0,247,146]},{index:.75,rgb:[0,255,88]},{index:.88,rgb:[40,255,8]},{index:1,rgb:[147,255,0]}],"rainbow-soft":[{index:0,rgb:[125,0,179]},{index:.1,rgb:[199,0,180]},{index:.2,rgb:[255,0,121]},{index:.3,rgb:[255,108,0]},{index:.4,rgb:[222,194,0]},{index:.5,rgb:[150,255,0]},{index:.6,rgb:[0,255,55]},{index:.7,rgb:[0,246,150]},{index:.8,rgb:[50,167,222]},{index:.9,rgb:[103,51,235]},{index:1,rgb:[124,0,186]}],bathymetry:[{index:0,rgb:[40,26,44]},{index:.13,rgb:[59,49,90]},{index:.25,rgb:[64,76,139]},{index:.38,rgb:[63,110,151]},{index:.5,rgb:[72,142,158]},{index:.63,rgb:[85,174,163]},{index:.75,rgb:[120,206,163]},{index:.88,rgb:[187,230,172]},{index:1,rgb:[253,254,204]}],cdom:[{index:0,rgb:[47,15,62]},{index:.13,rgb:[87,23,86]},{index:.25,rgb:[130,28,99]},{index:.38,rgb:[171,41,96]},{index:.5,rgb:[206,67,86]},{index:.63,rgb:[230,106,84]},{index:.75,rgb:[242,149,103]},{index:.88,rgb:[249,193,135]},{index:1,rgb:[254,237,176]}],chlorophyll:[{index:0,rgb:[18,36,20]},{index:.13,rgb:[25,63,41]},{index:.25,rgb:[24,91,59]},{index:.38,rgb:[13,119,72]},{index:.5,rgb:[18,148,80]},{index:.63,rgb:[80,173,89]},{index:.75,rgb:[132,196,122]},{index:.88,rgb:[175,221,162]},{index:1,rgb:[215,249,208]}],density:[{index:0,rgb:[54,14,36]},{index:.13,rgb:[89,23,80]},{index:.25,rgb:[110,45,132]},{index:.38,rgb:[120,77,178]},{index:.5,rgb:[120,113,213]},{index:.63,rgb:[115,151,228]},{index:.75,rgb:[134,185,227]},{index:.88,rgb:[177,214,227]},{index:1,rgb:[230,241,241]}],"freesurface-blue":[{index:0,rgb:[30,4,110]},{index:.13,rgb:[47,14,176]},{index:.25,rgb:[41,45,236]},{index:.38,rgb:[25,99,212]},{index:.5,rgb:[68,131,200]},{index:.63,rgb:[114,156,197]},{index:.75,rgb:[157,181,203]},{index:.88,rgb:[200,208,216]},{index:1,rgb:[241,237,236]}],"freesurface-red":[{index:0,rgb:[60,9,18]},{index:.13,rgb:[100,17,27]},{index:.25,rgb:[142,20,29]},{index:.38,rgb:[177,43,27]},{index:.5,rgb:[192,87,63]},{index:.63,rgb:[205,125,105]},{index:.75,rgb:[216,162,148]},{index:.88,rgb:[227,199,193]},{index:1,rgb:[241,237,236]}],oxygen:[{index:0,rgb:[64,5,5]},{index:.13,rgb:[106,6,15]},{index:.25,rgb:[144,26,7]},{index:.38,rgb:[168,64,3]},{index:.5,rgb:[188,100,4]},{index:.63,rgb:[206,136,11]},{index:.75,rgb:[220,174,25]},{index:.88,rgb:[231,215,44]},{index:1,rgb:[248,254,105]}],par:[{index:0,rgb:[51,20,24]},{index:.13,rgb:[90,32,35]},{index:.25,rgb:[129,44,34]},{index:.38,rgb:[159,68,25]},{index:.5,rgb:[182,99,19]},{index:.63,rgb:[199,134,22]},{index:.75,rgb:[212,171,35]},{index:.88,rgb:[221,210,54]},{index:1,rgb:[225,253,75]}],phase:[{index:0,rgb:[145,105,18]},{index:.13,rgb:[184,71,38]},{index:.25,rgb:[186,58,115]},{index:.38,rgb:[160,71,185]},{index:.5,rgb:[110,97,218]},{index:.63,rgb:[50,123,164]},{index:.75,rgb:[31,131,110]},{index:.88,rgb:[77,129,34]},{index:1,rgb:[145,105,18]}],salinity:[{index:0,rgb:[42,24,108]},{index:.13,rgb:[33,50,162]},{index:.25,rgb:[15,90,145]},{index:.38,rgb:[40,118,137]},{index:.5,rgb:[59,146,135]},{index:.63,rgb:[79,175,126]},{index:.75,rgb:[120,203,104]},{index:.88,rgb:[193,221,100]},{index:1,rgb:[253,239,154]}],temperature:[{index:0,rgb:[4,35,51]},{index:.13,rgb:[23,51,122]},{index:.25,rgb:[85,59,157]},{index:.38,rgb:[129,79,143]},{index:.5,rgb:[175,95,130]},{index:.63,rgb:[222,112,101]},{index:.75,rgb:[249,146,66]},{index:.88,rgb:[249,196,65]},{index:1,rgb:[232,250,91]}],turbidity:[{index:0,rgb:[34,31,27]},{index:.13,rgb:[65,50,41]},{index:.25,rgb:[98,69,52]},{index:.38,rgb:[131,89,57]},{index:.5,rgb:[161,112,59]},{index:.63,rgb:[185,140,66]},{index:.75,rgb:[202,174,88]},{index:.88,rgb:[216,209,126]},{index:1,rgb:[233,246,171]}],"velocity-blue":[{index:0,rgb:[17,32,64]},{index:.13,rgb:[35,52,116]},{index:.25,rgb:[29,81,156]},{index:.38,rgb:[31,113,162]},{index:.5,rgb:[50,144,169]},{index:.63,rgb:[87,173,176]},{index:.75,rgb:[149,196,189]},{index:.88,rgb:[203,221,211]},{index:1,rgb:[254,251,230]}],"velocity-green":[{index:0,rgb:[23,35,19]},{index:.13,rgb:[24,64,38]},{index:.25,rgb:[11,95,45]},{index:.38,rgb:[39,123,35]},{index:.5,rgb:[95,146,12]},{index:.63,rgb:[152,165,18]},{index:.75,rgb:[201,186,69]},{index:.88,rgb:[233,216,137]},{index:1,rgb:[255,253,205]}],cubehelix:[{index:0,rgb:[0,0,0]},{index:.07,rgb:[22,5,59]},{index:.13,rgb:[60,4,105]},{index:.2,rgb:[109,1,135]},{index:.27,rgb:[161,0,147]},{index:.33,rgb:[210,2,142]},{index:.4,rgb:[251,11,123]},{index:.47,rgb:[255,29,97]},{index:.53,rgb:[255,54,69]},{index:.6,rgb:[255,85,46]},{index:.67,rgb:[255,120,34]},{index:.73,rgb:[255,157,37]},{index:.8,rgb:[241,191,57]},{index:.87,rgb:[224,220,93]},{index:.93,rgb:[218,241,142]},{index:1,rgb:[227,253,198]}]},se=function(e,t,i){return e*(1-i)+t*i};function ne(e){return[e[0]/255,e[1]/255,e[2]/255,e[3]]}function ae(e){for(var t,i="#",r=0;r<3;++r)i+=("00"+(t=(t=e[r]).toString(16))).substr(t.length);return i}function oe(e){return"rgba("+e.join(",")+")"}const le=ie((function(e){var t,i,r,s,n,a,o,l,h,c;e||(e={});l=(e.nshades||72)-1,o=e.format||"hex",(a=e.colormap)||(a="jet");if("string"==typeof a){if(a=a.toLowerCase(),!re[a])throw Error(a+" not a supported colorscale");n=re[a]}else{if(!Array.isArray(a))throw Error("unsupported colormap option",a);n=a.slice()}if(n.length>l+1)throw new Error(a+" map requires nshades to be at least size "+n.length);h=Array.isArray(e.alpha)?2!==e.alpha.length?[1,1]:e.alpha.slice():"number"==typeof e.alpha?[e.alpha,e.alpha]:[1,1];t=n.map((function(e){return Math.round(e.index*l)})),h[0]=Math.min(Math.max(h[0],0),1),h[1]=Math.min(Math.max(h[1],0),1);var d=n.map((function(e,t){var i=n[t].index,r=n[t].rgb.slice();return 4===r.length&&r[3]>=0&&r[3]<=1||(r[3]=h[0]+(h[1]-h[0])*i),r})),u=[];for(c=0;c<t.length-1;++c){s=t[c+1]-t[c],i=d[c],r=d[c+1];for(var p=0;p<s;p++){var m=p/s;u.push([Math.round(se(i[0],r[0],m)),Math.round(se(i[1],r[1],m)),Math.round(se(i[2],r[2],m)),se(i[3],r[3],m)])}}u.push(n[n.length-1].rgb.concat(h[1])),"hex"===o?u=u.map(ae):"rgbaString"===o?u=u.map(oe):"float"===o&&(u=u.map(ne));return u}));class he{constructor(){this._events=Object.create(null)}on(e,t){if("function"!=typeof t)throw new TypeError("listener must be a function");return this._events[e]||(this._events[e]=[]),this._events[e].push(t),()=>this.removeListener(e,t)}once(e,t){if("function"!=typeof t)throw new TypeError("listener must be a function");const i=(...r)=>{this.removeListener(e,i),t(...r)};return this.on(e,i)}emit(e,...t){this._events[e]&&[...this._events[e]].forEach((e=>e(...t)))}removeListener(e,t){this._events[e]&&(this._events[e]=this._events[e].filter((e=>e!==t)),0===this._events[e].length&&delete this._events[e])}removeAllListeners(e){e?delete this._events[e]:this._events=Object.create(null)}off(e,t){return this.removeListener(e,t)}}let ce=!1;function de(...e){ce&&console.log(...e)}const ue={blues:[16251903,13032431,7057110,545180],reds:[16774640,16559761,16476746,13309981],oranges:[16774635,16625259,15821075,10892803],purples:[16579581,12369372,7695281,4128893],rdylbu:[10813478,14102567,16018755,16625249,16703632,14742520,11262441,7646673,4552116,3225237],rdylgn:[10813478,14102567,16018755,16625249,16703627,14282635,10934634,6733155,1742928,26679],spectral:[10355010,13975119,16018755,16625249,16703627,15136152,11263396,6734501,3311805,6180770],coolwarm:[3886272,7833816,11780847,14607599,16234652,15631464,14102567,8323072],bwr:[255,16777215,16711680],seismic:[255,49087,16777215,16744319,16711680]},pe=class e extends he{constructor(e,t={}){if(super(),!Array.isArray(e)||0===e.length)throw new TypeError("Colors must be a non-empty array");this.colors=e.map((e=>this.parseColor(e))),this._hasAlpha=4===this.colors[0].length,this.range=[0,1],this.threshold=[0,0],this.alpha=1,this.setRange(t.range),this.setThreshold(t.threshold),this.setAlpha(t.alpha)}setRange(e){Array.isArray(e)&&2===e.length&&e.every((e=>"number"==typeof e))?(this.range=e,de("ColorMap: Emitting rangeChanged event",this.range),this.emit("rangeChanged",this.range)):this.range=[0,1]}setThreshold(e){Array.isArray(e)&&2===e.length&&e.every((e=>"number"==typeof e))?(this.threshold=e,de("ColorMap: Emitting thresholdChanged event",this.threshold),this.emit("thresholdChanged",this.threshold)):this.threshold=[0,0]}parseColor(e){if("string"==typeof e&&e.startsWith("#"))return this.hexToRgb(e);if(!Array.isArray(e)||3!==e.length&&4!==e.length)throw new TypeError(`Invalid color specification: ${e}`);return e.map((e=>{if("number"!=typeof e||e<0||e>1)throw new TypeError(`Color components must be numbers in the range [0, 1], got ${e}`);return e}))}hexToRgb(e){const t=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);if(!t)throw new TypeError(`Invalid hex color: ${e}`);return[parseInt(t[1],16)/255,parseInt(t[2],16)/255,parseInt(t[3],16)/255]}getColor(e){const[t,i]=this.range,[r,s]=this.threshold;if(r!==s&&e>=r&&e<=s)return this.hasAlpha()?[0,0,0,0]:[0,0,0];const n=i-t,a=0===n?0:Math.max(0,Math.min(1,(e-t)/n)),o=Math.min(Math.floor(a*(this.colors.length-1)),this.colors.length-1),l=this.colors[o];return l&&Array.isArray(l)?this._hasAlpha&&4===l.length&&1!==this.alpha?[l[0],l[1],l[2],l[3]*this.alpha]:l:(console.warn(`ColorMap.getColor: Invalid color at index ${o}, returning fallback`),this.hasAlpha()?[.5,.5,.5,1]:[.5,.5,.5])}hasAlpha(){return this._hasAlpha}setAlpha(e){"number"==typeof e&&e>=0&&e<=1?(this.alpha=e,de("ColorMap: Emitting alphaChanged event",this.alpha),this.emit("alphaChanged",this.alpha)):this.alpha=1}getRange(){return this.range}getThreshold(){return this.threshold}getAlpha(){return this.alpha}static generatePreset(t,i=256){de(`ColorMap: Generating preset colormap: ${t} with ${i} shades`);const r=t.toLowerCase();if(ue[r])return de(`ColorMap: Using custom preset for ${t}`),e.buildGradient(ue[r],i);try{const e=le({colormap:t,nshades:i,format:"float"});if(!Array.isArray(e)||0===e.length)throw new Error(`Colormap "${t}" returned no colors`);const r=e.filter((e=>null!=e&&Array.isArray(e)&&e.length>=3));if(0===r.length)throw new Error(`Colormap "${t}" has no valid color entries after filtering`);return de(`ColorMap: Generated ${r.length} colors for ${t}`),r}catch(s){throw de(`ColorMap: Failed to generate colormap ${t}:`,s),new Error(`Colormap "${t}" is not supported`)}}static fromArray(t,i={}){return new e(t,i)}static toHex(e){if("number"==typeof e)return e;const t=e.startsWith("#")?e:`#${e}`;return new r.Color(t).getHex()}static lerp(e,t,i){return e+(t-e)*i}static buildGradient(t,i){const s=t.map((e=>new r.Color(e))),n=t.length-1;if(n<=0)return[];const a=[];for(let r=0;r<i;r++){const t=r/Math.max(1,i-1)*n,o=Math.min(Math.floor(t),n-1),l=t-o,h=s[o],c=s[o+1];a.push([e.lerp(h.r,c.r,l),e.lerp(h.g,c.g,l),e.lerp(h.b,c.b,l)])}return a}static getPresetMaps(){if(!e.presetMaps){e.presetMaps={};const i=["jet","hsv","hot","cool","spring","summer","autumn","winter","bone","copper","greys","greens","bluered","RdBu","picnic","rainbow","portland","blackbody","earth","electric","viridis","inferno","magma","plasma","warm","rainbow-soft","bathymetry","cdom","chlorophyll","density","freesurface-blue","freesurface-red","oxygen","par","phase","salinity","temperature","turbidity","velocity-blue","velocity-green","cubehelix","blues","reds","oranges","purples","RdYlBu","RdYlGn","Spectral","coolwarm","bwr","seismic"];for(const r of i)try{const t=e.generatePreset(r);t&&t.length>0&&(e.presetMaps[r]=t)}catch(t){}if(!e.presetMaps.hot){const t=256,i=[];for(let e=0;e<t;e++){const r=e/(t-1);let s,n,a;r<1/3?(s=3*r,n=0,a=0):r<2/3?(s=1,n=3*(r-1/3),a=0):(s=1,n=1,a=3*(r-2/3)),i.push([s,n,a,1])}e.presetMaps.hot=i}if(!e.presetMaps.jet){const t=256,i=[];for(let e=0;e<t;e++){const r=e/(t-1);let s,n,a;r<.125?(s=0,n=0,a=.5+4*r):r<.375?(s=0,n=4*(r-.125),a=1):r<.625?(s=4*(r-.375),n=1,a=1-4*(r-.375)):r<.875?(s=1,n=1-4*(r-.625),a=0):(s=1-4*(r-.875),n=0,a=0),i.push([s,n,a,1])}e.presetMaps.jet=i}if(e.presetMaps.gray||e.presetMaps.greys)e.presetMaps.greys&&!e.presetMaps.gray?(e.presetMaps.gray=e.presetMaps.greys,e.presetMaps.grays=e.presetMaps.greys,e.presetMaps.grey=e.presetMaps.greys):e.presetMaps.gray&&!e.presetMaps.greys&&(e.presetMaps.greys=e.presetMaps.gray,e.presetMaps.grays=e.presetMaps.gray,e.presetMaps.grey=e.presetMaps.gray);else{const t=256,i=[];for(let e=0;e<t;e++){const r=e/(t-1);i.push([r,r,r,1])}e.presetMaps.gray=i,e.presetMaps.grays=i,e.presetMaps.grey=i,e.presetMaps.greys=i}de("ColorMap: Available presets:",Object.keys(e.presetMaps))}return e.presetMaps}static getAvailableMaps(){const t=e.getPresetMaps();return Object.keys(t)}static fromPreset(t,i={}){const r=e.getPresetMaps();let s=r[t];if(s||"gray"!==t&&"grey"!==t&&"grays"!==t||(s=r.greys||r.gray||r.grey),!s&&(de(`ColorMap.fromPreset: Preset "${t}" not found, falling back to viridis`),s=r.viridis||r.jet,!s))throw new Error(`Preset "${t}" not found and no fallback available`);if(!Array.isArray(s)||0===s.length)throw new Error(`Preset "${t}" has invalid or empty colors array`);const n=s.filter((e=>null!=e&&Array.isArray(e)));if(0===n.length)throw new Error(`Preset "${t}" has no valid color entries`);return de(`ColorMap.fromPreset: Created ${t} colormap with ${n.length} colors`),new e(n,i)}};pe.presetMaps=null;let me=pe;me.getPresetMaps();class fe{static buildAdjacencyList(e,t){var i,r,s,n,a,o;const l=new Map,h=e.length/3;for(let c=0;c<h;c++)l.set(c,new Set);for(let c=0;c<t.length;c+=3){const e=t[c],h=t[c+1],d=t[c+2];null==(i=l.get(e))||i.add(h),null==(r=l.get(e))||r.add(d),null==(s=l.get(h))||s.add(e),null==(n=l.get(h))||n.add(d),null==(a=l.get(d))||a.add(e),null==(o=l.get(d))||o.add(h)}return l}static smooth(e,t,i=1,r=.5,s=!1){if(r<-1||r>1)throw new Error("Lambda must be between -1 and 1");console.log(`Laplacian smoothing: ${i} iterations, lambda=${r}, boundarySmoothing=${s}`);const n=e.length/3,a=this.buildAdjacencyList(e,t),o=new Set;if(!s){const e=new Map;for(let i=0;i<t.length;i+=3){const r=t[i],s=t[i+1],n=t[i+2];[[Math.min(r,s),Math.max(r,s)],[Math.min(s,n),Math.max(s,n)],[Math.min(n,r),Math.max(n,r)]].forEach((([t,i])=>{const r=`${t}-${i}`;e.set(r,(e.get(r)||0)+1)}))}e.forEach(((e,t)=>{if(1===e){const[e,i]=t.split("-").map(Number);o.add(e),o.add(i)}}))}for(let l=0;l<i;l++){const t=new Float32Array(e);for(let i=0;i<n;i++){if(!s&&o.has(i))continue;const n=a.get(i);if(!n||0===n.size)continue;let l=0,h=0,c=0;n.forEach((t=>{l+=e[3*t],h+=e[3*t+1],c+=e[3*t+2]}));const d=n.size;l/=d,h/=d,c/=d;const u=3*i;t[u]=e[u]+r*(l-e[u]),t[u+1]=e[u+1]+r*(h-e[u+1]),t[u+2]=e[u+2]+r*(c-e[u+2])}e.set(t)}return e}static taubinSmooth(e,t,i=1,r=.5,s=-.53,n=!1){console.log(`Taubin smoothing: ${i} iterations, lambda=${r}, mu=${s}`);for(let a=0;a<i;a++)this.smooth(e,t,1,r,n),this.smooth(e,t,1,s,n);return e}static smoothGeometry(e,t=1,i=.5,r="laplacian",s=!1,n=-.53){const a=e.getAttribute("position");if(!a)throw new Error("Geometry must have position attribute");const o=e.getIndex();if(!o)throw new Error("Geometry must have index attribute");const l=a.array,h=o.array;"taubin"===r?this.taubinSmooth(l,h,t,i,n,s):this.smooth(l,h,t,i,s),a.needsUpdate=!0,e.computeVertexNormals(),e.computeBoundingBox(),e.computeBoundingSphere()}}function ge(e,t){if(t<=0)throw new Error("vertexCount must be positive");if(e.length%3!=0)throw new Error("faces length must be divisible by 3");const i=new Array(t),r=new Array(t);for(let s=0;s<t;s++)i[s]=new Set,r[s]=[];for(let s=0;s<e.length;s+=3){const t=e[s],n=e[s+1],a=e[s+2],o=s/3;i[t].add(n),i[t].add(a),i[n].add(t),i[n].add(a),i[a].add(t),i[a].add(n),r[t].push(o),r[n].push(o),r[a].push(o)}return{neighbors:i,vertexFaces:r,vertexCount:t}}class ve{constructor(e,t,i,r=null){this.vertices=new Float32Array(e),this.faces=new Uint32Array(t),this.hemi=i,this.vertexCurv=r?new Float32Array(r):null,this.mesh=null,this.hemisphere=i,this._boundsCache=null,this._adjacencyCache=null,de("SurfaceGeometry constructor called"),de("Vertices:",this.vertices.length),de("Faces:",this.faces.length),de("Hemi:",this.hemi),this.createMesh()}createMesh(){try{const e=new r.BufferGeometry;e.setAttribute("position",new r.Float32BufferAttribute(this.vertices,3)),e.setIndex(new r.Uint32BufferAttribute(this.faces,1)),this.vertexCurv&&e.setAttribute("curv",new r.Float32BufferAttribute(this.vertexCurv,1));const t=new r.MeshPhongMaterial({color:11119017,flatShading:!1,vertexColors:!1,emissive:657930,emissiveIntensity:.2,specular:5592405,shininess:30});this.mesh=new r.Mesh(e,t),de("SurfaceGeometry construction complete"),de("Mesh:",this.mesh)}catch(e){throw console.error("Error creating mesh:",e),e}}getVertexCount(){return this.vertices.length/3}getBounds(){if(this._boundsCache)return this._boundsCache;let e=1/0,t=1/0,i=1/0,s=-1/0,n=-1/0,a=-1/0;for(let r=0;r<this.vertices.length;r+=3){const o=this.vertices[r],l=this.vertices[r+1],h=this.vertices[r+2];e=Math.min(e,o),s=Math.max(s,o),t=Math.min(t,l),n=Math.max(n,l),i=Math.min(i,h),a=Math.max(a,h)}const o=new r.Vector3(e,t,i),l=new r.Vector3(s,n,a),h=(new r.Vector3).addVectors(o,l).multiplyScalar(.5),c=(new r.Vector3).subVectors(l,o),d=c.length()/2;return this._boundsCache={min:o,max:l,center:h,size:c,radius:d},this._boundsCache}invalidateBounds(){this._boundsCache=null}getAdjacency(){return this._adjacencyCache||(this._adjacencyCache=ge(this.faces,this.getVertexCount())),this._adjacencyCache}dispose(){this.mesh&&(this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.material&&(Array.isArray(this.mesh.material)?this.mesh.material.forEach((e=>e.dispose())):this.mesh.material.dispose()),this.mesh=null),this._adjacencyCache=null,this.vertices=null,this.faces=null,this.vertexCurv=null}}class ye extends he{calculateDataRange(e){if(!e||0===e.length)return[0,0];let t=1/0,i=-1/0;for(let r=0;r<e.length;r++){const s=e[r];isFinite(s)&&(t=Math.min(t,s),i=Math.max(i,s))}return t===1/0||i===-1/0?[0,0]:[t,i]}computeNormals(e){var t;this.config.flatShading?null==(t=e.computeFaceNormals)||t.call(e):(e.computeVertexNormals(),void 0!==this.config.smoothingAngle&&this.config.smoothingAngle<180&&(this.config.smoothingAngle,Math.PI,de(`Smoothing angle set to ${this.config.smoothingAngle} degrees`)))}constructor(e,t,i,s={}){if(super(),this.geometry=e,t&&0!==t.length)this.indices=new Uint32Array(t);else{const t=e.vertices.length/3;this.indices=new Uint32Array(Array.from({length:t},((e,t)=>t))),de("Using default indices (identity mapping) for",t,"vertices")}this.data=new Float32Array(i),this.vertexCurv=e.vertexCurv||null,this.mesh=null,this.threshold=Array.isArray(s.thresh)?s.thresh:[0,0],this.irange=s.irange||this.calculateDataRange(i),this.hemisphere=e.hemisphere,this.config={color:new r.Color(11119017),flatShading:!1,smoothingAngle:void 0,shininess:30,specularColor:5592405,emissive:new r.Color(657930),emissiveIntensity:.2,alpha:1,thresh:this.threshold,irange:this.irange,...s}}update(e,t){const i=`update${e.charAt(0).toUpperCase()+e.slice(1)}`;this[i]?this[i](t):console.warn(`Update method for ${e} not implemented in ${this.constructor.name}`)}updateConfig(e){const t={...this.config};if(this.config={...this.config,...e},this.mesh&&this.mesh.material){const i=this.mesh.material;if(e.materialType&&e.materialType!==t.materialType){const e=this.mesh;return this.mesh=this.createMesh(),e.parent&&(e.parent.add(this.mesh),e.parent.remove(e)),Array.isArray(e.material)?e.material.forEach((e=>e.dispose())):e.material.dispose(),void this.updateColors()}void 0!==this.config.color&&(i.color=this.config.color instanceof r.Color?this.config.color:new r.Color(this.config.color)),i instanceof r.MeshPhongMaterial?(void 0!==this.config.specularColor&&(i.specular=new r.Color(this.config.specularColor)),void 0!==this.config.shininess&&(i.shininess=this.config.shininess)):(i instanceof r.MeshStandardMaterial||i instanceof r.MeshPhysicalMaterial)&&(void 0!==this.config.metalness&&(i.metalness=this.config.metalness),void 0!==this.config.roughness&&(i.roughness=this.config.roughness)),void 0!==this.config.emissive&&(i.emissive=this.config.emissive instanceof r.Color?this.config.emissive:new r.Color(this.config.emissive)),void 0!==this.config.emissiveIntensity&&(i.emissiveIntensity=this.config.emissiveIntensity),void 0!==this.config.flatShading&&(i.flatShading=this.config.flatShading),void 0!==this.config.alpha&&(i.transparent=this.config.alpha<1,i.opacity=this.config.alpha,i.depthWrite=this.config.alpha>=1),i.needsUpdate=!0,t.alpha!==this.config.alpha&&this.emit("opacity:changed",{surface:this,opacity:this.config.alpha}),t.color!==this.config.color&&this.emit("color:changed",{surface:this,color:this.config.color}),this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}}setVisible(e){this.mesh&&(this.mesh.visible=e,this.emit("visibility:changed",{surface:this,visible:e}),this.emit("render:needed",{surface:this}))}setOpacity(e){this.updateConfig({alpha:e})}setSmoothShading(e,t){if(this.updateConfig({flatShading:!e,smoothingAngle:t}),this.mesh&&this.mesh.geometry){this.computeNormals(this.mesh.geometry);const e=this.mesh.geometry.getAttribute("normal");e&&(e.needsUpdate=!0)}}applyLaplacianSmoothing(e=1,t=.5,i="laplacian",r=!0){if(this.mesh&&this.mesh.geometry)try{fe.smoothGeometry(this.mesh.geometry,e,t,i,!r);const s=this.mesh.geometry.getAttribute("position");s&&this.geometry.vertices&&(this.geometry.vertices=new Float32Array(s.array)),this.emit("geometry:smoothed",{surface:this,iterations:e,lambda:t,method:i}),this.emit("geometry:updated",{surface:this}),this.emit("render:needed",{surface:this}),de(`Applied ${i} smoothing: ${e} iterations, lambda=${t}`)}catch(s){console.error("Error applying Laplacian smoothing:",s)}else console.warn("Cannot apply smoothing: mesh not initialized")}createSmoothedCopy(e=1,t=.5,i="laplacian"){const r=new Float32Array(this.geometry.vertices),s=new Uint32Array(this.geometry.faces);return"taubin"===i?fe.taubinSmooth(r,s,e,t):fe.smooth(r,s,e,t),new ve(r,s,this.geometry.hemi,this.geometry.vertexCurv)}updateMesh(){var e,t;if(!this.mesh)return this.createMesh();const i=this.mesh.geometry,r=i.attributes.position;return r&&(r.needsUpdate=!0),i.index&&(i.index.needsUpdate=!0),this.geometry&&(null==(t=(e=this.geometry).invalidateBounds)||t.call(e)),this.emit("geometry:updated",{surface:this}),this.emit("render:needed",{surface:this}),this.mesh}dispose(){this.emit("dispose",{surface:this}),this.mesh&&(this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.material&&(Array.isArray(this.mesh.material)?this.mesh.material.forEach((e=>e.dispose())):this.mesh.material.dispose()),this.mesh=null),this.geometry=null,this.indices=null,this.data=null,this.vertexCurv=null,this.removeAllListeners()}}class be extends ye{constructor(e,t,i,r,s={}){super(e,t,i,s),this.colorMap=null,this.rangeListener=null,this.thresholdListener=null,this.alphaListener=null,this.createMesh(),r&&this.setColorMap(r)}setColorMap(e){if(this.removeColorMapListeners(),e instanceof me)this.colorMap=e;else if("string"==typeof e)try{this.colorMap=me.fromPreset(e)}catch(t){const i=me.getAvailableMaps(),r=i.includes("jet")?"jet":i[0]||"jet";console.warn(`ColorMappedNeuroSurface: preset "${e}" unavailable, falling back to "${r}"`,t),this.colorMap=me.fromPreset(r)}else Array.isArray(e)?this.colorMap=new me(e):(console.error("Invalid colorMap provided. Using default."),this.colorMap=me.fromPreset("jet"));this.colorMap.setThreshold(this.threshold),this.colorMap.setRange(this.irange),this.colorMap.setAlpha(this.config.alpha),this.rangeListener=this.colorMap.on("rangeChanged",(e=>{de("ColorMappedNeuroSurface: Received rangeChanged event",e),this.irange=e,this.updateColors()})),this.thresholdListener=this.colorMap.on("thresholdChanged",(e=>{de("ColorMappedNeuroSurface: Received thresholdChanged event",e),this.threshold=e,this.updateColors()})),this.alphaListener=this.colorMap.on("alphaChanged",(e=>{de("ColorMappedNeuroSurface: Received alphaChanged event",e),this.config.alpha=e,this.updateColors()})),this.mesh&&this.updateColors()}createMesh(){const e=new r.BufferGeometry;e.setAttribute("position",new r.Float32BufferAttribute(this.geometry.vertices,3));const t=this.geometry.faces&&this.geometry.faces.length>0?this.geometry.faces:new Uint32Array(Array.from({length:this.geometry.vertices.length/3},((e,t)=>t)));let i;return e.setIndex(new r.Uint32BufferAttribute(t,1)),i="standard"===this.config.materialType?new r.MeshStandardMaterial({vertexColors:!0,transparent:this.config.alpha<1,opacity:this.config.alpha,metalness:this.config.metalness??0,roughness:this.config.roughness??.5,emissive:new r.Color(this.config.emissive||0),emissiveIntensity:this.config.emissiveIntensity||0,flatShading:this.config.flatShading||!1,side:r.DoubleSide,depthWrite:this.config.alpha>=1}):"physical"===this.config.materialType?new r.MeshPhysicalMaterial({vertexColors:!0,transparent:this.config.alpha<1,opacity:this.config.alpha,metalness:this.config.metalness??0,roughness:this.config.roughness??.5,emissive:new r.Color(this.config.emissive||0),emissiveIntensity:this.config.emissiveIntensity||0,flatShading:this.config.flatShading||!1,side:r.DoubleSide,depthWrite:this.config.alpha>=1,clearcoat:0,clearcoatRoughness:0}):new r.MeshPhongMaterial({vertexColors:!0,transparent:this.config.alpha<1,opacity:this.config.alpha,shininess:this.config.shininess||30,specular:new r.Color(this.config.specularColor||1118481),emissive:new r.Color(this.config.emissive||0),emissiveIntensity:this.config.emissiveIntensity||0,flatShading:this.config.flatShading||!1,side:r.DoubleSide,depthWrite:this.config.alpha>=1}),this.mesh=new r.Mesh(e,i),this.computeNormals(e),this.mesh}updateColors(){if(de("Updating colors. Mesh:",!!this.mesh,"ColorMap:",!!this.colorMap),!this.mesh||!this.colorMap)return console.warn("Mesh or ColorMap not initialized in updateColors"),de("Mesh:",this.mesh),void de("ColorMap:",this.colorMap);if(!this.mesh.geometry)return void console.warn("Mesh geometry not initialized");const e=this.geometry.vertices.length/3;let t,i=this.mesh.geometry.getAttribute("color");i&&i.array.length===4*e?t=i.array:(t=new Float32Array(4*e),i=new r.BufferAttribute(t,4),this.mesh.geometry.setAttribute("color",i)),de("threshold",this.threshold),de("irange",this.irange),de("alpha",this.config.alpha),de("data",this.data);const s=new r.Color(this.config.color);if(this.data)for(let r=0;r<this.indices.length;r++){const e=this.indices[r],i=this.data[r],n=this.colorMap.getColor(i),a=4*e;this.threshold[0]!==this.threshold[1]&&i>=this.threshold[0]&&i<=this.threshold[1]?(t[a]=s.r,t[a+1]=s.g,t[a+2]=s.b,t[a+3]=0):(t[a]=n[0],t[a+1]=n[1],t[a+2]=n[2],t[a+3]=1)}else for(let r=0;r<t.length;r+=4)t[r]=s.r,t[r+1]=s.g,t[r+2]=s.b,t[r+3]=1;i.needsUpdate=!0;const n=this.mesh.material;n.vertexColors=!0,n.needsUpdate=!0,n.transparent=!0,n.opacity=1,this.viewer&&this.viewer.requestRender&&this.viewer.requestRender()}updateConfig(e){super.updateConfig(e),this.colorMap&&this.colorMap.setAlpha(this.config.alpha),this.updateColors()}setData(e){const t=new Float32Array(e);t.length===this.data.length?(this.data=t,this.updateColors()):console.error("New data length does not match the current data length")}removeColorMapListeners(){this.rangeListener&&(this.rangeListener(),this.rangeListener=null),this.thresholdListener&&(this.thresholdListener(),this.thresholdListener=null),this.alphaListener&&(this.alphaListener(),this.alphaListener=null)}dispose(){this.removeColorMapListeners(),super.dispose(),this.colorMap=null}}class we extends ye{constructor(e,t,i,r={}){const s=e.vertices.length/3;super(e,t,new Float32Array(s),r),this.colors=new Float32Array(0),this.createMesh(),this.setColors(i)}setColors(e){this.colors=new Float32Array(3*e.length);for(let t=0;t<e.length;t++){const i=new r.Color(e[t]);this.colors[3*t]=i.r,this.colors[3*t+1]=i.g,this.colors[3*t+2]=i.b}this.updateColors()}updateColors(){if(!this.mesh)return;const e=this.geometry.vertices.length/3;let t,i=this.mesh.geometry.getAttribute("color");i&&i.array.length===3*e?t=i.array:(t=new Float32Array(3*e),i=new r.BufferAttribute(t,3),this.mesh.geometry.setAttribute("color",i));for(let r=0;r<this.indices.length;r++){const e=this.indices[r];t[3*e]=this.colors[3*r],t[3*e+1]=this.colors[3*r+1],t[3*e+2]=this.colors[3*r+2]}i.needsUpdate=!0;const s=this.mesh.material;s.vertexColors=!0,s.needsUpdate=!0}createMesh(){const e=new r.BufferGeometry;e.setAttribute("position",new r.Float32BufferAttribute(this.geometry.vertices,3)),e.setIndex(new r.Uint32BufferAttribute(this.geometry.faces,1)),this.vertexCurv&&e.setAttribute("curv",new r.Float32BufferAttribute(this.vertexCurv,1));const t=new r.MeshPhongMaterial({vertexColors:!0,transparent:this.config.alpha<1,opacity:this.config.alpha,shininess:this.config.shininess||30,specular:new r.Color(this.config.specularColor||1118481),emissive:new r.Color(this.config.emissive||0),emissiveIntensity:this.config.emissiveIntensity||0,flatShading:this.config.flatShading||!1,side:r.DoubleSide,depthWrite:this.config.alpha>=1});return this.mesh=new r.Mesh(e,t),this.computeNormals(e),this.updateColors(),this.mesh}dispose(){this.colors=null,super.dispose()}}class xe{constructor(e,t,i={}){this.texture=null,this.textureData=e,this.textureSize=t,this.rangeX=i.rangeX||[0,1],this.rangeY=i.rangeY||[0,1],this.thresholdX=i.thresholdX||[0,0],this.thresholdY=i.thresholdY||[0,0],this.alpha=i.alpha??1}getColor(e,t){const i=this.thresholdX[0]!==this.thresholdX[1],r=this.thresholdY[0]!==this.thresholdY[1];if(i&&e>=this.thresholdX[0]&&e<=this.thresholdX[1])return[0,0,0,0];if(r&&t>=this.thresholdY[0]&&t<=this.thresholdY[1])return[0,0,0,0];const s=this.normalizeValue(e,this.rangeX),n=this.normalizeValue(t,this.rangeY),a=Math.floor(s*(this.textureSize-1)),o=4*(Math.floor(n*(this.textureSize-1))*this.textureSize+a);return[this.textureData[o],this.textureData[o+1],this.textureData[o+2],this.textureData[o+3]*this.alpha]}normalizeValue(e,t){const[i,r]=t;return r===i?0:Math.max(0,Math.min(1,(e-i)/(r-i)))}getTexture(){return this.texture||(this.texture=new r.DataTexture(this.textureData,this.textureSize,this.textureSize,r.RGBAFormat,r.FloatType),this.texture.needsUpdate=!0,this.texture.minFilter=r.LinearFilter,this.texture.magFilter=r.LinearFilter,this.texture.wrapS=r.ClampToEdgeWrapping,this.texture.wrapT=r.ClampToEdgeWrapping),this.texture}getTextureData(){return this.textureData}getTextureSize(){return this.textureSize}setRangeX(e){this.rangeX=e}setRangeY(e){this.rangeY=e}setThresholdX(e){this.thresholdX=e}setThresholdY(e){this.thresholdY=e}setAlpha(e){this.alpha=Math.max(0,Math.min(1,e))}getRangeX(){return[...this.rangeX]}getRangeY(){return[...this.rangeY]}getThresholdX(){return[...this.thresholdX]}getThresholdY(){return[...this.thresholdY]}getAlpha(){return this.alpha}dispose(){this.texture&&(this.texture.dispose(),this.texture=null)}static fromPreset(e,t=256,i={}){const r=xe.generatePresetTexture(e,t);return new xe(r,t,i)}static fromGenerator(e,t=256,i={}){const r=new Float32Array(t*t*4);for(let s=0;s<t;s++)for(let i=0;i<t;i++){const n=e(i/(t-1),s/(t-1)),a=4*(s*t+i);r[a]=n[0],r[a+1]=n[1],r[a+2]=n[2],r[a+3]=n[3]}return new xe(r,t,i)}static generatePresetTexture(e,t){const i=new Float32Array(t*t*4);for(let r=0;r<t;r++)for(let s=0;s<t;s++){const n=s/(t-1),a=r/(t-1),o=4*(r*t+s);let l,h,c,d;switch(e){case"hot_cold":[l,h,c,d]=xe.hotColdColor(n,a);break;case"rgba_wheel":[l,h,c,d]=xe.rgbaWheelColor(n,a);break;case"confidence":[l,h,c,d]=xe.confidenceColor(n,a);break;case"diverging":[l,h,c,d]=xe.divergingColor(n,a);break;case"magnitude_phase":[l,h,c,d]=xe.magnitudePhaseColor(n,a);break;default:l=n,h=a,c=.5,d=1}i[o]=l,i[o+1]=h,i[o+2]=c,i[o+3]=d}return de(`ColorMap2D: Generated ${e} texture (${t}x${t})`),i}static hotColdColor(e,t){let i,r,s;if(e<.5){const t=2*e;i=t,r=t,s=1}else{const t=2*(e-.5);i=1,r=1-t,s=1-t}return i*=t,r*=t,s*=t,[i,r,s,1]}static rgbaWheelColor(e,t){const i=e-.5,r=t-.5,s=2*Math.sqrt(i*i+r*r),n=(Math.atan2(r,i)+Math.PI)/(2*Math.PI),a=Math.min(1,s),[o,l,h]=xe.hsvToRgb(n,a,1);return[o,l,h,s<=1?1:0]}static confidenceColor(e,t){const i=.8*e,[r,s,n]=xe.hsvToRgb(i,t,1);return[r,s,n,1]}static divergingColor(e,t){let i,r,s;if(e<.5){const t=2*e;i=t,r=t,s=1}else{const t=2*(e-.5);i=1,r=1-t,s=1-t}return i=1-(1-i)*t,r=1-(1-r)*t,s=1-(1-s)*t,[i,r,s,1]}static magnitudePhaseColor(e,t){const[i,r,s]=xe.hsvToRgb(t,1,e);return[i,r,s,1]}static hsvToRgb(e,t,i){let r,s,n;const a=Math.floor(6*e),o=6*e-a,l=i*(1-t),h=i*(1-o*t),c=i*(1-(1-o)*t);switch(a%6){case 0:r=i,s=c,n=l;break;case 1:r=h,s=i,n=l;break;case 2:r=l,s=i,n=c;break;case 3:r=l,s=h,n=i;break;case 4:r=c,s=l,n=i;break;case 5:r=i,s=l,n=h;break;default:r=0,s=0,n=0}return[r,s,n]}static getPresetNames(){return["hot_cold","rgba_wheel","confidence","diverging","magnitude_phase"]}}class Me{constructor(e,t,i,s,n={}){if(t<=0||i<=0||s<=0)throw new Error(`VolumeTexture3D: invalid dims (${t}, ${i}, ${s})`);const a=t*i*s;if(e.length!==a)throw new Error(`VolumeTexture3D: data length ${e.length} does not match dims product ${a}`);this.dims=new r.Vector3(t,i,s),this.useHalfFloat=n.useHalfFloat??!1;const{gpuData:o,gpuType:l}=this.prepareData(e);this.texture=new r.Data3DTexture(o,t,i,s),this.texture.format=r.RedFormat,this.texture.type=l,this.texture.minFilter=n.minFilter??r.LinearFilter,this.texture.magFilter=n.magFilter??r.LinearFilter,this.texture.wrapS=n.wrapS??r.ClampToEdgeWrapping,this.texture.wrapT=n.wrapT??r.ClampToEdgeWrapping,this.texture.wrapR=n.wrapR??r.ClampToEdgeWrapping,this.texture.unpackAlignment=1,this.texture.generateMipmaps=!1,this.texture.needsUpdate=!0}updateData(e){const t=this.dims.x*this.dims.y*this.dims.z;if(e.length!==t)throw new Error(`VolumeTexture3D.updateData: data length ${e.length} does not match dims product ${t}`);const{gpuData:i}=this.prepareData(e),r=this.texture.image;(null==r?void 0:r.data)&&r.data.length===i.length&&r.data.constructor===i.constructor?r.data.set(i):r.data=i,this.texture.needsUpdate=!0}static isSupported(e,t={}){const i=t.requireLinearFiltering??!0,r=t.useHalfFloat??!1;if(!e.capabilities.isWebGL2)return!1;if((e.capabilities.maxVertexTextures??0)<=0)return!1;if(!i)return!0;const s=r?"OES_texture_half_float_linear":"OES_texture_float_linear";return null!==e.getContext().getExtension(s)}dispose(){this.texture.dispose()}prepareData(e){const t=e instanceof Float32Array?e:(()=>{const t=new Float32Array(e.length);for(let i=0;i<e.length;i++)t[i]=e[i];return t})();if(!this.useHalfFloat)return{gpuData:t,gpuType:r.FloatType};const i=new Uint16Array(t.length);for(let s=0;s<t.length;s++)i[s]=r.DataUtils.toHalfFloat(t[s]);return{gpuData:i,gpuType:r.HalfFloatType}}}function Ce(e,t=256){let i;try{i=me.generatePreset(e,t)}catch(a){const r=me.getAvailableMaps(),s=r.includes("jet")?"jet":r[0]||"jet";console.warn(`createColormapTexture: preset "${e}" unavailable, falling back to "${s}"`,a),i=me.generatePreset(s,t)}const s=new Uint8Array(4*t);for(let r=0;r<t;r++){const e=i[r]??[0,0,0,1],t=Math.max(0,Math.min(1,e[0]??0)),n=Math.max(0,Math.min(1,e[1]??0)),a=Math.max(0,Math.min(1,e[2]??0)),o=Math.max(0,Math.min(1,e[3]??1)),l=4*r;s[l]=Math.round(255*t),s[l+1]=Math.round(255*n),s[l+2]=Math.round(255*a),s[l+3]=Math.round(255*o)}const n=new r.DataTexture(s,t,1,r.RGBAFormat,r.UnsignedByteType);return n.needsUpdate=!0,n.minFilter=r.LinearFilter,n.magFilter=r.LinearFilter,n.wrapS=r.ClampToEdgeWrapping,n.wrapT=r.ClampToEdgeWrapping,n.generateMipmaps=!1,n.flipY=!1,n}class Se{constructor(e,t={}){this.id=e,this.visible=void 0===t.visible||t.visible,this.opacity=void 0!==t.opacity?t.opacity:1,this.blendMode=t.blendMode||"normal",this.order=t.order||0,this.needsUpdate=!0,this._onChangeCallback=null}_notifyChange(){this.needsUpdate=!0,this._onChangeCallback&&this._onChangeCallback()}setVisible(e){this.visible!==e&&(this.visible=e,this._notifyChange())}setOpacity(e){e=Math.max(0,Math.min(1,e)),this.opacity!==e&&(this.opacity=e,this._notifyChange())}setBlendMode(e){["normal","additive","multiply"].includes(e)&&this.blendMode!==e&&(this.blendMode=e,this._notifyChange())}dispose(){}toStateJSON(){return{id:this.id,type:this.constructor.name,visible:this.visible,opacity:this.opacity,blendMode:this.blendMode,order:this.order}}static registerOutlineLayer(e){Se._outlineCtor=e}static registerTemporalLayer(e){Se._temporalCtor=e}static get outlineCtor(){return Se._outlineCtor}static fromConfig(e){const{type:t,id:i}=e;if(!t||!i)throw new Error("Layer.fromConfig requires type and id");const r={visible:e.visible,opacity:e.opacity??(void 0!==e.alpha?e.alpha:void 0),blendMode:e.blendMode,order:e.order};switch(t){case"base":return new Ee(e.color??13421772,r);case"rgba":if(!e.data)throw new Error("RGBALayer requires data");return new _e(i,e.data,r);case"data":if(!e.data)throw new Error("DataLayer requires data");return new Te(i,e.data,e.indices??null,e.cmap??e.colorMap??"jet",{...r,range:e.range,threshold:e.threshold});case"outline":if(!e.roiLabels)throw new Error("OutlineLayer requires roiLabels");if(!Se.outlineCtor)throw new Error("OutlineLayer constructor not registered");return new Se.outlineCtor(i,{roiLabels:e.roiLabels,color:e.color,opacity:r.opacity,width:e.width,halo:e.halo,haloColor:e.haloColor,haloWidth:e.haloWidth,offset:e.offset,roiSubset:e.roiSubset,visible:r.visible,blendMode:r.blendMode,order:r.order});case"label":if(!e.labels||!e.labelDefs)throw new Error("LabelLayer requires labels and labelDefs");return new Le(i,{labels:e.labels,labelDefs:e.labelDefs,defaultColor:e.defaultColor,visible:r.visible,opacity:r.opacity,blendMode:r.blendMode,order:r.order});case"twodata":if(!e.dataX||!e.dataY)throw new Error("TwoDataLayer requires dataX and dataY");return new Pe(i,e.dataX,e.dataY,e.indices??null,e.cmap??e.colorMap??"confidence",{...r,rangeX:e.rangeX,rangeY:e.rangeY,thresholdX:e.thresholdX,thresholdY:e.thresholdY});case"temporal":if(!e.frames||!e.times)throw new Error("TemporalDataLayer requires frames and times");if(!Se._temporalCtor)throw new Error("TemporalDataLayer constructor not registered");return new Se._temporalCtor(i,e.frames,e.times,e.cmap??e.colorMap??"jet",{...r,range:e.range,threshold:e.threshold,factor:e.factor});case"volume":if(!e.volumeData||!e.dims)throw new Error("VolumeProjectionLayer requires volumeData and dims");return new Ae(i,e.volumeData,e.dims,{...r,colormap:e.colormap??e.cmap??"viridis",range:e.range,threshold:e.threshold,worldToIJK:e.worldToIJK,affineMatrix:e.affineMatrix??e.affine,voxelSize:e.voxelSize,volumeOrigin:e.volumeOrigin,useHalfFloat:e.useHalfFloat,fillValue:e.fillValue});default:throw new Error(`Unsupported layer type: ${t}`)}}}class _e extends Se{constructor(e,t,i={}){super(e,i),this.rgbaData=null,this.setRGBAData(t)}setRGBAData(e){if(!e)throw new Error("RGBA data is required");if(this.rgbaData=e instanceof Float32Array?e:new Float32Array(e),this.rgbaData.length%4!=0)throw new Error("RGBA data length must be divisible by 4");this._notifyChange(),de(`RGBALayer ${this.id}: Set RGBA data with ${this.rgbaData.length/4} vertices`)}getRGBAData(e){if(!this.rgbaData)throw new Error("No RGBA data set");const t=4*e;return this.rgbaData.length!==t&&console.warn(`RGBALayer ${this.id}: Data length mismatch. Expected ${t}, got ${this.rgbaData.length}`),this.rgbaData}update(e){e.rgbaData&&this.setRGBAData(e.rgbaData),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}toStateJSON(){return{...super.toStateJSON(),type:"rgba"}}}class Te extends Se{constructor(e,t,i,r,s={}){super(e,s),this.data=null,this.indices=null,this.colorMap=null,this.colorMapName=null,this._cachedRGBABuffer=null,this.range=s.range||[0,1],this.threshold=s.threshold||[0,0],this.setData(t,i),this.setColorMap(r),this.colorMap&&(this.colorMap.setRange(this.range),this.colorMap.setThreshold(this.threshold))}setData(e,t){if(!e)throw new Error("Data is required");if(this.data=e instanceof Float32Array?e:new Float32Array(e),t)this.indices=t instanceof Uint32Array?t:new Uint32Array(t);else{this.indices=new Uint32Array(this.data.length);for(let e=0;e<this.data.length;e++)this.indices[e]=e}this._notifyChange(),de(`DataLayer ${this.id}: Set data with ${this.data.length} values`)}getData(){return this.data}setColorMap(e){if(!e)throw new Error("ColorMap is required");if(de(`DataLayer ${this.id}: setColorMap called with`,e),e instanceof me)this.colorMap=e,this.colorMapName="custom",de(`DataLayer ${this.id}: Set ColorMap instance directly`);else if("string"==typeof e)try{this.colorMap=me.fromPreset(e),this.colorMapName=e,de(`DataLayer ${this.id}: Created ColorMap from preset: ${e}`)}catch(t){const i=me.getAvailableMaps(),r=i.includes("jet")?"jet":i[0]||"jet";console.warn(`DataLayer ${this.id}: preset "${e}" unavailable, falling back to "${r}"`,t),this.colorMap=me.fromPreset(r),this.colorMapName=r}else{if(!Array.isArray(e))throw new Error("Invalid colorMap type");this.colorMap=new me(e),this.colorMapName="custom",de(`DataLayer ${this.id}: Created ColorMap from color array`)}this.colorMap.setRange(this.range),this.colorMap.setThreshold(this.threshold),this._cachedRGBABuffer=null,this._notifyChange(),de(`DataLayer ${this.id}: ColorMap updated, needsUpdate = true`)}setRange(e){this.range=e,this.colorMap&&(this.colorMap.setRange(e),this._notifyChange())}setThreshold(e){this.threshold=e,this.colorMap&&(this.colorMap.setThreshold(e),this._notifyChange())}getRange(){return[...this.range]}getThreshold(){return[...this.threshold]}getColorMapName(){return this.colorMapName||"custom"}toStateJSON(){return{...super.toStateJSON(),type:"data",colorMapName:this.getColorMapName(),range:this.getRange(),threshold:this.getThreshold()}}getRGBAData(e){if(!this.data||!this.colorMap||!this.indices)throw new Error("Data, indices and colorMap must be set");de(`DataLayer ${this.id}: getRGBAData called for ${e} vertices`),de(`DataLayer ${this.id}: data.length=${this.data.length}, indices.length=${this.indices.length}`),de(`DataLayer ${this.id}: range=[${this.range[0].toFixed(4)}, ${this.range[1].toFixed(4)}]`),de(`DataLayer ${this.id}: threshold=[${this.threshold[0].toFixed(4)}, ${this.threshold[1].toFixed(4)}]`),de(`DataLayer ${this.id}: colormap=${this.colorMapName}, opacity=${this.opacity}`),this._cachedRGBABuffer&&this._cachedRGBABuffer.length===4*e||(this._cachedRGBABuffer=new Float32Array(4*e));const t=this._cachedRGBABuffer;t.fill(0);let i=0,r=0;for(let s=0;s<this.indices.length&&s<this.data.length;s++){const n=this.indices[s],a=this.data[s];if(n>=0&&n<e&&isFinite(a)){const e=this.colorMap.getColor(a),s=4*n;t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=(e[3]||1)*this.opacity,t[s+3]>0?i++:r++}}if(de(`DataLayer ${this.id}: Generated colors - ${i} visible, ${r} transparent`),this.data.length>0){const e=Math.floor(this.data.length/2),t=this.data[e],i=this.colorMap.getColor(t);de(`DataLayer ${this.id}: Sample value[${e}]=${t.toFixed(4)} -> RGBA=[${i.map((e=>e.toFixed(3))).join(", ")}]`)}return t}update(e){void 0!==e.data&&this.setData(e.data,e.indices),void 0!==e.colorMap&&this.setColorMap(e.colorMap),void 0!==e.range&&this.setRange(e.range),void 0!==e.threshold&&this.setThreshold(e.threshold),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}dispose(){this.data=null,this.indices=null,this.colorMap=null,this._cachedRGBABuffer=null}}class Ae extends Se{constructor(e,t,i,r={}){super(e,r),this.attachedSurface=null,this.rgbaBuffer=null,this.dims=i,this.range=r.range||[0,1],this.threshold=r.threshold||[0,0],this.fillValue=r.fillValue??0,this.volumeData=t instanceof Float32Array?t:new Float32Array(t),this.volumeTexture=new Me(this.volumeData,i[0],i[1],i[2],{useHalfFloat:r.useHalfFloat}),this.worldToIJK=this.computeWorldToIJK(r),this.colorMapName=r.colormap??"viridis";try{this.colorMap=me.fromPreset(this.colorMapName)}catch(s){const e=me.getAvailableMaps(),t=e.includes("jet")?"jet":e[0]||"jet";console.warn(`VolumeProjectionLayer ${this.id}: preset "${this.colorMapName}" unavailable, falling back to "${t}"`,s),this.colorMapName=t,this.colorMap=me.fromPreset(t)}this.colorMap.setRange(this.range),this.colorMap.setThreshold(this.threshold),this.colormapTexture=Ce(this.colorMapName)}attach(e){this.attachedSurface=e,this._notifyChange()}detach(){this.attachedSurface=null}getVolumeTexture(){return this.volumeTexture}getColormapTexture(){return this.colormapTexture}getWorldToIJK(){return this.worldToIJK}getVolumeDims(){return this.volumeTexture.dims}getRange(){return[...this.range]}getThreshold(){return[...this.threshold]}getFillValue(){return this.fillValue}setRange(e){this.range=e,this.colorMap.setRange(e),this._notifyChange()}setThreshold(e){this.threshold=e,this.colorMap.setThreshold(e),this._notifyChange()}setFillValue(e){this.fillValue=e,this._notifyChange()}setColormap(e){this.colorMapName=e;try{this.colorMap=me.fromPreset(e)}catch(t){const i=me.getAvailableMaps(),r=i.includes("jet")?"jet":i[0]||"jet";console.warn(`VolumeProjectionLayer ${this.id}: preset "${e}" unavailable, falling back to "${r}"`,t),this.colorMapName=r,this.colorMap=me.fromPreset(r)}this.colorMap.setRange(this.range),this.colorMap.setThreshold(this.threshold),this.colormapTexture&&this.colormapTexture.dispose(),this.colormapTexture=Ce(this.colorMapName),this._notifyChange()}setWorldToIJK(e){this.worldToIJK=e instanceof r.Matrix4?e.clone():(new r.Matrix4).fromArray(Array.from(e)),this._notifyChange()}updateVolumeData(e){this.volumeData=e instanceof Float32Array?e:new Float32Array(e),this.volumeTexture.updateData(this.volumeData),this._notifyChange()}getRGBAData(e){if(!this.attachedSurface)throw new Error("VolumeProjectionLayer.getRGBAData requires attachment to a surface");const t=this.attachedSurface.geometry.vertices;t.length/3!==e&&console.warn(`VolumeProjectionLayer ${this.id}: vertexCount mismatch; expected ${t.length/3}, got ${e}`),this.rgbaBuffer&&this.rgbaBuffer.length===4*e||(this.rgbaBuffer=new Float32Array(4*e));const i=this.rgbaBuffer;i.fill(0);const s=this.attachedSurface.mesh;s&&"function"==typeof s.updateMatrixWorld&&s.updateMatrixWorld(!0);const n=(s?s.matrixWorld:new r.Matrix4).elements,a=this.worldToIJK.elements,o=this.dims[0],l=this.dims[1],h=this.dims[2],c=this.volumeData;for(let r=0;r<e;r++){const e=3*r,s=t[e],d=t[e+1],u=t[e+2],p=n[0]*s+n[4]*d+n[8]*u+n[12],m=n[1]*s+n[5]*d+n[9]*u+n[13],f=n[2]*s+n[6]*d+n[10]*u+n[14],g=a[0]*p+a[4]*m+a[8]*f+a[12],v=a[1]*p+a[5]*m+a[9]*f+a[13],y=a[2]*p+a[6]*m+a[10]*f+a[14],b=(g+.5)/o,w=(v+.5)/l,x=(y+.5)/h;if(b<0||b>1||w<0||w>1||x<0||x>1)continue;const M=c[Math.min(o-1,Math.max(0,Math.floor(g+.5)))+o*Math.min(l-1,Math.max(0,Math.floor(v+.5)))+o*l*Math.min(h-1,Math.max(0,Math.floor(y+.5)))];if(!isFinite(M))continue;if(Math.abs(M-this.fillValue)<1e-6)continue;const C=this.colorMap.getColor(M),S=4*r;i[S]=C[0],i[S+1]=C[1],i[S+2]=C[2],i[S+3]=4===C.length?C[3]:1}return this.needsUpdate=!1,i}update(e){void 0!==e.volumeData&&this.updateVolumeData(e.volumeData),void 0!==e.colormap&&this.setColormap(e.colormap),void 0!==e.range&&this.setRange(e.range),void 0!==e.threshold&&this.setThreshold(e.threshold),void 0!==e.worldToIJK?this.setWorldToIJK(e.worldToIJK):void 0===e.affineMatrix&&void 0===e.voxelSize&&void 0===e.volumeOrigin||(this.worldToIJK=this.computeWorldToIJK({...e,range:this.range,threshold:this.threshold,colormap:this.colorMapName}),this._notifyChange()),void 0!==e.fillValue&&this.setFillValue(e.fillValue),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}toStateJSON(){return{...super.toStateJSON(),type:"volume",colorMapName:this.colorMapName,range:[...this.range],threshold:[...this.threshold],fillValue:this.fillValue}}dispose(){this.detach(),this.colormapTexture&&this.colormapTexture.dispose(),this.volumeTexture&&this.volumeTexture.dispose(),this.rgbaBuffer=null}computeWorldToIJK(e){if(e.worldToIJK)return e.worldToIJK instanceof r.Matrix4?e.worldToIJK.clone():(new r.Matrix4).fromArray(Array.from(e.worldToIJK));let t;if(e.affineMatrix)t=e.affineMatrix instanceof r.Matrix4?e.affineMatrix.clone():(new r.Matrix4).fromArray(Array.from(e.affineMatrix));else{const i=e.voxelSize??[1,1,1],s=e.volumeOrigin??[0,0,0];t=(new r.Matrix4).set(i[0],0,0,s[0],0,i[1],0,s[1],0,0,i[2],s[2],0,0,0,1)}const i=t.clone(),s=i.determinant();if(Math.abs(s)<1e-10)throw new Error("VolumeProjectionLayer: voxel-to-world matrix is singular (determinant  0). Check voxelSize and affineMatrix.");return i.invert()}}class Pe extends Se{constructor(e,t,i,r,s,n={}){super(e,n),this.dataX=null,this.dataY=null,this.indices=null,this.colorMap=null,this.colorMapName="confidence",this.is2DLayer=!0,this.rangeX=n.rangeX||[0,1],this.rangeY=n.rangeY||[0,1],this.thresholdX=n.thresholdX||[0,0],this.thresholdY=n.thresholdY||[0,0],this.setData(t,i,r),this.setColorMap(s)}setData(e,t,i){if(!e||!t)throw new Error("Both dataX and dataY are required");if(this.dataX=e instanceof Float32Array?e:new Float32Array(e),this.dataY=t instanceof Float32Array?t:new Float32Array(t),this.dataX.length!==this.dataY.length)throw new Error("dataX and dataY must have the same length");if(i)this.indices=i instanceof Uint32Array?i:new Uint32Array(i);else{this.indices=new Uint32Array(this.dataX.length);for(let e=0;e<this.dataX.length;e++)this.indices[e]=e}this._notifyChange(),de(`TwoDataLayer ${this.id}: Set data with ${this.dataX.length} values`)}getDataX(){return this.dataX}getDataY(){return this.dataY}setColorMap(e){if(!e)throw new Error("ColorMap is required");e instanceof xe?(this.colorMap=e,this.colorMapName="custom"):(this.colorMap=xe.fromPreset(e,256,{rangeX:this.rangeX,rangeY:this.rangeY,thresholdX:this.thresholdX,thresholdY:this.thresholdY}),this.colorMapName=e),this.colorMap.setRangeX(this.rangeX),this.colorMap.setRangeY(this.rangeY),this.colorMap.setThresholdX(this.thresholdX),this.colorMap.setThresholdY(this.thresholdY),this._notifyChange(),de(`TwoDataLayer ${this.id}: ColorMap set to ${this.colorMapName}`)}getColorMap(){return this.colorMap}setRangeX(e){this.rangeX=e,this.colorMap&&(this.colorMap.setRangeX(e),this._notifyChange())}setRangeY(e){this.rangeY=e,this.colorMap&&(this.colorMap.setRangeY(e),this._notifyChange())}setThresholdX(e){this.thresholdX=e,this.colorMap&&(this.colorMap.setThresholdX(e),this._notifyChange())}setThresholdY(e){this.thresholdY=e,this.colorMap&&(this.colorMap.setThresholdY(e),this._notifyChange())}getRangeX(){return[...this.rangeX]}getRangeY(){return[...this.rangeY]}getThresholdX(){return[...this.thresholdX]}getThresholdY(){return[...this.thresholdY]}getColorMapName(){return this.colorMapName}getRGBAData(e){if(!(this.dataX&&this.dataY&&this.colorMap&&this.indices))throw new Error("Data, indices and colorMap must be set");de(`TwoDataLayer ${this.id}: getRGBAData called for ${e} vertices`);const t=new Float32Array(4*e);t.fill(0);let i=0;const r=this.indices,s=this.dataX,n=this.dataY,a=this.colorMap;for(let o=0;o<r.length&&o<s.length;o++){const l=r[o],h=s[o],c=n[o];if(l>=0&&l<e){const e=a.getColor(h,c),r=4*l;t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2],t[r+3]=e[3]*this.opacity,t[r+3]>0&&i++}}return de(`TwoDataLayer ${this.id}: Generated colors - ${i} visible`),t}update(e){if(void 0!==e.dataX||void 0!==e.dataY){const t=void 0!==e.dataX?e.dataX instanceof Float32Array?e.dataX:new Float32Array(e.dataX):this.dataX,i=void 0!==e.dataY?e.dataY instanceof Float32Array?e.dataY:new Float32Array(e.dataY):this.dataY;t&&i&&this.setData(t,i,e.indices)}void 0!==e.colorMap&&this.setColorMap(e.colorMap),void 0!==e.rangeX&&this.setRangeX(e.rangeX),void 0!==e.rangeY&&this.setRangeY(e.rangeY),void 0!==e.thresholdX&&this.setThresholdX(e.thresholdX),void 0!==e.thresholdY&&this.setThresholdY(e.thresholdY),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}toStateJSON(){return{...super.toStateJSON(),type:"twodata",colorMapName:this.getColorMapName(),rangeX:this.getRangeX(),rangeY:this.getRangeY(),thresholdX:this.getThresholdX(),thresholdY:this.getThresholdY()}}dispose(){this.dataX=null,this.dataY=null,this.indices=null,this.colorMap&&(this.colorMap.dispose(),this.colorMap=null)}}class Ee extends Se{constructor(e=13421772,t={}){super("base",{...t,order:-1}),this.color=e}setColor(e){this.color=e,this._notifyChange()}getRGBAData(e){const t=new Float32Array(4*e),i=(this.color>>16&255)/255,r=(this.color>>8&255)/255,s=(255&this.color)/255;for(let n=0;n<t.length;n+=4)t[n]=i,t[n+1]=r,t[n+2]=s,t[n+3]=this.opacity;return t}update(e){void 0!==e.color&&this.setColor(e.color),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible)}toStateJSON(){return{...super.toStateJSON(),type:"base",color:this.color}}}class Le extends Se{constructor(e,t){if(super(e,t),this.rgbaBuffer=null,!t.labels||!t.labelDefs)throw new Error("LabelLayer requires labels and labelDefs");this.labels=t.labels instanceof Uint32Array?t.labels:(t.labels,Int32Array,new Uint32Array(t.labels)),this.labelMap=new Map,t.labelDefs.forEach((e=>{this.labelMap.set(e.id,new r.Color(e.color))})),this.defaultColor=new r.Color(t.defaultColor??10066329),this.needsUpdate=!0}setLabels(e){this.labels=e instanceof Uint32Array?e:(Int32Array,new Uint32Array(e)),this._notifyChange()}setLabelDefs(e){this.labelMap.clear(),e.forEach((e=>{this.labelMap.set(e.id,new r.Color(e.color))})),this._notifyChange()}update(e){void 0!==e.labels&&this.setLabels(e.labels),void 0!==e.labelDefs&&this.setLabelDefs(e.labelDefs),void 0!==e.defaultColor&&(this.defaultColor=new r.Color(e.defaultColor),this._notifyChange()),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}getRGBAData(e){this.rgbaBuffer&&this.rgbaBuffer.length===4*e||(this.rgbaBuffer=new Float32Array(4*e));const t=this.rgbaBuffer,i=this.labels,r=this.labelMap,s=this.defaultColor;for(let n=0;n<e;n++){const e=i[n]??-1,a=r.get(e)||s,o=4*n;t[o]=a.r,t[o+1]=a.g,t[o+2]=a.b,t[o+3]=1}return this.needsUpdate=!1,t}toStateJSON(){return{...super.toStateJSON(),type:"label"}}}class Ie{constructor(){this.layers=new Map,this.layerOrder=[],this.needsComposite=!0}addLayer(e){this.layers.set(e.id,e),this.updateLayerOrder(),this.needsComposite=!0,de(`Added layer ${e.id} to stack`)}removeLayer(e){const t=this.layers.get(e);return!!t&&(t.dispose&&t.dispose(),this.layers.delete(e),this.updateLayerOrder(),this.needsComposite=!0,de(`Removed layer ${e} from stack`),!0)}getLayer(e){return this.layers.get(e)}updateLayer(e,t){const i=this.layers.get(e);i&&(i.update(t),i.needsUpdate&&(this.needsComposite=!0))}getAllLayers(){return Array.from(this.layers.values())}setLayerOrder(e){const t=e.filter((e=>this.layers.has(e)));this.layers.forEach(((e,i)=>{t.includes(i)||t.push(i)})),this.layerOrder=t,this.needsComposite=!0}updateLayerOrder(){this.layerOrder=Array.from(this.layers.keys()).sort(((e,t)=>{const i=this.layers.get(e),r=this.layers.get(t);return i.order-r.order}))}getVisibleLayers(){return this.layerOrder.map((e=>this.layers.get(e))).filter((e=>e&&e.visible))}clear(){this.layers.forEach((e=>{e.dispose&&e.dispose()})),this.layers.clear(),this.layerOrder=[],this.needsComposite=!0}dispose(){this.clear()}}class Re extends Se{constructor(e,t,i={}){super(e,{...i,order:i.order??-2}),this.rgbaBuffer=null,this.curvature=t instanceof Float32Array?t:new Float32Array(t),this.brightness=i.brightness??.5,this.contrast=i.contrast??.5,this.smoothness=i.smoothness??1,de(`CurvatureLayer ${e}: Created with ${this.curvature.length} vertices`)}setCurvature(e){this.curvature=e instanceof Float32Array?e:new Float32Array(e),this.rgbaBuffer=null,this._notifyChange()}getCurvature(){return this.curvature}setBrightness(e){this.brightness=Math.max(0,Math.min(1,e)),this.rgbaBuffer=null,this._notifyChange()}setContrast(e){this.contrast=Math.max(0,Math.min(1,e)),this.rgbaBuffer=null,this._notifyChange()}setSmoothness(e){this.smoothness=Math.max(.01,e),this.rgbaBuffer=null,this._notifyChange()}getDisplayParams(){return{brightness:this.brightness,contrast:this.contrast,smoothness:this.smoothness}}getRGBAData(e){this.rgbaBuffer&&this.rgbaBuffer.length===4*e||(this.rgbaBuffer=new Float32Array(4*e));const t=this.rgbaBuffer,i=this.curvature,r=this.brightness,s=this.contrast,n=this.smoothness,a=this.opacity;for(let o=0;o<e;o++){const e=o<i.length?i[o]:0,l=Math.max(-.5,Math.min(.5,e/n)),h=Math.max(0,Math.min(1,l*s+r)),c=4*o;t[c]=h,t[c+1]=h,t[c+2]=h,t[c+3]=a}return this.needsUpdate=!1,t}update(e){void 0!==e.curvature&&this.setCurvature(e.curvature),void 0!==e.brightness&&this.setBrightness(e.brightness),void 0!==e.contrast&&this.setContrast(e.contrast),void 0!==e.smoothness&&this.setSmoothness(e.smoothness),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode)}toStateJSON(){return{...super.toStateJSON(),type:"curvature",brightness:this.brightness,contrast:this.contrast,smoothness:this.smoothness}}dispose(){this.rgbaBuffer=null}}const De=Se.fromConfig.bind(Se);Se.fromConfig=function(e){if("curvature"===e.type){if(!e.curvature)throw new Error("CurvatureLayer requires curvature data");return new Re(e.id,e.curvature,{visible:e.visible,opacity:e.opacity,brightness:e.brightness,contrast:e.contrast,smoothness:e.smoothness,order:e.order})}return De(e)};class ke{constructor(e={}){var t,i;this.normal=(null==(t=e.normal)?void 0:t.clone())??new r.Vector3(1,0,0),this.point=(null==(i=e.point)?void 0:i.clone())??new r.Vector3(0,0,0),this.enabled=e.enabled??!1,this._flip=e.flip??!1,this._plane=new r.Plane,this._updatePlane()}setFromAxisDistance(e,t,i=!1){switch(this._flip=i,e){case"x":this.normal.set(1,0,0),this.point.set(t,0,0);break;case"y":this.normal.set(0,1,0),this.point.set(0,t,0);break;case"z":this.normal.set(0,0,1),this.point.set(0,0,t)}return i&&this.normal.negate(),this._updatePlane(),this}setFromPoints(e,t,i){const s=(new r.Vector3).subVectors(t,e),n=(new r.Vector3).subVectors(i,e);return this.normal.crossVectors(s,n).normalize(),this.point.copy(e),this._flip&&this.normal.negate(),this._updatePlane(),this}setFromNormalAndPoint(e,t){return this.normal.copy(e).normalize(),this.point.copy(t),this._flip&&this.normal.negate(),this._updatePlane(),this}setDistance(e){return this.point.copy(this.normal).multiplyScalar(e),this._updatePlane(),this}getDistance(){return this.point.dot(this.normal)}setEnabled(e){return this.enabled=e,this}toggle(){return this.enabled=!this.enabled,this}flip(){return this._flip=!this._flip,this.normal.negate(),this._updatePlane(),this}getThreePlane(){return this._plane}getShaderUniforms(){return{normal:this.normal.clone(),point:this.point.clone(),enabled:this.enabled}}toStateJSON(){const e=this.normal;let t="custom";return Math.abs(Math.abs(e.x)-1)<.001&&Math.abs(e.y)<.001&&Math.abs(e.z)<.001?t="x":Math.abs(e.x)<.001&&Math.abs(Math.abs(e.y)-1)<.001&&Math.abs(e.z)<.001?t="y":Math.abs(e.x)<.001&&Math.abs(e.y)<.001&&Math.abs(Math.abs(e.z)-1)<.001&&(t="z"),{axis:t,normal:[e.x,e.y,e.z],distance:this.getDistance(),enabled:this.enabled,flip:this._flip}}clone(){return new ke({normal:this.normal.clone(),point:this.point.clone(),enabled:this.enabled,flip:this._flip})}_updatePlane(){this._plane.setFromNormalAndCoplanarPoint(this.normal,this.point)}}class Fe{constructor(){this.x=(new ke).setFromAxisDistance("x",0),this.y=(new ke).setFromAxisDistance("y",0),this.z=(new ke).setFromAxisDistance("z",0),this._planes=[this.x,this.y,this.z]}setClipPlane(e,t,i=!0,r=!1){const s=this[e];return s.setFromAxisDistance(e,t,r),s.setEnabled(i),this}getClipPlane(e){return this[e]}enableClipPlane(e){return this[e].setEnabled(!0),this}disableClipPlane(e){return this[e].setEnabled(!1),this}clearClipPlanes(){return this._planes.forEach((e=>e.setEnabled(!1))),this}getThreePlanes(){return this._planes.filter((e=>e.enabled)).map((e=>e.getThreePlane()))}getAllPlanes(){return[...this._planes]}getEnabledPlanes(){return this._planes.filter((e=>e.enabled))}hasEnabledPlanes(){return this._planes.some((e=>e.enabled))}toStateJSON(){return this._planes.map((e=>e.toStateJSON()))}getShaderUniforms(){return{clipPlaneX:this.x.getShaderUniforms(),clipPlaneY:this.y.getShaderUniforms(),clipPlaneZ:this.z.getShaderUniforms()}}}class Ve{constructor(e,t=8){if(this.material=null,e<=0)throw new Error(`GPULayerCompositor: vertexCount must be positive, got ${e}`);this.vertexCount=e,this.maxLayers=t,this.initializeTextures(),this.createShaderMaterial()}initializeTextures(){this.layerTextureSize=Math.ceil(Math.sqrt(this.vertexCount));const e=this.layerTextureSize*this.layerTextureSize*4,t=new Float32Array(e*this.maxLayers);this.layerTexture=new r.DataArrayTexture(t,this.layerTextureSize,this.layerTextureSize,this.maxLayers),this.layerTexture.format=r.RGBAFormat,this.layerTexture.type=r.FloatType,this.layerTexture.minFilter=r.NearestFilter,this.layerTexture.magFilter=r.NearestFilter,this.layerTexture.wrapS=r.ClampToEdgeWrapping,this.layerTexture.wrapT=r.ClampToEdgeWrapping,this.layerTexture.generateMipmaps=!1,this.layerTexture.flipY=!1,this.layerTexture.needsUpdate=!0;const i=new Uint8Array(1024*this.maxLayers);this.volumeColormapsTexture=new r.DataArrayTexture(i,256,1,this.maxLayers),this.volumeColormapsTexture.format=r.RGBAFormat,this.volumeColormapsTexture.type=r.UnsignedByteType,this.volumeColormapsTexture.minFilter=r.LinearFilter,this.volumeColormapsTexture.magFilter=r.LinearFilter,this.volumeColormapsTexture.wrapS=r.ClampToEdgeWrapping,this.volumeColormapsTexture.wrapT=r.ClampToEdgeWrapping,this.volumeColormapsTexture.generateMipmaps=!1,this.volumeColormapsTexture.flipY=!1,this.volumeColormapsTexture.needsUpdate=!0}createShaderMaterial(){const e=this.layerTextureSize,t={baseColor:{value:new r.Color(13421772)},textureSize:{value:e},layerCount:{value:0},layerOpacity:{value:new Float32Array(8).fill(1)},layerBlendMode:{value:new Int32Array(8).fill(0)},layerKind:{value:new Int32Array(8).fill(0)},layerTextures:{value:this.layerTexture},volumeWorldToIJK:{value:Array.from({length:8},(()=>new r.Matrix4))},volumeDims:{value:Array.from({length:8},(()=>new r.Vector3(1,1,1)))},volumeIntensityRange:{value:Array.from({length:8},(()=>new r.Vector2(0,1)))},volumeThreshold:{value:Array.from({length:8},(()=>new r.Vector2(0,0)))},volumeFillValue:{value:new Float32Array(8).fill(0)},volumeColormaps:{value:this.volumeColormapsTexture},ambientLight:{value:new r.Color(4210752)},directionalLight:{value:new r.Color(16777215)},lightDirection:{value:new r.Vector3(.5,.5,1).normalize()},shininess:{value:30},clipPlaneNormalX:{value:new r.Vector3(1,0,0)},clipPlanePointX:{value:new r.Vector3(0,0,0)},clipPlaneEnabledX:{value:!1},clipPlaneNormalY:{value:new r.Vector3(0,1,0)},clipPlanePointY:{value:new r.Vector3(0,0,0)},clipPlaneEnabledY:{value:!1},clipPlaneNormalZ:{value:new r.Vector3(0,0,1)},clipPlanePointZ:{value:new r.Vector3(0,0,0)},clipPlaneEnabledZ:{value:!1}};for(let i=0;i<this.maxLayers;i++)t[`volume${i}`]={value:null};this.material=new r.ShaderMaterial({uniforms:t,vertexShader:"\n      precision highp float;\n      precision highp sampler3D;\n\n      in float vertexIndex;\n\n      out vec3 vNormal;\n      out vec3 vViewPosition;\n      out vec3 vWorldPosition;\n      out vec4 vLayerColor;\n\n      uniform sampler2DArray layerTextures;\n\n      // Layer kind per slot: 0 = precomputed RGBA texture, 1 = volume projection.\n      uniform int layerKind[8];\n\n      // Volume projection resources per slot (only used when layerKind[i] == 1).\n      uniform sampler3D volume0;\n      uniform sampler3D volume1;\n      uniform sampler3D volume2;\n      uniform sampler3D volume3;\n      uniform sampler3D volume4;\n      uniform sampler3D volume5;\n      uniform sampler3D volume6;\n      uniform sampler3D volume7;\n\n      uniform sampler2DArray volumeColormaps;\n\n      uniform mat4 volumeWorldToIJK[8];\n      uniform vec3 volumeDims[8];\n      uniform vec2 volumeIntensityRange[8];\n      uniform vec2 volumeThreshold[8];\n      uniform float volumeFillValue[8];\n\n      uniform float layerOpacity[8];\n      uniform int layerBlendMode[8];\n      uniform int layerCount;\n      uniform float textureSize;\n      uniform vec3 baseColor;\n\n      vec4 sampleLayerTexture(int layerIndex, vec2 texCoord) {\n        return texture(layerTextures, vec3(texCoord, float(layerIndex)));\n      }\n\n      float sampleVolumeValue(int layerIndex, vec3 uvw) {\n        if (layerIndex == 0) return texture(volume0, uvw).r;\n        if (layerIndex == 1) return texture(volume1, uvw).r;\n        if (layerIndex == 2) return texture(volume2, uvw).r;\n        if (layerIndex == 3) return texture(volume3, uvw).r;\n        if (layerIndex == 4) return texture(volume4, uvw).r;\n        if (layerIndex == 5) return texture(volume5, uvw).r;\n        if (layerIndex == 6) return texture(volume6, uvw).r;\n        if (layerIndex == 7) return texture(volume7, uvw).r;\n        return 0.0;\n      }\n\n      vec4 sampleVolumeColormap(int layerIndex, float t) {\n        return texture(volumeColormaps, vec3(t, 0.5, float(layerIndex)));\n      }\n\n      bool inBounds(vec3 uvw) {\n        return all(greaterThanEqual(uvw, vec3(0.0))) && all(lessThanEqual(uvw, vec3(1.0)));\n      }\n\n      vec4 sampleVolumeLayer(int layerIndex, vec3 worldPos) {\n        vec3 dims = volumeDims[layerIndex];\n        if (dims.x <= 0.0 || dims.y <= 0.0 || dims.z <= 0.0) return vec4(0.0);\n\n        vec3 ijk = (volumeWorldToIJK[layerIndex] * vec4(worldPos, 1.0)).xyz;\n        vec3 uvw = (ijk + vec3(0.5)) / dims;\n\n        if (!inBounds(uvw)) return vec4(0.0);\n\n        float v = sampleVolumeValue(layerIndex, uvw);\n\n        if (abs(v - volumeFillValue[layerIndex]) < 1e-6) return vec4(0.0);\n\n        vec2 thresh = volumeThreshold[layerIndex];\n        bool thresholdActive = abs(thresh.x - thresh.y) > 1e-10;\n        if (thresholdActive && v >= thresh.x && v <= thresh.y) return vec4(0.0);\n\n        vec2 ir = volumeIntensityRange[layerIndex];\n        float denom = max(ir.y - ir.x, 1e-10);\n        float t = clamp((v - ir.x) / denom, 0.0, 1.0);\n\n        return sampleVolumeColormap(layerIndex, t);\n      }\n\n      vec4 getLayerColor(int layerIndex, vec2 texCoord, vec3 worldPos) {\n        if (layerKind[layerIndex] == 1) {\n          return sampleVolumeLayer(layerIndex, worldPos);\n        }\n        return sampleLayerTexture(layerIndex, texCoord);\n      }\n\n      vec4 blendColors(vec4 base, vec4 overlay, int blendMode, float opacity) {\n        vec4 result = base;\n        if (blendMode == 0) { // Normal\n          result = mix(base, overlay, overlay.a * opacity);\n        } else if (blendMode == 1) { // Additive\n          result = base + overlay * opacity;\n          result = clamp(result, 0.0, 1.0);\n        } else if (blendMode == 2) { // Multiply\n          result = mix(base, base * overlay, overlay.a * opacity);\n        } else if (blendMode == 3) { // Screen\n          vec4 screen = vec4(1.0) - (vec4(1.0) - base) * (vec4(1.0) - overlay);\n          result = mix(base, screen, overlay.a * opacity);\n        }\n        return result;\n      }\n\n      void main() {\n        vNormal = normalize(normalMatrix * normal);\n        vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n        vWorldPosition = worldPosition.xyz;\n\n        // Calculate texture coordinates from vertex index in vertex shader\n        // This ensures we get the exact vertex color, not interpolated\n        float x = mod(vertexIndex, textureSize);\n        float y = floor(vertexIndex / textureSize);\n        vec2 texCoord = vec2(x + 0.5, y + 0.5) / textureSize;\n\n        // Composite layers in vertex shader to avoid interpolation issues\n        vec4 finalColor = vec4(baseColor, 1.0);\n        for (int i = 0; i < 8; i++) {\n          if (i >= layerCount) break;\n          vec4 layerColor = getLayerColor(i, texCoord, vWorldPosition);\n          if (layerColor.a > 0.0) {\n            finalColor = blendColors(finalColor, layerColor, layerBlendMode[i], layerOpacity[i]);\n          }\n        }\n        vLayerColor = finalColor;\n\n        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n        vViewPosition = -mvPosition.xyz;\n        gl_Position = projectionMatrix * mvPosition;\n        gl_PointSize = 1.0;\n      }\n    ",fragmentShader:"\n      precision highp float;\n\n      uniform vec3 ambientLight;\n      uniform vec3 directionalLight;\n      uniform vec3 lightDirection;\n      uniform float shininess;\n\n      // Clip plane uniforms (up to 3 planes: X, Y, Z)\n      uniform vec3 clipPlaneNormalX;\n      uniform vec3 clipPlanePointX;\n      uniform bool clipPlaneEnabledX;\n      uniform vec3 clipPlaneNormalY;\n      uniform vec3 clipPlanePointY;\n      uniform bool clipPlaneEnabledY;\n      uniform vec3 clipPlaneNormalZ;\n      uniform vec3 clipPlanePointZ;\n      uniform bool clipPlaneEnabledZ;\n\n      in vec3 vNormal;\n      in vec3 vViewPosition;\n      in vec3 vWorldPosition;\n      in vec4 vLayerColor;\n\n      out vec4 outColor;\n\n      void main() {\n        // Apply clip planes - discard fragments on the clipped side\n        if (clipPlaneEnabledX && dot(vWorldPosition - clipPlanePointX, clipPlaneNormalX) > 0.0) {\n          discard;\n        }\n        if (clipPlaneEnabledY && dot(vWorldPosition - clipPlanePointY, clipPlaneNormalY) > 0.0) {\n          discard;\n        }\n        if (clipPlaneEnabledZ && dot(vWorldPosition - clipPlanePointZ, clipPlaneNormalZ) > 0.0) {\n          discard;\n        }\n\n        // Use pre-computed color from vertex shader (avoids interpolation issues)\n        vec4 finalColor = vLayerColor;\n\n        // Apply lighting\n        vec3 normal = normalize(vNormal);\n        vec3 viewDir = normalize(vViewPosition);\n\n        // Ambient\n        vec3 ambient = ambientLight * finalColor.rgb;\n\n        // Diffuse (Lambertian)\n        float diff = max(dot(normal, lightDirection), 0.0);\n        vec3 diffuse = directionalLight * diff * finalColor.rgb;\n\n        // Specular (Blinn-Phong)\n        vec3 halfDir = normalize(lightDirection + viewDir);\n        float spec = pow(max(dot(normal, halfDir), 0.0), shininess);\n        vec3 specular = directionalLight * spec * 0.3;\n\n        vec3 litColor = ambient + diffuse + specular;\n        outColor = vec4(litColor, finalColor.a);\n      }\n    ",glslVersion:r.GLSL3,vertexColors:!0,transparent:!0,side:r.DoubleSide})}updateLayers(e){if(!this.material)return;const t=e.filter((e=>e.visible)),i=Math.min(t.length,this.maxLayers);de(`GPULayerCompositor: Updating ${i} layers`),this.material.uniforms.layerCount.value=i;for(let r=0;r<i;r++){const e=t[r];this.material.uniforms.layerOpacity.value[r]=e.opacity,this.material.uniforms.layerBlendMode.value[r]=this.getBlendModeIndex(e.blendMode),e instanceof Ae?(this.material.uniforms.layerKind.value[r]=1,this.updateVolumeLayerUniforms(r,e)):(this.material.uniforms.layerKind.value[r]=0,this.updateLayerTexture(r,e))}for(let r=i;r<this.maxLayers;r++)this.material.uniforms.layerKind.value[r]=0,this.clearLayerTexture(r),this.material.uniforms[`volume${r}`].value=null}updateLayerTexture(e,t){const i=t.getRGBAData(this.vertexCount),r=this.layerTextureSize,s=this.layerTexture.image.data,n=r*r*4,a=e*n;s.set(i.subarray(0,4*this.vertexCount),a);for(let o=a+4*this.vertexCount;o<a+n;o++)s[o]=0;this.layerTexture.needsUpdate=!0}updateVolumeLayerUniforms(e,t){if(!this.material)return;const i=this.material.uniforms;i[`volume${e}`].value=t.getVolumeTexture().texture,this.updateVolumeColormapSlice(e,t.getColormapTexture()),i.volumeWorldToIJK.value[e].copy(t.getWorldToIJK()),i.volumeDims.value[e].copy(t.getVolumeDims());const r=t.getRange();i.volumeIntensityRange.value[e].set(r[0],r[1]);const s=t.getThreshold();i.volumeThreshold.value[e].set(s[0],s[1]),i.volumeFillValue.value[e]=t.getFillValue()}updateVolumeColormapSlice(e,t){const i=t.image,r=null==i?void 0:i.data;if(!r)return;const s=this.volumeColormapsTexture.image,n=s.data,a=s.width*s.height*4,o=e*a;if(r.length===a)n.set(r,o);else{const e=Math.min(r.length,a);for(let t=0;t<e;t++)n[o+t]=r[t];for(let t=e;t<a;t++)n[o+t]=0}this.volumeColormapsTexture.needsUpdate=!0}clearLayerTexture(e){const t=this.layerTextureSize,i=t*t*4,r=e*i;this.layerTexture.image.data.fill(0,r,r+i),this.layerTexture.needsUpdate=!0}getBlendModeIndex(e){switch(e){case"normal":default:return 0;case"additive":return 1;case"multiply":return 2;case"screen":return 3}}getMaterial(){return this.material}setBaseColor(e){this.material&&(this.material.uniforms.baseColor.value=new r.Color(e))}setClipPlanes(e){if(!this.material)return;const t=this.material.uniforms,i=e.x;t.clipPlaneNormalX.value.copy(i.normal),t.clipPlanePointX.value.copy(i.point),t.clipPlaneEnabledX.value=i.enabled;const r=e.y;t.clipPlaneNormalY.value.copy(r.normal),t.clipPlanePointY.value.copy(r.point),t.clipPlaneEnabledY.value=r.enabled;const s=e.z;t.clipPlaneNormalZ.value.copy(s.normal),t.clipPlanePointZ.value.copy(s.point),t.clipPlaneEnabledZ.value=s.enabled}setClipPlane(e,t){if(!this.material)return;const i=this.material.uniforms,r=e.toUpperCase();i[`clipPlaneNormal${r}`].value.copy(t.normal),i[`clipPlanePoint${r}`].value.copy(t.point),i[`clipPlaneEnabled${r}`].value=t.enabled}clearClipPlanes(){if(!this.material)return;const e=this.material.uniforms;e.clipPlaneEnabledX.value=!1,e.clipPlaneEnabledY.value=!1,e.clipPlaneEnabledZ.value=!1}dispose(){this.layerTexture&&this.layerTexture.dispose(),this.volumeColormapsTexture&&this.volumeColormapsTexture.dispose(),this.material&&(this.material.dispose(),this.material=null)}}class Be extends Se{constructor(e,t){if(super(e,{visible:t.visible,opacity:t.opacity??1,blendMode:t.blendMode,order:t.order}),this.lineObject=null,this.haloObject=null,!t.roiLabels)throw new Error("OutlineLayer requires roiLabels");this.roiLabels=t.roiLabels instanceof Uint32Array?t.roiLabels:(t.roiLabels,Int32Array,new Uint32Array(t.roiLabels)),this.order=void 0!==t.order?t.order:10,this.color=new r.Color(t.color??0).getHex(),this.width=t.width??1.5,this.halo=t.halo??!1,this.haloColor=new r.Color(t.haloColor??16777215).getHex(),this.haloWidth=t.haloWidth??1,this.offset=t.offset??0,this.roiSubset=t.roiSubset??null}getRGBAData(e){return new Float32Array(4*e)}update(e){e.roiLabels&&(this.roiLabels=e.roiLabels instanceof Uint32Array?e.roiLabels:(e.roiLabels,Int32Array,new Uint32Array(e.roiLabels))),void 0!==e.color&&(this.color=new r.Color(e.color).getHex()),void 0!==e.width&&(this.width=e.width),void 0!==e.halo&&(this.halo=e.halo),void 0!==e.haloColor&&(this.haloColor=new r.Color(e.haloColor).getHex()),void 0!==e.haloWidth&&(this.haloWidth=e.haloWidth),void 0!==e.offset&&(this.offset=e.offset),void 0!==e.roiSubset&&(this.roiSubset=e.roiSubset),void 0!==e.opacity&&this.setOpacity(e.opacity),void 0!==e.visible&&this.setVisible(e.visible),void 0!==e.blendMode&&this.setBlendMode(e.blendMode),void 0!==e.order&&(this.order=e.order),this._notifyChange()}toStateJSON(){return{...super.toStateJSON(),type:"outline",color:this.color,width:this.width,halo:this.halo,haloColor:this.haloColor,haloWidth:this.haloWidth,offset:this.offset}}dispose(){this.lineObject&&(this.lineObject.traverse((e=>{const t=e;t.geometry&&t.geometry.dispose(),t.material&&"function"==typeof t.material.dispose&&t.material.dispose()})),this.lineObject=null),this.haloObject&&(this.haloObject.traverse((e=>{const t=e;t.geometry&&t.geometry.dispose(),t.material&&"function"==typeof t.material.dispose&&t.material.dispose()})),this.haloObject=null)}}Se.registerOutlineLayer(Be);class Oe extends Se{constructor(e,t,i={}){if(super(e,{visible:i.visible,opacity:i.opacity??.85,blendMode:i.blendMode,order:i.order??15}),this._filteredEdges=[],this._edgeObject=null,this._nodeObject=null,this._tubeTemplate=null,this._sphereTemplate=null,this._surface=null,!t||0===t.length)throw new Error("ConnectivityLayer requires a non-empty edges array");for(const r of t)if(r.source<0||r.target<0)throw new Error(`ConnectivityLayer: negative vertex index (source=${r.source}, target=${r.target})`);this._edges=t,this._colorMapName=i.colorMap??"hot",this._colorMap=Oe._resolveColorMap(this._colorMapName),this._weightRange=i.weightRange??Oe._inferRange(t),this._colorMap.setRange(this._weightRange),this._threshold=i.threshold??0,this._renderMode=i.renderMode??"tube",this._tubeRadius=i.tubeRadius??.25,this._tubeRadiusScale=i.tubeRadiusScale??!0,this._showNodes=i.showNodes??!0,this._nodeRadius=i.nodeRadius??.8,this._nodeColor=new r.Color(i.nodeColor??2201331),this._topN=i.topN??0,this._regionFilter=i.regionFilter?new Set(i.regionFilter):null,this._group=new r.Group,this._group.name=`connectivity-${e}`,this._applyFilters()}static fromMatrix(e,t,i={}){const r=[],s=i.vertexIndices;if(Array.isArray(t)&&Array.isArray(t[0])){const e=t.length;for(let i=0;i<e;i++)for(let n=i+1;n<e;n++){const e=t[i][n];0!==e&&r.push({source:s?s[i]:i,target:s?s[n]:n,weight:e})}}else{const e=t,i=Math.round(Math.sqrt(e.length));if(i*i!==e.length)throw new Error("fromMatrix: flat array length must be a perfect square");for(let t=0;t<i;t++)for(let n=t+1;n<i;n++){const a=e[t*i+n];0!==a&&r.push({source:s?s[t]:t,target:s?s[n]:n,weight:a})}}if(0===r.length)throw new Error("fromMatrix: no non-zero edges in upper triangle");return new Oe(e,r,i)}static fromSparse(e,t,i={}){const r=[],s=i.vertexIndices,n=t.indptr.length-1;for(let a=0;a<n;a++){const e=t.indptr[a],i=t.indptr[a+1];for(let n=e;n<i;n++){const e=t.indices[n];e>a&&r.push({source:s?s[a]:a,target:s?s[e]:e,weight:t.data[n]})}}if(0===r.length)throw new Error("fromSparse: no edges found in upper triangle");return new Oe(e,r,i)}getRGBAData(e){return new Float32Array(4*e)}update(e){let t=!1;if(void 0!==e.edges){if(!e.edges||0===e.edges.length)throw new Error("ConnectivityLayer.update: edges must be non-empty");this._edges=e.edges,t=!0}void 0!==e.threshold&&(this._threshold=e.threshold,t=!0),void 0!==e.topN&&(this._topN=e.topN,t=!0),void 0!==e.regionFilter&&(this._regionFilter=e.regionFilter?new Set(e.regionFilter):null,t=!0),void 0!==e.weightRange&&(this._weightRange=e.weightRange,this._colorMap.setRange(this._weightRange),t=!0),void 0!==e.renderMode&&e.renderMode!==this._renderMode&&(this._renderMode=e.renderMode,t=!0),void 0!==e.colorMap&&e.colorMap!==this._colorMapName&&(this._colorMapName=e.colorMap,this._colorMap=Oe._resolveColorMap(e.colorMap),this._colorMap.setRange(this._weightRange),t=!0),void 0!==e.tubeRadius&&(this._tubeRadius=e.tubeRadius,t=!0),void 0!==e.tubeRadiusScale&&(this._tubeRadiusScale=e.tubeRadiusScale,t=!0),void 0!==e.showNodes&&(this._showNodes=e.showNodes,t=!0),void 0!==e.nodeRadius&&(this._nodeRadius=e.nodeRadius,t=!0),void 0!==e.nodeColor&&(this._nodeColor=new r.Color(e.nodeColor),t=!0),void 0!==e.opacity&&(this.setOpacity(e.opacity),t||this._syncOpacity()),void 0!==e.visible&&(this.setVisible(e.visible),this._group.visible=e.visible),t&&(this._applyFilters(),this._rebuild()),this._notifyChange()}attach(e){this._surface=e,e.mesh&&e.mesh.add(this._group),this._rebuild()}detach(){this._group.parent&&this._group.parent.remove(this._group),this._disposeObjects(),this._surface=null}getEdgeCount(){return this._filteredEdges.length}getFilteredEdges(){return[...this._filteredEdges]}getRenderMode(){return this._renderMode}getShowNodes(){return this._showNodes}getThreshold(){return this._threshold}getTopN(){return this._topN}getColorMapName(){return this._colorMapName}getWeightRange(){return[...this._weightRange]}getGroup(){return this._group}getEdgeColors(){const e=new Float32Array(4*this._filteredEdges.length);for(let t=0;t<this._filteredEdges.length;t++){const i=this._colorMap.getColor(Math.abs(this._filteredEdges[t].weight));e[4*t]=i[0],e[4*t+1]=i[1],e[4*t+2]=i[2],e[4*t+3]=i.length>3?i[3]:1}return e}toStateJSON(){return{...super.toStateJSON(),type:"connectivity",colorMapName:this._colorMapName,weightRange:[...this._weightRange],threshold:this._threshold,renderMode:this._renderMode,tubeRadius:this._tubeRadius,tubeRadiusScale:this._tubeRadiusScale,showNodes:this._showNodes,nodeRadius:this._nodeRadius,nodeColor:this._nodeColor.getHex(),topN:this._topN,regionFilter:this._regionFilter?Array.from(this._regionFilter):null}}setClipPlanes(e){this._group.traverse((t=>{const i=t.material;i&&"clippingPlanes"in i&&(i.clippingPlanes=e&&e.length>0?e:null,i.needsUpdate=!0)}))}_applyFilters(){let e=this._edges;if(this._threshold>0&&(e=e.filter((e=>Math.abs(e.weight)>=this._threshold))),this._regionFilter){const t=this._regionFilter;e=e.filter((e=>t.has(e.source)||t.has(e.target)))}this._topN>0&&e.length>this._topN&&(e=e.slice().sort(((e,t)=>Math.abs(t.weight)-Math.abs(e.weight))).slice(0,this._topN)),this._filteredEdges=e}_rebuild(){if(this._disposeObjects(),!this._surface||0===this._filteredEdges.length)return;const e=this._resolveVertices();e&&("line"===this._renderMode?this._buildLines(e):this._buildTubes(e),this._showNodes&&this._buildNodes(e),this._group.visible=this.visible,this._syncOpacity())}_resolveVertices(){if(!this._surface)return null;return(this._surface.geometry??this._surface).vertices??null}_buildLines(e){const t=this._filteredEdges,i=new Float32Array(6*t.length),s=new Float32Array(6*t.length);for(let r=0;r<t.length;r++){const{source:n,target:a,weight:o}=t[r],l=3*n,h=3*a,c=6*r;i[c]=e[l],i[c+1]=e[l+1],i[c+2]=e[l+2],i[c+3]=e[h],i[c+4]=e[h+1],i[c+5]=e[h+2];const[d,u,p]=this._colorMap.getColor(Math.abs(o));s[c]=d,s[c+1]=u,s[c+2]=p,s[c+3]=d,s[c+4]=u,s[c+5]=p}const n=new r.BufferGeometry;n.setAttribute("position",new r.BufferAttribute(i,3)),n.setAttribute("color",new r.BufferAttribute(s,3));const a=new r.LineBasicMaterial({vertexColors:!0,transparent:!0,opacity:this.opacity,depthWrite:!1,depthTest:!1});this._edgeObject=new r.LineSegments(n,a),this._edgeObject.name=`connectivity-lines-${this.id}`,this._edgeObject.renderOrder=1,this._edgeObject.frustumCulled=!1,this._group.add(this._edgeObject)}_buildTubes(e){const t=this._filteredEdges;this._tubeTemplate||(this._tubeTemplate=new r.CylinderGeometry(1,1,1,8,1));const i=new r.MeshPhongMaterial({transparent:!0,opacity:this.opacity,depthWrite:!1,depthTest:!1}),s=new r.InstancedMesh(this._tubeTemplate,i,t.length);s.name=`connectivity-tubes-${this.id}`,s.renderOrder=1,s.frustumCulled=!1;const n=new r.Object3D,a=new r.Vector3(0,1,0),o=new r.Vector3,l=new r.Vector3,h=new r.Vector3,c=new r.Vector3,d=new r.Color;let u=0;for(let r=0;r<t.length;r++){const{source:i,target:p,weight:m}=t[r],f=3*i,g=3*p;o.set(e[f],e[f+1],e[f+2]),l.set(e[g],e[g+1],e[g+2]),h.subVectors(l,o);const v=h.length();if(0===v)continue;h.normalize(),c.addVectors(o,l).multiplyScalar(.5);const y=this._normalizeWeight(m),b=this._tubeRadiusScale?this._tubeRadius*(.3+.7*y):this._tubeRadius;n.position.copy(c),n.quaternion.setFromUnitVectors(a,h),n.scale.set(b,v,b),n.updateMatrix(),s.setMatrixAt(u,n.matrix);const[w,x,M]=this._colorMap.getColor(Math.abs(m));d.setRGB(w,x,M),s.setColorAt(u,d),u++}s.count=u,s.instanceMatrix.needsUpdate=!0,s.instanceColor&&(s.instanceColor.needsUpdate=!0),this._edgeObject=s,this._group.add(s)}_buildNodes(e){const t=new Set;for(const r of this._filteredEdges)t.add(r.source),t.add(r.target);const i=Array.from(t);if(0===i.length)return;this._sphereTemplate||(this._sphereTemplate=new r.SphereGeometry(1,12,12));const s=new r.MeshPhongMaterial({color:this._nodeColor,transparent:!0,opacity:this.opacity,depthWrite:!1,depthTest:!1}),n=new r.InstancedMesh(this._sphereTemplate,s,i.length);n.name=`connectivity-nodes-${this.id}`,n.renderOrder=2,n.frustumCulled=!1;const a=new r.Object3D;for(let r=0;r<i.length;r++){const t=3*i[r];a.position.set(e[t],e[t+1],e[t+2]),a.scale.setScalar(this._nodeRadius),a.updateMatrix(),n.setMatrixAt(r,a.matrix)}n.instanceMatrix.needsUpdate=!0,this._nodeObject=n,this._group.add(n)}_normalizeWeight(e){const[t,i]=this._weightRange,r=i-t||1;return Math.max(0,Math.min(1,(Math.abs(e)-t)/r))}_syncOpacity(){this._group.traverse((e=>{const t=e.material;t&&"opacity"in t&&(t.opacity=this.opacity)}))}static _inferRange(e){let t=1/0,i=-1/0;for(const r of e){const e=Math.abs(r.weight);e<t&&(t=e),e>i&&(i=e)}return[t,i]}static _resolveColorMap(e){return e instanceof me?e:me.fromPreset(e)}_disposeObjects(){const e=e=>{e.traverse((e=>{var t;const i=e;i.geometry&&i.geometry.dispose(),(null==(t=i.material)?void 0:t.dispose)&&i.material.dispose()}))};this._edgeObject&&(e(this._edgeObject),this._group.remove(this._edgeObject),this._edgeObject=null),this._nodeObject&&(e(this._nodeObject),this._group.remove(this._nodeObject),this._nodeObject=null)}dispose(){this.detach(),this._tubeTemplate&&(this._tubeTemplate.dispose(),this._tubeTemplate=null),this._sphereTemplate&&(this._sphereTemplate.dispose(),this._sphereTemplate=null),this._edges=[],this._filteredEdges=[]}}const Ne=Se.fromConfig.bind(Se);Se.fromConfig=e=>{if("connectivity"===e.type){if(!e.edges)throw new Error("ConnectivityLayer requires edges");return new Oe(e.id,e.edges,{visible:e.visible,opacity:e.opacity,blendMode:e.blendMode,order:e.order,colorMap:e.cmap??e.colorMap??"hot",weightRange:e.weightRange,threshold:e.threshold,renderMode:e.renderMode,tubeRadius:e.tubeRadius,tubeRadiusScale:e.tubeRadiusScale,showNodes:e.showNodes,nodeRadius:e.nodeRadius,nodeColor:e.nodeColor,topN:e.topN,regionFilter:e.regionFilter})}return Ne(e)};class Ue extends Te{constructor(e,t,i,r,s){if(!t||0===t.length)throw new Error("TemporalDataLayer requires at least one frame");if(i.length!==t.length)throw new Error(`times.length (${i.length}) must equal frames.length (${t.length})`);const n=t[0].length;for(let a=1;a<t.length;a++)if(t[a].length!==n)throw new Error(`Frame ${a} has ${t[a].length} vertices, expected ${n}`);for(let a=1;a<i.length;a++)if(i[a]<i[a-1])throw new Error("times must be sorted in ascending order");if(s.factor&&s.factor.assignment.length!==t.length)throw new Error(`factor.assignment.length (${s.factor.assignment.length}) must equal frames.length (${t.length})`);super(e,new Float32Array(t[0]),null,r,{range:s.range,threshold:s.threshold,visible:s.visible,opacity:s.opacity,blendMode:s.blendMode,order:s.order}),this.frames=t,this.times=i.slice(),this.factor=s.factor??null,this.vertexCount=n}setTime(e,t,i){const r=this.frames[e],s=this.frames[t];if(!r||!s)return;const n=this.getData();if(!n)return;const a=1-i;for(let o=0;o<this.vertexCount;o++)n[o]=r[o]*a+s[o]*i;this.needsUpdate=!0}getTimeSeries(e){const t=this.frames.length,i=new Float32Array(t);for(let r=0;r<t;r++)i[r]=this.frames[r][e];return i}getTimes(){return this.times.slice()}getFactorDescriptor(){return this.factor}getFrameCount(){return this.frames.length}getVertexCount(){return this.vertexCount}dispose(){this.frames=[],super.dispose()}}const ze=new t.Box3,je=new t.Vector3;class $e extends t.InstancedBufferGeometry{constructor(){super(),this.isLineSegmentsGeometry=!0,this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this.setAttribute("position",new t.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this.setAttribute("uv",new t.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))}applyMatrix4(e){const t=this.attributes.instanceStart,i=this.attributes.instanceEnd;return void 0!==t&&(t.applyMatrix4(e),i.applyMatrix4(e),t.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}setPositions(e){let i;e instanceof Float32Array?i=e:Array.isArray(e)&&(i=new Float32Array(e));const r=new t.InstancedInterleavedBuffer(i,6,1);return this.setAttribute("instanceStart",new t.InterleavedBufferAttribute(r,3,0)),this.setAttribute("instanceEnd",new t.InterleavedBufferAttribute(r,3,3)),this.instanceCount=this.attributes.instanceStart.count,this.computeBoundingBox(),this.computeBoundingSphere(),this}setColors(e){let i;e instanceof Float32Array?i=e:Array.isArray(e)&&(i=new Float32Array(e));const r=new t.InstancedInterleavedBuffer(i,6,1);return this.setAttribute("instanceColorStart",new t.InterleavedBufferAttribute(r,3,0)),this.setAttribute("instanceColorEnd",new t.InterleavedBufferAttribute(r,3,3)),this}fromWireframeGeometry(e){return this.setPositions(e.attributes.position.array),this}fromEdgesGeometry(e){return this.setPositions(e.attributes.position.array),this}fromMesh(e){return this.fromWireframeGeometry(new t.WireframeGeometry(e.geometry)),this}fromLineSegments(e){const t=e.geometry;return this.setPositions(t.attributes.position.array),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new t.Box3);const e=this.attributes.instanceStart,i=this.attributes.instanceEnd;void 0!==e&&void 0!==i&&(this.boundingBox.setFromBufferAttribute(e),ze.setFromBufferAttribute(i),this.boundingBox.union(ze))}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new t.Sphere),null===this.boundingBox&&this.computeBoundingBox();const e=this.attributes.instanceStart,i=this.attributes.instanceEnd;if(void 0!==e&&void 0!==i){const t=this.boundingSphere.center;this.boundingBox.getCenter(t);let r=0;for(let s=0,n=e.count;s<n;s++)je.fromBufferAttribute(e,s),r=Math.max(r,t.distanceToSquared(je)),je.fromBufferAttribute(i,s),r=Math.max(r,t.distanceToSquared(je));this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}toJSON(){}}t.UniformsLib.line={worldUnits:{value:1},linewidth:{value:1},resolution:{value:new t.Vector2(1,1)},dashOffset:{value:0},dashScale:{value:1},dashSize:{value:1},gapSize:{value:1}},t.ShaderLib.line={uniforms:t.UniformsUtils.merge([t.UniformsLib.common,t.UniformsLib.fog,t.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tworldStart = start.xyz;\n\t\t\t\tworldEnd = end.xyz;\n\n\t\t\t#else\n\n\t\t\t\tvUv = uv;\n\n\t\t\t#endif\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\n\n\t\t\t\t// height offset\n\t\t\t\tfloat hw = linewidth * 0.5;\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\n\n\t\t\t\t// don't extend the line if we're rendering dashes because we\n\t\t\t\t// won't be rendering the endcaps\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t// cap extension\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\n\n\t\t\t\t\t// add width to the box\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\n\n\t\t\t\t\t// endcaps\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\n\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t\t// project the worldpos\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\n\n\t\t\t\t// shift the depth of the projected points so the line\n\t\t\t\t// segments overlap neatly\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\n\t\t\t\tclip.z = clipPose.z * clip.w;\n\n\t\t\t#else\n\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\t\t\t\t// undo aspect ratio adjustment\n\t\t\t\tdir.x /= aspect;\n\t\t\t\toffset.x /= aspect;\n\n\t\t\t\t// sign flip\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t\t// endcaps\n\t\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\t\toffset += - dir;\n\n\t\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\t\toffset += dir;\n\n\t\t\t\t}\n\n\t\t\t\t// adjust for linewidth\n\t\t\t\toffset *= linewidth;\n\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\t\toffset /= resolution.y;\n\n\t\t\t\t// select end\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t\t// back to clip space\n\t\t\t\toffset *= clip.w;\n\n\t\t\t\tclip.xy += offset;\n\n\t\t\t#endif\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform float linewidth;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#ifdef WORLD_UNITS\n\n\t\t\tvarying vec4 worldPos;\n\t\t\tvarying vec3 worldStart;\n\t\t\tvarying vec3 worldEnd;\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvarying vec2 vUv;\n\n\t\t\t#endif\n\n\t\t#else\n\n\t\t\tvarying vec2 vUv;\n\n\t\t#endif\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\n\n\t\t\tfloat mua;\n\t\t\tfloat mub;\n\n\t\t\tvec3 p13 = p1 - p3;\n\t\t\tvec3 p43 = p4 - p3;\n\n\t\t\tvec3 p21 = p2 - p1;\n\n\t\t\tfloat d1343 = dot( p13, p43 );\n\t\t\tfloat d4321 = dot( p43, p21 );\n\t\t\tfloat d1321 = dot( p13, p21 );\n\t\t\tfloat d4343 = dot( p43, p43 );\n\t\t\tfloat d2121 = dot( p21, p21 );\n\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\n\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\n\n\t\t\tmua = numer / denom;\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\n\n\t\t\treturn vec2( mua, mub );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tfloat alpha = opacity;\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\t#ifdef WORLD_UNITS\n\n\t\t\t\t// Find the closest points on the view ray and the line segment\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\n\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\n\t\t\t\tvec3 p2 = rayEnd * params.y;\n\t\t\t\tvec3 delta = p1 - p2;\n\t\t\t\tfloat len = length( delta );\n\t\t\t\tfloat norm = len / linewidth;\n\n\t\t\t\t#ifndef USE_DASH\n\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\n\n\t\t\t\t\t#else\n\n\t\t\t\t\t\tif ( norm > 0.5 ) {\n\n\t\t\t\t\t\t\tdiscard;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t#endif\n\n\t\t\t\t#endif\n\n\t\t\t#else\n\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\n\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\tfloat len2 = a * a + b * b;\n\t\t\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t\t\t}\n\n\t\t\t\t#else\n\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\t\t\tfloat a = vUv.x;\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t\t\t}\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};class Ge extends t.ShaderMaterial{constructor(e){super({type:"LineMaterial",uniforms:t.UniformsUtils.clone(t.ShaderLib.line.uniforms),vertexShader:t.ShaderLib.line.vertexShader,fragmentShader:t.ShaderLib.line.fragmentShader,clipping:!0}),this.isLineMaterial=!0,this.setValues(e)}get color(){return this.uniforms.diffuse.value}set color(e){this.uniforms.diffuse.value=e}get worldUnits(){return"WORLD_UNITS"in this.defines}set worldUnits(e){!0===e?this.defines.WORLD_UNITS="":delete this.defines.WORLD_UNITS}get linewidth(){return this.uniforms.linewidth.value}set linewidth(e){this.uniforms.linewidth&&(this.uniforms.linewidth.value=e)}get dashed(){return"USE_DASH"in this.defines}set dashed(e){!0===e!==this.dashed&&(this.needsUpdate=!0),!0===e?this.defines.USE_DASH="":delete this.defines.USE_DASH}get dashScale(){return this.uniforms.dashScale.value}set dashScale(e){this.uniforms.dashScale.value=e}get dashSize(){return this.uniforms.dashSize.value}set dashSize(e){this.uniforms.dashSize.value=e}get dashOffset(){return this.uniforms.dashOffset.value}set dashOffset(e){this.uniforms.dashOffset.value=e}get gapSize(){return this.uniforms.gapSize.value}set gapSize(e){this.uniforms.gapSize.value=e}get opacity(){return this.uniforms.opacity.value}set opacity(e){this.uniforms&&(this.uniforms.opacity.value=e)}get resolution(){return this.uniforms.resolution.value}set resolution(e){this.uniforms.resolution.value.copy(e)}get alphaToCoverage(){return"USE_ALPHA_TO_COVERAGE"in this.defines}set alphaToCoverage(e){this.defines&&(!0===e!==this.alphaToCoverage&&(this.needsUpdate=!0),!0===e?this.defines.USE_ALPHA_TO_COVERAGE="":delete this.defines.USE_ALPHA_TO_COVERAGE)}}const qe=new t.Vector4,Ye=new t.Vector3,We=new t.Vector3,Xe=new t.Vector4,He=new t.Vector4,Je=new t.Vector4,Ze=new t.Vector3,Ke=new t.Matrix4,Qe=new t.Line3,et=new t.Vector3,tt=new t.Box3,it=new t.Sphere,rt=new t.Vector4;let st,nt;function at(e,t,i){return rt.set(0,0,-t,1).applyMatrix4(e.projectionMatrix),rt.multiplyScalar(1/rt.w),rt.x=nt/i.width,rt.y=nt/i.height,rt.applyMatrix4(e.projectionMatrixInverse),rt.multiplyScalar(1/rt.w),Math.abs(Math.max(rt.x,rt.y))}class ot extends t.Mesh{constructor(e=new $e,t=new Ge({color:16777215*Math.random()})){super(e,t),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,i=e.attributes.instanceStart,r=e.attributes.instanceEnd,s=new Float32Array(2*i.count);for(let t=0,a=0,o=i.count;t<o;t++,a+=2)Ye.fromBufferAttribute(i,t),We.fromBufferAttribute(r,t),s[a]=0===a?0:s[a-1],s[a+1]=s[a]+Ye.distanceTo(We);const n=new t.InstancedInterleavedBuffer(s,2,1);return e.setAttribute("instanceDistanceStart",new t.InterleavedBufferAttribute(n,1,0)),e.setAttribute("instanceDistanceEnd",new t.InterleavedBufferAttribute(n,1,1)),this}raycast(e,i){const r=this.material.worldUnits,s=e.camera;null!==s||r||console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const n=void 0!==e.params.Line2&&e.params.Line2.threshold||0;st=e.ray;const a=this.matrixWorld,o=this.geometry,l=this.material;let h,c;if(nt=l.linewidth+n,null===o.boundingSphere&&o.computeBoundingSphere(),it.copy(o.boundingSphere).applyMatrix4(a),r)h=.5*nt;else{h=at(s,Math.max(s.near,it.distanceToPoint(st.origin)),l.resolution)}if(it.radius+=h,!1!==st.intersectsSphere(it)){if(null===o.boundingBox&&o.computeBoundingBox(),tt.copy(o.boundingBox).applyMatrix4(a),r)c=.5*nt;else{c=at(s,Math.max(s.near,tt.distanceToPoint(st.origin)),l.resolution)}tt.expandByScalar(c),!1!==st.intersectsBox(tt)&&(r?function(e,i){const r=e.matrixWorld,s=e.geometry,n=s.attributes.instanceStart,a=s.attributes.instanceEnd;for(let o=0,l=Math.min(s.instanceCount,n.count);o<l;o++){Qe.start.fromBufferAttribute(n,o),Qe.end.fromBufferAttribute(a,o),Qe.applyMatrix4(r);const s=new t.Vector3,l=new t.Vector3;st.distanceSqToSegment(Qe.start,Qe.end,l,s),l.distanceTo(s)<.5*nt&&i.push({point:l,pointOnLine:s,distance:st.origin.distanceTo(l),object:e,face:null,faceIndex:o,uv:null,uv1:null})}}(this,i):function(e,i,r){const s=i.projectionMatrix,n=e.material.resolution,a=e.matrixWorld,o=e.geometry,l=o.attributes.instanceStart,h=o.attributes.instanceEnd,c=Math.min(o.instanceCount,l.count),d=-i.near;st.at(1,Je),Je.w=1,Je.applyMatrix4(i.matrixWorldInverse),Je.applyMatrix4(s),Je.multiplyScalar(1/Je.w),Je.x*=n.x/2,Je.y*=n.y/2,Je.z=0,Ze.copy(Je),Ke.multiplyMatrices(i.matrixWorldInverse,a);for(let u=0,p=c;u<p;u++){if(Xe.fromBufferAttribute(l,u),He.fromBufferAttribute(h,u),Xe.w=1,He.w=1,Xe.applyMatrix4(Ke),He.applyMatrix4(Ke),Xe.z>d&&He.z>d)continue;if(Xe.z>d){const e=Xe.z-He.z,t=(Xe.z-d)/e;Xe.lerp(He,t)}else if(He.z>d){const e=He.z-Xe.z,t=(He.z-d)/e;He.lerp(Xe,t)}Xe.applyMatrix4(s),He.applyMatrix4(s),Xe.multiplyScalar(1/Xe.w),He.multiplyScalar(1/He.w),Xe.x*=n.x/2,Xe.y*=n.y/2,He.x*=n.x/2,He.y*=n.y/2,Qe.start.copy(Xe),Qe.start.z=0,Qe.end.copy(He),Qe.end.z=0;const i=Qe.closestPointToPointParameter(Ze,!0);Qe.at(i,et);const o=t.MathUtils.lerp(Xe.z,He.z,i),c=o>=-1&&o<=1,p=Ze.distanceTo(et)<.5*nt;if(c&&p){Qe.start.fromBufferAttribute(l,u),Qe.end.fromBufferAttribute(h,u),Qe.start.applyMatrix4(a),Qe.end.applyMatrix4(a);const i=new t.Vector3,s=new t.Vector3;st.distanceSqToSegment(Qe.start,Qe.end,s,i),r.push({point:s,pointOnLine:i,distance:st.origin.distanceTo(s),object:e,face:null,faceIndex:u,uv:null,uv1:null})}}}(this,s,i))}}onBeforeRender(e){const t=this.material.uniforms;t&&t.resolution&&(e.getViewport(qe),this.material.uniforms.resolution.value.set(qe.z,qe.w))}}class lt extends ye{constructor(e,t={}){const i=e.vertices.length/3,s=new Uint32Array(i);for(let r=0;r<i;r++)s[r]=r;if(super(e,s,new Float32Array(i),t),this.gpuCompositor=null,this.outlineResolution=null,this.layerStack=new Ie,this.compositeBuffer=new Float32Array(4*i),this.vertexCount=i,this._updatePending=!1,this.useGPUCompositing=t.useGPUCompositing??!1,this.useWideLines=t.useWideLines??!0,this.clipPlanes=new Fe,this.useGPUCompositing&&this.supportsWebGL2())try{this.gpuCompositor=new Ve(i),de("GPU compositing enabled for surface")}catch(l){console.warn("Failed to initialize GPU compositor, falling back to CPU:",l),this.useGPUCompositing=!1}else this.useGPUCompositing&&(console.warn("GPU compositing requested but WebGL2 not available; falling back to CPU"),this.useGPUCompositing=!1);if(t.curvature&&!1!==t.showCurvature){const e=t.curvatureOptions||{},i=new Re("curvature",t.curvature,{brightness:e.brightness,contrast:e.contrast,smoothness:e.smoothness,order:-2});this.layerStack.addLayer(i),de(`CurvatureLayer added with ${t.curvature.length} vertices`)}const n=t.curvature&&!1!==t.showCurvature,a=t.baseColor||13421772,o=new Ee("number"==typeof a?a:new r.Color(a).getHex(),{opacity:1,visible:!n});this.layerStack.addLayer(o),this.createMesh(),this.updateColors()}toggleWireframe(e){if(!this.mesh)return;const t=this.mesh.getObjectByName("__WIREFRAME__");if(e&&!t){const e=new r.EdgesGeometry(this.mesh.geometry,5),t=new r.LineSegments(e,new r.LineBasicMaterial({color:4473924,transparent:!0,opacity:.6}));t.name="__WIREFRAME__",this.mesh.add(t)}const i=this.mesh.getObjectByName("__WIREFRAME__");i&&(i.visible=e),this.mesh.material&&(this.mesh.material.visible=!e||this.mesh.material.visible),this.requestColorUpdate()}applyOutlineLayer(e){if(!this.mesh)return;this.detachOutlineLayer(e);const t=this.buildOutlineObjects(e);t?(t.halo&&(t.halo.renderOrder=(e.order||0)-.5,this.mesh.add(t.halo),e.haloObject=t.halo),t.line.renderOrder=e.order||0,this.mesh.add(t.line),e.lineObject=t.line,e.needsUpdate=!1,this.emit("layer:updated",{surface:this,layer:e}),this.requestColorUpdate()):de(`OutlineLayer ${e.id}: no boundary edges found`)}detachOutlineLayer(e){const t=this.mesh;if(!t)return;const i=e=>{e&&(e.parent===t&&t.remove(e),e.traverse((e=>{var t,i;const r=e;(null==(t=r.geometry)?void 0:t.dispose)&&r.geometry.dispose(),(null==(i=r.material)?void 0:i.dispose)&&r.material.dispose()})))};i(e.lineObject),i(e.haloObject),e.lineObject=null,e.haloObject=null}ensureOutlineResolution(){var e,t;this.outlineResolution||(this.outlineResolution=new r.Vector2),this.viewer&&this.viewer.renderer&&this.viewer.renderer.getSize?this.viewer.renderer.getSize(this.outlineResolution):this.outlineResolution.set((null==(e=this.viewer)?void 0:e.width)||1,(null==(t=this.viewer)?void 0:t.height)||1)}setMaterialResolution(e,t,i){e&&e.traverse((e=>{const r=e.material;r&&r.resolution&&"function"==typeof r.resolution.set&&r.resolution.set(t,i)}))}buildOutlineObjects(e){var t,i;if(!this.mesh)return null;e.roiLabels.length!==this.vertexCount&&console.warn(`OutlineLayer ${e.id}: roiLabels length ${e.roiLabels.length} does not match vertex count ${this.vertexCount}`);const s=this.mesh.geometry,n=s.getAttribute("position");let a=s.getAttribute("normal");if(a||(s.computeVertexNormals(),a=s.getAttribute("normal")),!n||!a)return null;const o=function(e,t,i){const r=[],s=new Set,n=i&&i.length?new Set(i):null,a=(e,i)=>{if(e===i)return;const a=t[e],o=t[i];if(a===o)return;if(n&&!n.has(a)&&!n.has(o))return;const l=e<i?`${e}-${i}`:`${i}-${e}`;s.has(l)||(s.add(l),r.push(e<i?[e,i]:[i,e]))};for(let o=0;o<e.length;o+=3){const t=e[o],i=e[o+1],r=e[o+2];a(t,i),a(i,r),a(r,t)}return r}(this.geometry.faces,e.roiLabels,e.roiSubset);if(!o.length)return null;const l=[],h=n.array,c=a.array,d=e.offset||0;for(const[r,b]of o){const e=h[3*r],t=h[3*r+1],i=h[3*r+2],s=h[3*b],n=h[3*b+1],a=h[3*b+2],o=c[3*r],u=c[3*r+1],p=c[3*r+2],m=c[3*b],f=c[3*b+1],g=c[3*b+2];l.push(e+o*d,t+u*d,i+p*d,s+m*d,n+f*d,a+g*d)}this.ensureOutlineResolution();const u=(null==(t=this.outlineResolution)?void 0:t.x)||1,p=(null==(i=this.outlineResolution)?void 0:i.y)||1,m=this.useWideLines?new $e:new r.BufferGeometry;m instanceof $e?m.setPositions(l):m.setAttribute("position",new r.Float32BufferAttribute(l,3));const f=(e,t,i)=>{if(this.useWideLines){const r=new Ge({color:e,linewidth:t,transparent:i<1,opacity:i,depthTest:!0,depthWrite:!1});return r.resolution.set(u,p),r}return new r.LineBasicMaterial({color:e,transparent:i<1,opacity:i})},g=f(e.color,e.width,e.opacity),v=this.useWideLines?new ot(m,g):new r.LineSegments(m,g);let y;if(v.visible=e.visible,e.halo){const t=f(e.haloColor,e.width+e.haloWidth,Math.min(1,.6*e.opacity)),i=(this.useWideLines,m.clone());y=this.useWideLines?new ot(i,t):new r.LineSegments(i,t),y.visible=e.visible}return{line:v,halo:y}}updateOutlineResolution(e,t,i=1){this.outlineResolution||(this.outlineResolution=new r.Vector2),this.outlineResolution.set(e*i,t*i),this.layerStack.getAllLayers().forEach((r=>{r instanceof Be&&(this.setMaterialResolution(r.lineObject,e*i,t*i),this.setMaterialResolution(r.haloObject,e*i,t*i))}))}requestColorUpdate(){this._updatePending||(this._updatePending=!0,requestAnimationFrame((()=>{this._updatePending=!1,this.updateColors(),this.emit("render:needed",{surface:this})})))}addLayer(e){this.layerStack.addLayer(e),this.emit("layer:added",{surface:this,layer:e}),e._onChangeCallback=()=>this.requestColorUpdate();const t=e.attach;if("function"==typeof t)try{t.call(e,this)}catch(i){console.warn(`MultiLayerNeuroSurface: failed to attach layer "${e.id}"`,i)}e instanceof Be?this.applyOutlineLayer(e):this.requestColorUpdate()}addTwoDataLayer(e,t,i,r="confidence",s={}){const n=new Pe(e,t,i,null,r,s);return this.addLayer(n),n}getTwoDataLayer(e){const t=this.layerStack.getLayer(e);return t instanceof Pe?t:void 0}removeLayer(e){const t=this.layerStack.getLayer(e);if(t instanceof Be&&this.detachOutlineLayer(t),t){t._onChangeCallback=null;const e=t.detach;if("function"==typeof e)try{e.call(t)}catch(i){console.warn(`MultiLayerNeuroSurface: failed to detach layer "${t.id}"`,i)}}return!!this.layerStack.removeLayer(e)&&(this.emit("layer:removed",{surface:this,layerId:e}),this.requestColorUpdate(),!0)}clearLayers(e={}){const t=e.includeBase??!1;this.layerStack.getAllLayers().forEach((e=>{const i=e instanceof Ee||e.id.startsWith("base");!t&&i||this.removeLayer(e.id)}))}updateLayer(e,t){this.layerStack.updateLayer(e,t);const i=this.layerStack.getLayer(e);i instanceof Be&&i.needsUpdate?(this.layerStack.needsComposite=!1,this.applyOutlineLayer(i)):this.layerStack.needsComposite&&this.requestColorUpdate()}updateLayerData(e,t,i){this.updateLayer(e,{data:t,indices:i})}updateLayerVisibility(e,t){this.updateLayer(e,{visible:t})}getLayer(e){return this.layerStack.getLayer(e)}setCurvature(e,t){const i=this.layerStack.getLayer("curvature");if(i&&i instanceof Re)i.setCurvature(e),void 0!==(null==t?void 0:t.brightness)&&i.setBrightness(t.brightness),void 0!==(null==t?void 0:t.contrast)&&i.setContrast(t.contrast),void 0!==(null==t?void 0:t.smoothness)&&i.setSmoothness(t.smoothness);else{const i=new Re("curvature",e,{brightness:null==t?void 0:t.brightness,contrast:null==t?void 0:t.contrast,smoothness:null==t?void 0:t.smoothness,order:-2});this.layerStack.addLayer(i)}this.requestColorUpdate()}getCurvatureLayer(){const e=this.layerStack.getLayer("curvature");return e instanceof Re?e:void 0}showCurvature(e){const t=this.getCurvatureLayer(),i=this.layerStack.getLayer("base");t&&t.setVisible(e),i&&i.setVisible(!e),this.requestColorUpdate()}setClipPlane(e,t,i=!0,r=!1){this.clipPlanes.setClipPlane(e,t,i,r),this._syncClipPlanes(),this.requestColorUpdate()}enableClipPlane(e){this.clipPlanes.enableClipPlane(e),this._syncClipPlanes(),this.requestColorUpdate()}disableClipPlane(e){this.clipPlanes.disableClipPlane(e),this._syncClipPlanes(),this.requestColorUpdate()}clearClipPlanes(){this.clipPlanes.clearClipPlanes(),this._syncClipPlanes(),this.requestColorUpdate()}getClipPlane(e){return this.clipPlanes.getClipPlane(e)}_syncClipPlanes(){var e;if(this.gpuCompositor&&this.gpuCompositor.setClipPlanes(this.clipPlanes),this.mesh&&this.mesh.material){const e=this.mesh.material;if("clippingPlanes"in e){const t=this.clipPlanes.getThreePlanes();e.clippingPlanes=t.length>0?t:null,e.needsUpdate=!0}}const t=this.clipPlanes.getThreePlanes();this.layerStack.getAllLayers().forEach((e=>{e instanceof Oe&&e.setClipPlanes(t.length>0?t:null)})),(null==(e=this.viewer)?void 0:e.renderer)&&(this.viewer.renderer.localClippingEnabled=this.clipPlanes.hasEnabledPlanes())}setLayerOrder(e){this.layerStack.setLayerOrder(e),this.requestColorUpdate()}updateLayers(e){let t=!1;e.forEach((e=>{const{id:i,type:s,...n}=e;if(s){let e=null;switch(s){case"base":const t=n.color||13421772;e=new Ee("number"==typeof t?t:new r.Color(t).getHex(),n);break;case"rgba":n.data&&(e=new _e(i,n.data,n));break;case"data":if(n.data&&n.indices){const t=n.colormap||n.colorMap;e=new Te(i,n.data,n.indices,t||"jet",n)}break;case"volume":if(n.volumeData&&n.dims){const t="string"==typeof n.colormap?n.colormap:n.cmap??"viridis";e=new Ae(i,n.volumeData,n.dims,{colormap:t,range:n.range,threshold:n.threshold,worldToIJK:n.worldToIJK,affineMatrix:n.affineMatrix??n.affine,voxelSize:n.voxelSize,volumeOrigin:n.volumeOrigin,useHalfFloat:n.useHalfFloat,fillValue:n.fillValue,visible:n.visible,opacity:n.opacity,blendMode:n.blendMode,order:n.order})}break;case"label":n.labels&&n.labelDefs&&(e=new Le(i,{labels:n.labels,labelDefs:n.labelDefs,defaultColor:n.defaultColor,visible:n.visible,opacity:n.opacity,blendMode:n.blendMode,order:n.order}));break;case"outline":n.roiLabels&&(e=new Be(i,{roiLabels:n.roiLabels,color:n.color,width:n.width,opacity:n.opacity,halo:n.halo,haloColor:n.haloColor,haloWidth:n.haloWidth,offset:n.offset,roiSubset:n.roiSubset,visible:n.visible,blendMode:n.blendMode,order:n.order}));break;case"temporal":if(n.frames&&n.times){const t=n.colormap||n.colorMap||n.cmap||"jet";e=new Ue(i,n.frames,n.times,t,{range:n.range,threshold:n.threshold,factor:n.factor,visible:n.visible,opacity:n.opacity,blendMode:n.blendMode,order:n.order})}break;case"curvature":n.curvature&&(e=new Re(i,n.curvature,{brightness:n.brightness,contrast:n.contrast,smoothness:n.smoothness,visible:n.visible,opacity:n.opacity,blendMode:n.blendMode,order:n.order??-2}));break;default:return void console.warn(`Unknown layer type: ${s}`)}if(e){this.layerStack.addLayer(e);const i=e.attach;if("function"==typeof i)try{i.call(e,this)}catch(a){console.warn(`MultiLayerNeuroSurface: failed to attach layer "${e.id}"`,a)}e instanceof Be&&this.applyOutlineLayer(e),t=!0}}else{if(this.layerStack.updateLayer(i,n),this.layerStack.getLayer(i)instanceof Be){const e=this.layerStack.getLayer(i);e.needsUpdate&&this.applyOutlineLayer(e)}t=t||this.layerStack.needsComposite}})),t&&(this.emit("layer:updated",{surface:this,layer:this.layerStack.getLayer(e[0].id)}),this.requestColorUpdate())}updateColors(){this.mesh?(de("MultiLayerNeuroSurface: Updating colors"),this.useGPUCompositing&&this.gpuCompositor?this.updateColorsGPU():this.updateColorsCPU()):de("MultiLayerNeuroSurface: No mesh to update")}updateColorsGPU(){if(!this.gpuCompositor)return;const e=this.layerStack.getVisibleLayers().filter((e=>!(e instanceof Be||e instanceof Oe)));this.gpuCompositor.updateLayers(e),e.forEach((e=>e.needsUpdate=!1)),this.layerStack.needsComposite=!1,this.viewer&&this.viewer.requestRender&&this.viewer.requestRender()}updateColorsCPU(){const e=this.config.baseColor||13421772,t="number"==typeof e?e:new r.Color(e).getHex(),i=(t>>16&255)/255,s=(t>>8&255)/255,n=(255&t)/255;for(let r=0;r<this.compositeBuffer.length;r+=4)this.compositeBuffer[r]=i,this.compositeBuffer[r+1]=s,this.compositeBuffer[r+2]=n,this.compositeBuffer[r+3]=1;de(`MultiLayerNeuroSurface: updateColorsCPU initialized with base color rgb(${i.toFixed(2)}, ${s.toFixed(2)}, ${n.toFixed(2)})`);const a=this.layerStack.getVisibleLayers().filter((e=>!(e instanceof Be||e instanceof Oe)));if(de(`MultiLayerNeuroSurface: updateColorsCPU found ${a.length} visible layers`),0===a.length)return de("No visible layers"),void this.applyCompositeToMesh();for(const r of a)try{de(`MultiLayerNeuroSurface: Processing layer ${r.id} (type: ${r.constructor.name})`);const e=r.getRGBAData(this.vertexCount);if(e.length>=8){const t=Array.from(e.slice(0,8)).map((e=>e.toFixed(3)));de(`MultiLayerNeuroSurface: Layer ${r.id} RGBA sample [0..7]: ${t.join(", ")}`)}let t=0;for(let i=3;i<e.length;i+=4)e[i]>0&&t++;de(`MultiLayerNeuroSurface: Layer ${r.id} has ${t}/${this.vertexCount} non-transparent vertices`),this.compositeLayer(e,r),r.needsUpdate=!1}catch(o){console.error(`Error processing layer ${r.id}:`,o)}this.applyCompositeToMesh(),this.layerStack.needsComposite=!1,this.viewer&&this.viewer.requestRender&&this.viewer.requestRender()}compositeLayer(e,t){const i=t.blendMode,r=t.opacity;for(let s=0;s<this.vertexCount;s++){const t=4*s,n=e[t],a=e[t+1],o=e[t+2],l=e[t+3]*r;if(0===l)continue;const h=this.compositeBuffer[t],c=this.compositeBuffer[t+1],d=this.compositeBuffer[t+2],u=this.compositeBuffer[t+3];switch(i){case"normal":const e=l+u*(1-l);e>0&&(this.compositeBuffer[t]=(n*l+h*u*(1-l))/e,this.compositeBuffer[t+1]=(a*l+c*u*(1-l))/e,this.compositeBuffer[t+2]=(o*l+d*u*(1-l))/e,this.compositeBuffer[t+3]=e);break;case"additive":this.compositeBuffer[t]=Math.min(1,h+n*l),this.compositeBuffer[t+1]=Math.min(1,c+a*l),this.compositeBuffer[t+2]=Math.min(1,d+o*l),this.compositeBuffer[t+3]=Math.min(1,u+l);break;case"multiply":const i=1-l;this.compositeBuffer[t]=h*(i+n*l),this.compositeBuffer[t+1]=c*(i+a*l),this.compositeBuffer[t+2]=d*(i+o*l),this.compositeBuffer[t+3]=u+l*(1-u)}}}hasValidColorData(){for(let e=3;e<this.compositeBuffer.length;e+=4)if(this.compositeBuffer[e]>0)return!0;return!1}applyCompositeToMesh(){var e,t,i;if(!this.mesh)return;const s=this.mesh.geometry,n=this.mesh.material,a=this.hasValidColorData();if(de(`MultiLayerNeuroSurface: applyCompositeToMesh hasValidColors=${a}`),!a)return n.vertexColors=!1,n.needsUpdate=!0,void de("MultiLayerNeuroSurface: No valid colors, using material base color");let o=s.getAttribute("color");if(!o){const e=new Float32Array(4*this.vertexCount);o=new r.BufferAttribute(e,4),s.setAttribute("color",o)}const l=o.array;l.length===this.compositeBuffer.length?(l.set(this.compositeBuffer),o.needsUpdate=!0,n.vertexColors=!0,n.transparent=!0,n.needsUpdate=!0,de("MultiLayerNeuroSurface: Applied vertex colors to mesh"),de("MultiLayerNeuroSurface: Mesh state:",{meshExists:!!this.mesh,geometryExists:!!s,positionCount:null==(e=s.getAttribute("position"))?void 0:e.count,colorCount:o.count,indexCount:null==(t=s.getIndex())?void 0:t.count,materialVertexColors:n.vertexColors,materialVisible:n.visible,meshVisible:null==(i=this.mesh)?void 0:i.visible}),s.boundingBox||s.computeBoundingBox(),s.boundingSphere||s.computeBoundingSphere()):console.error("Color attribute size mismatch")}createFallbackMaterial(){return new r.MeshPhongMaterial({vertexColors:!1,transparent:!0,opacity:1,shininess:this.config.shininess||30,specular:new r.Color(this.config.specularColor||1118481),flatShading:this.config.flatShading||!1,side:r.DoubleSide,color:new r.Color(this.config.baseColor||13421772)})}createMesh(){var e,t;const i=new r.BufferGeometry;i.setAttribute("position",new r.Float32BufferAttribute(this.geometry.vertices,3)),i.setIndex(new r.Uint32BufferAttribute(this.geometry.faces,1));const s=new Float32Array(this.vertexCount);for(let r=0;r<this.vertexCount;r++)s[r]=r;let n;return i.setAttribute("vertexIndex",new r.Float32BufferAttribute(s,1)),n=this.useGPUCompositing&&this.gpuCompositor&&this.gpuCompositor.getMaterial()||this.createFallbackMaterial(),this.mesh=new r.Mesh(i,n),i.computeVertexNormals(),i.computeBoundingBox(),i.computeBoundingSphere(),de("MultiLayerNeuroSurface: createMesh complete",{vertexCount:this.geometry.vertices.length/3,faceCount:this.geometry.faces.length/3,boundingSphereRadius:null==(e=i.boundingSphere)?void 0:e.radius,boundingSphereCenter:null==(t=i.boundingSphere)?void 0:t.center.toArray()}),this.updateColors(),this.mesh}setCompositingMode(e){if(e!==this.useGPUCompositing){if(this.useGPUCompositing=e,e){if(!this.supportsWebGL2())return console.warn("GPU compositing requires WebGL2; keeping CPU mode"),void(this.useGPUCompositing=!1);if(!this.gpuCompositor)try{this.gpuCompositor=new Ve(this.vertexCount),de("Switched to GPU compositing")}catch(t){return console.warn("Failed to initialize GPU compositor:",t),void(this.useGPUCompositing=!1)}if(this.mesh&&this.gpuCompositor){const e=this.mesh.material;this.mesh.material=this.gpuCompositor.getMaterial()||this.createFallbackMaterial(),e&&"dispose"in e&&e.dispose()}}else{if(this.mesh){const e=this.mesh.material;this.mesh.material=this.createFallbackMaterial(),e&&"dispose"in e&&e.dispose()}this.gpuCompositor&&(this.gpuCompositor.dispose(),this.gpuCompositor=null),de("Switched to CPU compositing")}this.updateColors()}}setWideLines(e){e!==this.useWideLines&&(this.useWideLines=e,this.layerStack.getAllLayers().forEach((e=>{e instanceof Be&&this.applyOutlineLayer(e)})),this.requestColorUpdate())}getCompositingMode(){return this.useGPUCompositing?"GPU":"CPU"}supportsWebGL2(){var e;const t=null==(e=this.viewer)?void 0:e.renderer;return!!(t&&t.capabilities&&t.capabilities.isWebGL2)}dispose(){this.layerStack.getAllLayers().forEach((e=>{e instanceof Be?this.detachOutlineLayer(e):e instanceof Oe&&e.detach()})),this.gpuCompositor&&(this.gpuCompositor.dispose(),this.gpuCompositor=null),this.layerStack&&(this.layerStack.dispose(),this.layerStack=null),this.compositeBuffer=null,super.dispose()}}class ht extends lt{constructor(e,t={}){const i=new Float32Array(e.getPositions(e.defaultVariant)),r=e.getCurv(e.defaultVariant)||null;super(new ve(i,e.faces,e.hemi,r),t),this.surfaceSet=e,this.currentVariantName=e.defaultVariant,this.variantAnimationId=null}currentVariant(){return this.currentVariantName}variantNames(){return this.surfaceSet.getVariantNames()}setVariant(e,t={}){var i,r,s;if(!this.surfaceSet.hasVariant(e))return void console.warn(`VariantSurface: variant "${e}" not found`);if(e===this.currentVariantName)return;const{animate:n=!0,duration:a=300,ease:o=e=>e}=t,l=this.surfaceSet.getPositions(e),h=null==(i=this.mesh)?void 0:i.geometry;if(!h)return;const c=h.getAttribute("position");if(!c)return;null!==this.variantAnimationId&&"undefined"!=typeof cancelAnimationFrame&&(cancelAnimationFrame(this.variantAnimationId),this.variantAnimationId=null);const d=new Float32Array(c.array);if(!(n&&a>0&&"undefined"!=typeof requestAnimationFrame))return c.array.set(l),c.needsUpdate=!0,h.computeVertexNormals(),this.geometry.vertices.set(l),null==(s=(r=this.geometry).invalidateBounds)||s.call(r),this.currentVariantName=e,this.emit("geometry:updated",{surface:this}),this.emit("variant:changed",{surface:this,variant:e}),void this.emit("render:needed",{surface:this});const u=performance.now(),p=t=>{var i,r;const s=Math.min(1,(t-u)/a),n=o?o(s):s,m=c.array;for(let e=0;e<m.length;e++)m[e]=d[e]+(l[e]-d[e])*n;c.needsUpdate=!0,this.emit("render:needed",{surface:this}),s<1?this.variantAnimationId=requestAnimationFrame(p):(h.computeVertexNormals(),this.geometry.vertices.set(l),null==(r=(i=this.geometry).invalidateBounds)||r.call(i),this.currentVariantName=e,this.variantAnimationId=null,this.emit("geometry:updated",{surface:this}),this.emit("variant:changed",{surface:this,variant:e}),this.emit("render:needed",{surface:this}))};this.variantAnimationId=requestAnimationFrame(p)}dispose(){null!==this.variantAnimationId&&"undefined"!=typeof cancelAnimationFrame&&(cancelAnimationFrame(this.variantAnimationId),this.variantAnimationId=null),super.dispose()}}class ct{static calculateBounds(e){let t=1/0,i=1/0,s=1/0,n=-1/0,a=-1/0,o=-1/0;for(let r=0;r<e.length;r+=3)t=Math.min(t,e[r]),n=Math.max(n,e[r]),i=Math.min(i,e[r+1]),a=Math.max(a,e[r+1]),s=Math.min(s,e[r+2]),o=Math.max(o,e[r+2]);const l=new r.Vector3(t,i,s),h=new r.Vector3(n,a,o),c=new r.Vector3((t+n)/2,(i+a)/2,(s+o)/2),d=new r.Vector3(n-t,a-i,o-s),u=d.length()/2;return{min:l,max:h,center:c,size:d,radius:u}}static calculateCameraDistance(e,t,i){const r=t*Math.PI/180,s=2*Math.atan(Math.tan(r/2)*i),n=Math.min(r,s);return 1.2*e/Math.sin(n/2)}static fitCameraToSurfaces(e,t,i){if(0===t.length)return;let s=1/0,n=1/0,a=1/0,o=-1/0,l=-1/0,h=-1/0;for(const r of t){const e=this.calculateBounds(r.vertices);s=Math.min(s,e.min.x),n=Math.min(n,e.min.y),a=Math.min(a,e.min.z),o=Math.max(o,e.max.x),l=Math.max(l,e.max.y),h=Math.max(h,e.max.z)}const c=new r.Vector3((s+o)/2,(n+l)/2,(a+h)/2),d=new r.Vector3(o-s,l-n,h-a).length()/2,u=this.calculateCameraDistance(d,e.fov,e.aspect),p=new r.Vector3(0,0,1);e.position.copy(c).add(p.multiplyScalar(u)),e.lookAt(c),i&&(i.target.copy(c),i.update()),e.near=u/1e3,e.far=10*u,e.updateProjectionMatrix()}static computeInitialZoom(e,t,i,r=1.2){const s=t*Math.PI/180,n=2*Math.atan(Math.tan(s/2)*i),a=Math.min(s,n);return e*r/Math.sin(a/2)}static fitCameraToGeometry(e,t={fov:60,aspect:1}){var i,s;const n=t.padding??1.2;let a=null;if((null==(s=null==(i=e.attributes)?void 0:i.position)?void 0:s.array)?a=e.attributes.position.array:e.vertices&&(a=e.vertices),!a)throw new Error("fitCameraToGeometry: geometry must provide position data");const o=a instanceof Float32Array?a:new Float32Array(a),l=this.calculateBounds(o),h=this.computeInitialZoom(l.radius,t.fov,t.aspect,n),c=new r.Vector3(l.center.x,l.center.y,l.center.z+h);return{center:l.center,distance:h,position:c}}}function dt(e){const t=e.capabilities;return{webgl2:!!t.isWebGL2,uint32Indices:!!t.isWebGL2||!(!e.getContext().getExtension||!e.getContext().getExtension("OES_element_index_uint")),floatTextures:!!t.isWebGL2||!(!e.getContext().getExtension||!e.getContext().getExtension("OES_texture_float")),maxVertexTextures:t.maxVertexTextures??0,workers:"undefined"!=typeof Worker,canvas:"undefined"!=typeof document&&!!document.createElement("canvas")}}class ut{constructor(e,t={}){this.annotations=new Map,this.counter=0,this.instancedThreshold=500,this.instancedMesh=null,this.instanceColors=null,this.viewer=e,this.defaultRadius=t.radius??.75,this.markerGeometry=new r.SphereGeometry(this.defaultRadius,12,12),this.defaultOnMaterial=new r.MeshBasicMaterial({color:t.colorOn??65280}),this.defaultOffMaterial=new r.MeshBasicMaterial({color:t.colorOff??16711680}),this.markerGroup=new r.Group,this.markerGroup.name="annotation-markers",this.viewer.scene.add(this.markerGroup)}add(e,t,i,s={}){const n=this.viewer.getSurface(e);if(!n||!n.mesh)return console.warn(`AnnotationManager: surface ${e} not found or missing mesh`),null;const a=n.mesh.geometry.getAttribute("position");if(!a)return console.warn("AnnotationManager: surface has no position attribute"),null;if(t<0||t>=a.count)return console.warn(`AnnotationManager: vertex index ${t} out of range`),null;const o="ann_"+ ++this.counter,l=s.radius??this.defaultRadius,h=new r.Vector3(a.getX(t),a.getY(t),a.getZ(t)),c=this.annotations.size+1>=this.instancedThreshold;let d;c?(this.ensureInstancedMesh(n.mesh,l),d=new r.Mesh):(d=new r.Mesh(l===this.defaultRadius?this.markerGeometry:new r.SphereGeometry(l,12,12),s.active?this.defaultOnMaterial.clone():this.defaultOffMaterial.clone()),d.position.copy(h),d.userData.annotationId=o,n.mesh.add(d));const u={id:o,surfaceId:e,vertexIndex:t,position:h.clone(),marker:d,data:i,active:!!s.active};return this.annotations.set(o,u),c?(this.writeInstance(u,!0===s.active),this.viewer.requestRender()):s.active?this.activate(o,{exclusive:!0}):this.viewer.requestRender(),this.viewer.emit("annotation:added",{annotation:u}),o}list(e){const t=Array.from(this.annotations.values());return e?t.filter((t=>t.surfaceId===e)):t}removeBySurface(e){this.annotations.forEach((t=>{t.surfaceId===e&&this.remove(t.id)}))}move(e,t){const i=this.annotations.get(e);if(!i)return!1;const s=this.viewer.getSurface(i.surfaceId);if(!s||!s.mesh)return!1;const n=s.mesh.geometry.getAttribute("position");if(!n||t<0||t>=n.count)return!1;const a=new r.Vector3(n.getX(t),n.getY(t),n.getZ(t));return i.vertexIndex=t,i.position.copy(a),this.instancedMesh&&this.instanceColors?this.writeInstance(i,i.active):i.marker&&i.marker.position.copy(a),this.viewer.emit("annotation:moved",{annotation:i}),this.viewer.requestRender(),!0}get(e){return this.annotations.get(e)}remove(e){const t=this.annotations.get(e);if(t){if(this.instancedMesh){const e=this.instanceIndex(t.id);e>=0&&this.instanceColors&&(this.instanceColors[3*e+0]=0,this.instanceColors[3*e+1]=0,this.instanceColors[3*e+2]=0,this.instancedMesh.instanceColor.needsUpdate=!0)}t.marker.parent&&t.marker.parent.remove(t.marker),this.disposeMarker(t.marker),this.annotations.delete(e),this.viewer.emit("annotation:removed",{annotation:t}),this.viewer.requestRender()}}reset(){this.annotations.forEach((e=>{e.marker.parent&&e.marker.parent.remove(e.marker),this.disposeMarker(e.marker)})),this.annotations.clear(),this.instancedMesh&&(this.viewer.scene.remove(this.instancedMesh),this.instancedMesh.geometry.dispose(),this.instancedMesh.material.dispose(),this.instancedMesh=null,this.instanceColors=null),this.viewer.emit("annotation:reset",{}),this.viewer.requestRender()}dispose(){this.reset(),this.markerGroup.parent&&this.markerGroup.parent.remove(this.markerGroup)}activate(e,t={}){const i=this.annotations.get(e);if(!i)return;const s=!1!==t.exclusive;this.annotations.forEach((t=>{const i=t.id===e;if(t.active=i||!s&&t.active,this.instancedMesh&&this.instanceColors){const e=this.instanceIndex(t.id);if(e>=0){const t=i?this.defaultOnMaterial.color.getHex():this.defaultOffMaterial.color.getHex(),s=new r.Color(t);this.instanceColors[3*e+0]=s.r,this.instanceColors[3*e+1]=s.g,this.instanceColors[3*e+2]=s.b}}else if(t.marker.material instanceof r.Material){t.marker.material.color.setHex(i?this.defaultOnMaterial.color.getHex():this.defaultOffMaterial.color.getHex())}})),this.instancedMesh&&this.instancedMesh.instanceColor&&(this.instancedMesh.instanceColor.needsUpdate=!0),this.viewer.emit("annotation:activated",{annotation:i}),this.viewer.requestRender()}forEach(e){this.annotations.forEach(e)}setDefaults(e){void 0!==e.radius&&(this.defaultRadius=e.radius,this.markerGeometry.dispose(),this.markerGeometry=new r.SphereGeometry(this.defaultRadius,12,12)),void 0!==e.colorOn&&this.defaultOnMaterial.color.setHex(e.colorOn),void 0!==e.colorOff&&this.defaultOffMaterial.color.setHex(e.colorOff)}disposeMarker(e){e.geometry&&e.geometry.dispose(),e.material&&(Array.isArray(e.material)?e.material.forEach((e=>e.dispose())):e.material.dispose())}ensureInstancedMesh(e,t){if(this.instancedMesh)return;const i=new r.SphereGeometry(t||this.defaultRadius,10,10),s=new r.MeshBasicMaterial({vertexColors:!0,depthWrite:!0}),n=Math.max(2*this.instancedThreshold,this.annotations.size+1);this.instancedMesh=new r.InstancedMesh(i,s,n),this.instancedMesh.name="annotation-instanced",this.instancedMesh.instanceMatrix.setUsage(r.DynamicDrawUsage),this.instancedMesh.instanceColor=new r.InstancedBufferAttribute(new Float32Array(3*n),3),this.instanceColors=this.instancedMesh.instanceColor.array,e.add(this.instancedMesh)}writeInstance(e,t){if(!this.instancedMesh||!this.instanceColors||!e)return;const i=this.instancedMesh,s=new r.Color(t?this.defaultOnMaterial.color:this.defaultOffMaterial.color),n=this.instanceIndex(e.id,!0),a=(new r.Matrix4).makeTranslation(e.position.x,e.position.y,e.position.z);i.setMatrixAt(n,a),this.instanceColors[3*n+0]=s.r,this.instanceColors[3*n+1]=s.g,this.instanceColors[3*n+2]=s.b,i.instanceMatrix.needsUpdate=!0,i.instanceColor.needsUpdate=!0}instanceIndex(e,t=!1){const i=parseInt(e.replace("ann_",""),10);if(!this.instancedMesh||Number.isNaN(i))return-1;if(i>=this.instancedMesh.count){if(!t)return-1;{const e=i+1;this.instancedMesh.count=e}}return i}}const pt=class e{constructor(t){this.surfaces=new Map,this.enabled=!0,this.lastPickTime=0,this.pickThrottleMs=16,this.savedClearColor=new r.Color,this.pickWorldPos=new r.Vector3,this.pickCamera=null,this.renderer=t,this.pickingTexture=new r.WebGLRenderTarget(1,1,{minFilter:r.NearestFilter,magFilter:r.NearestFilter,format:r.RGBAFormat,type:r.UnsignedByteType}),this.pixelBuffer=new Uint8Array(4),this.pickScene=new r.Scene,this.pickScene.background=e.NO_HIT_COLOR,this.pickMaterial=new r.ShaderMaterial({vertexShader:"\n  attribute float vertexId;\n  varying vec3 vPickColor;\n\n  void main() {\n    // Encode vertex index into RGB\n    float id = vertexId;\n    float r = mod(id, 256.0) / 255.0;\n    float g = mod(floor(id / 256.0), 256.0) / 255.0;\n    float b = mod(floor(id / 65536.0), 256.0) / 255.0;\n    vPickColor = vec3(r, g, b);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }\n",fragmentShader:"\n  varying vec3 vPickColor;\n\n  void main() {\n    gl_FragColor = vec4(vPickColor, 1.0);\n  }\n",side:r.DoubleSide}),de("GPUPicker initialized")}addSurface(e,t){this.surfaces.has(e)&&this.removeSurface(e);const i=t.geometry,s=i.getAttribute("position").count,n=new Float32Array(s);for(let r=0;r<s;r++)n[r]=r;const a=i.clone();a.setAttribute("vertexId",new r.BufferAttribute(n,1));const o=new r.Mesh(a,this.pickMaterial);o.matrixAutoUpdate=!1,this.pickScene.add(o),this.surfaces.set(e,{mesh:t,pickMesh:o,id:e}),de(`GPUPicker: Added surface "${e}" with ${s} vertices`)}removeSurface(e){const t=this.surfaces.get(e);return!!t&&(this.pickScene.remove(t.pickMesh),t.pickMesh.geometry.dispose(),this.surfaces.delete(e),de(`GPUPicker: Removed surface "${e}"`),!0)}syncTransforms(){for(const e of this.surfaces.values())e.pickMesh.matrix.copy(e.mesh.matrixWorld),e.pickMesh.matrixWorld.copy(e.mesh.matrixWorld)}setEnabled(e){this.enabled=e}isEnabled(){return this.enabled}setThrottleMs(e){this.pickThrottleMs=Math.max(0,e)}pick(t,i,r,s){if(!this.enabled)return{surfaceId:null,vertexIndex:null,point:null,faceIndex:null};const n=performance.now();if(n-this.lastPickTime<this.pickThrottleMs)return{surfaceId:null,vertexIndex:null,point:null,faceIndex:null};this.lastPickTime=n,s||(s=this.renderer.domElement.getBoundingClientRect());const a=t-s.left,o=i-s.top;this.syncTransforms();const l=this.renderer.getPixelRatio(),h=this.renderer.getContext(),c=h.drawingBufferWidth,d=h.drawingBufferHeight;this.pickCamera&&this.pickCamera.type===r.type?this.pickCamera.copy(r):this.pickCamera=r.clone();const u=this.pickCamera;"setViewOffset"in u&&u.setViewOffset(c,d,Math.floor(a*l),Math.floor(o*l),1,1);const p=this.renderer.getRenderTarget();this.renderer.getClearColor(this.savedClearColor);const m=this.renderer.getClearAlpha();this.renderer.setRenderTarget(this.pickingTexture),this.renderer.setClearColor(e.NO_HIT_COLOR,1),this.renderer.clear(),this.renderer.render(this.pickScene,u),this.renderer.readRenderTargetPixels(this.pickingTexture,0,0,1,1,this.pixelBuffer),this.renderer.setRenderTarget(p),this.renderer.setClearColor(this.savedClearColor,m);const f=this.pixelBuffer[0]|this.pixelBuffer[1]<<8|this.pixelBuffer[2]<<16;if(f===e.NO_HIT_ID)return{surfaceId:null,vertexIndex:null,point:null,faceIndex:null};for(const[e,g]of this.surfaces){const t=g.mesh.geometry,i=t.getAttribute("position");if(f<i.count){this.pickWorldPos.set(i.getX(f),i.getY(f),i.getZ(f));return{surfaceId:e,vertexIndex:f,point:this.pickWorldPos.applyMatrix4(g.mesh.matrixWorld),faceIndex:this.findFaceContainingVertex(t,f)}}}return{surfaceId:null,vertexIndex:null,point:null,faceIndex:null}}pickNDC(e,t,i){const r=this.renderer.domElement.getBoundingClientRect(),s=(e+1)/2*r.width+r.left,n=(1-t)/2*r.height+r.top;return this.pick(s,n,i,r)}findFaceContainingVertex(e,t){const i=e.index;if(!i)return null;const r=i.array;for(let s=0;s<r.length;s+=3)if(r[s]===t||r[s+1]===t||r[s+2]===t)return Math.floor(s/3);return null}static isSupported(e){const t=e.getContext();return null!==t&&(t instanceof WebGLRenderingContext||t instanceof WebGL2RenderingContext)}dispose(){this.pickingTexture.dispose(),this.pickMaterial.dispose();for(const e of this.surfaces.values())e.pickMesh.geometry.dispose();this.surfaces.clear(),de("GPUPicker disposed")}};pt.NO_HIT_COLOR=new r.Color(1,1,1),pt.NO_HIT_ID=16777215;let mt=pt;class ft extends r.ShaderMaterial{constructor(e){const{volumeTexture:t,worldToIJK:i,colormapTexture:s,config:n={}}=e,{intensityRange:a=[0,1],threshold:o=[0,0],overlayOpacity:l=1,baseColor:h=8947848,fillValue:c=0,ambientIntensity:d=.3,diffuseIntensity:u=.6,specularIntensity:p=.1,shininess:m=30}=n,f=new r.Color(h);super({glslVersion:r.GLSL3,vertexShader:"\nprecision highp float;\nprecision highp sampler3D;\n\nuniform sampler3D uVolumeSampler;\nuniform mat4 uWorldToIJK;\nuniform vec3 uVolumeDims;\nuniform float uFillValue;\n\nout float vValue;\nout float vInBounds;\nout vec3 vNormalView;\nout vec3 vViewPosition;\n\nbool inBoundsIJK(vec3 ijk) {\n  return all(greaterThanEqual(ijk, vec3(0.0))) &&\n         all(lessThan(ijk, uVolumeDims));\n}\n\nvoid main() {\n  vec4 worldPos = modelMatrix * vec4(position, 1.0);\n  vec3 ijk = (uWorldToIJK * worldPos).xyz;\n\n  if (inBoundsIJK(ijk)) {\n    vec3 uvw = (ijk + vec3(0.5)) / uVolumeDims;\n    vValue = texture(uVolumeSampler, uvw).r;\n    vInBounds = 1.0;\n  } else {\n    vValue = uFillValue;\n    vInBounds = 0.0;\n  }\n\n  vNormalView = normalize(normalMatrix * normal);\n\n  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n  vViewPosition = -mvPosition.xyz;\n  gl_Position = projectionMatrix * mvPosition;\n}\n",fragmentShader:"\nprecision highp float;\n\nuniform sampler2D uColormapSampler;\nuniform vec2 uIntensityRange;\nuniform vec2 uThreshold;\nuniform float uOverlayOpacity;\nuniform vec3 uBaseColor;\nuniform float uFillValue;\n\nuniform float uAmbientIntensity;\nuniform float uDiffuseIntensity;\nuniform float uSpecularIntensity;\nuniform float uShininess;\n\nin float vValue;\nin float vInBounds;\nin vec3 vNormalView;\nin vec3 vViewPosition;\n\nout vec4 outColor;\n\nfloat normalizeValue(float v, float vmin, float vmax) {\n  float range = max(vmax - vmin, 1e-10);\n  return clamp((v - vmin) / range, 0.0, 1.0);\n}\n\nvoid main() {\n  vec3 N = normalize(vNormalView);\n  vec3 L = normalize(vec3(0.3, 0.5, 1.0));\n  vec3 V = normalize(vViewPosition);\n  vec3 H = normalize(L + V);\n\n  float NdotL = max(dot(N, L), 0.0);\n  float NdotH = max(dot(N, H), 0.0);\n\n  float ambient = uAmbientIntensity;\n  float diffuse = uDiffuseIntensity * NdotL;\n  float specular = uSpecularIntensity * pow(NdotH, uShininess);\n  float shade = ambient + diffuse + specular;\n\n  vec3 baseRgb = uBaseColor * shade;\n\n  // Match surfviewjs threshold semantics: hide values inside [min,max], show outside.\n  bool thresholdActive = abs(uThreshold.x - uThreshold.y) > 1e-10;\n  bool hiddenByThreshold = thresholdActive && (vValue >= uThreshold.x && vValue <= uThreshold.y);\n\n  bool isFill = abs(vValue - uFillValue) < 1e-6;\n  if (vInBounds < 0.5 || isFill || hiddenByThreshold) {\n    outColor = vec4(baseRgb, 1.0);\n    return;\n  }\n\n  float t = normalizeValue(vValue, uIntensityRange.x, uIntensityRange.y);\n  vec3 overlayRgb = texture(uColormapSampler, vec2(t, 0.5)).rgb;\n  overlayRgb *= shade;\n\n  vec3 finalRgb = mix(baseRgb, overlayRgb, uOverlayOpacity);\n  outColor = vec4(finalRgb, 1.0);\n}\n",uniforms:{uVolumeSampler:{value:t.texture},uWorldToIJK:{value:i.clone()},uVolumeDims:{value:t.dims.clone()},uFillValue:{value:c},uColormapSampler:{value:s},uIntensityRange:{value:new r.Vector2(a[0],a[1])},uThreshold:{value:new r.Vector2(o[0],o[1])},uOverlayOpacity:{value:l},uBaseColor:{value:new r.Vector3(f.r,f.g,f.b)},uAmbientIntensity:{value:d},uDiffuseIntensity:{value:u},uSpecularIntensity:{value:p},uShininess:{value:m}},side:r.DoubleSide})}set intensityRange(e){this.uniforms.uIntensityRange.value.set(e[0],e[1])}set threshold(e){this.uniforms.uThreshold.value.set(e[0],e[1])}set overlayOpacity(e){this.uniforms.uOverlayOpacity.value=e}set baseColor(e){const t=new r.Color(e);this.uniforms.uBaseColor.value.set(t.r,t.g,t.b)}set colormap(e){this.uniforms.uColormapSampler.value=e}setVolumeTexture(e){this.uniforms.uVolumeSampler.value=e.texture,this.uniforms.uVolumeDims.value.copy(e.dims)}setWorldToIJK(e){this.uniforms.uWorldToIJK.value.copy(e)}}class gt extends ye{constructor(e,t){super(e,null,[],t.materialConfig??{});const{volumeData:i,volumeDims:r,useHalfFloat:s=!1,colormap:n="viridis",intensityRange:a=[0,1],threshold:o=[0,0],overlayOpacity:l=1,baseColor:h=8947848,fillValue:c=0}=t;this.volumeTexture=new Me(i,r[0],r[1],r[2],{useHalfFloat:s}),this.worldToIJKMatrix=this.computeWorldToIJK(t),this.colormapTexture=Ce(n),this.projectionMaterial=new ft({volumeTexture:this.volumeTexture,worldToIJK:this.worldToIJKMatrix,colormapTexture:this.colormapTexture,config:{intensityRange:a,threshold:o,overlayOpacity:l,baseColor:h,fillValue:c}}),this.createMesh()}createMesh(){const e=new r.BufferGeometry;e.setAttribute("position",new r.Float32BufferAttribute(this.geometry.vertices,3));const t=this.geometry.faces&&this.geometry.faces.length>0?this.geometry.faces:new Uint32Array(Array.from({length:this.geometry.vertices.length/3},((e,t)=>t)));return e.setIndex(new r.Uint32BufferAttribute(t,1)),this.mesh=new r.Mesh(e,this.projectionMaterial),this.computeNormals(e),this.mesh}updateColors(){}updateVolumeData(e){this.volumeTexture.updateData(e),this.emit("render:needed",{surface:this})}setIntensityRange(e,t){this.projectionMaterial.intensityRange=[e,t],this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}setThreshold(e,t){this.projectionMaterial.threshold=[e,t],this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}setOverlayOpacity(e){this.projectionMaterial.overlayOpacity=e,this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}setBaseColor(e){this.projectionMaterial.baseColor=e,this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}setColormap(e){this.colormapTexture&&this.colormapTexture.dispose(),this.colormapTexture=Ce(e),this.projectionMaterial.colormap=this.colormapTexture,this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}setWorldToIJK(e){this.worldToIJKMatrix=e instanceof r.Matrix4?e.clone():(new r.Matrix4).fromArray(Array.from(e)),this.projectionMaterial.setWorldToIJK(this.worldToIJKMatrix),this.emit("material:updated",{surface:this}),this.emit("render:needed",{surface:this})}static isSupported(e,t={}){return Me.isSupported(e,t)}dispose(){this.colormapTexture&&this.colormapTexture.dispose(),this.volumeTexture&&this.volumeTexture.dispose(),super.dispose()}computeWorldToIJK(e){if(e.worldToIJK)return e.worldToIJK instanceof r.Matrix4?e.worldToIJK.clone():(new r.Matrix4).fromArray(Array.from(e.worldToIJK));let t;if(e.affineMatrix)t=e.affineMatrix instanceof r.Matrix4?e.affineMatrix.clone():(new r.Matrix4).fromArray(Array.from(e.affineMatrix));else{const i=e.voxelSize??[1,1,1],s=e.volumeOrigin??[0,0,0];t=(new r.Matrix4).set(i[0],0,0,s[0],0,i[1],0,s[1],0,0,i[2],s[2],0,0,0,1)}return t.clone().invert()}}class vt{constructor(e){this.group=null,this.material=null,this.parent=null,this.size=1.5,this.color=16763904,this.surfaceId=null,this.vertexIndex=null,this.visible=!1,this.mode=null,this.hoverThrottleMs=80,this.lastHoverUpdate=0,this.requestRender=e}show(e,t,i,r){const s=e.geometry.getAttribute("position");!s||i<0||i>=s.count?console.warn(`Crosshair: invalid vertex index ${i}`):(this.ensureGroup(null==r?void 0:r.size,null==r?void 0:r.color),this.parent&&this.parent!==e&&this.group&&this.parent.remove(this.group),this.group&&this.group.parent!==e&&e.add(this.group),this.group&&(this.group.position.set(s.getX(i),s.getY(i),s.getZ(i)),this.group.visible=!0),this.parent=e,this.surfaceId=t,this.vertexIndex=i,this.visible=!0,this.mode=(null==r?void 0:r.mode)??"selection",this.requestRender())}hide(){this.group&&this.parent&&this.parent.remove(this.group),this.group&&(this.group.visible=!1),this.visible=!1,this.surfaceId=null,this.vertexIndex=null,this.parent=null,this.mode=null,this.requestRender()}toggle(e,t,i,r){if(this.visible)return void this.hide();const s=t??this.surfaceId,n=i??this.vertexIndex;e&&s&&null!==n&&this.show(e,s,n,r)}canHoverUpdate(){const e=performance.now();return!(e-this.lastHoverUpdate<this.hoverThrottleMs)&&(this.lastHoverUpdate=e,!0)}toStateJSON(){return{visible:this.visible,surfaceId:this.surfaceId,vertexIndex:this.vertexIndex,size:this.size,color:this.color,mode:this.mode}}dispose(){this.group&&(this.group.parent&&this.group.parent.remove(this.group),this.group.children.forEach((e=>{e.geometry.dispose()})),this.group=null),this.material&&(this.material.dispose(),this.material=null)}ensureGroup(e,t){const i=e??this.size,r=t??this.color,s=i!==this.size,n=r!==this.color;if(!this.group||s){this.group&&this.parent&&this.parent.remove(this.group),this.dispose(),this.group=this.buildGroup(i,r);const e=this.group.children[0];this.material=e.material}else n&&this.material&&this.material.color.setHex(r);return this.size=i,this.color=r,this.group}buildGroup(e,t){const i=new r.Group;i.name="neurosurface-crosshair";const s=e/2,n=new r.LineBasicMaterial({color:t,depthWrite:!1,depthTest:!1,transparent:!0}),a=(e,t)=>{const i=(new r.BufferGeometry).setFromPoints([e,t]);return new r.Line(i,n)};return i.add(a(new r.Vector3(-s,0,0),new r.Vector3(s,0,0))),i.add(a(new r.Vector3(0,-s,0),new r.Vector3(0,s,0))),i.add(a(new r.Vector3(0,0,-s),new r.Vector3(0,0,s))),i.renderOrder=999,i}}var yt=Uint8Array,bt=Uint16Array,wt=Uint32Array,xt=new yt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Mt=new yt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ct=new yt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),St=function(e,t){for(var i=new bt(31),r=0;r<31;++r)i[r]=t+=1<<e[r-1];var s=new wt(i[30]);for(r=1;r<30;++r)for(var n=i[r];n<i[r+1];++n)s[n]=n-i[r]<<5|r;return[i,s]},_t=St(xt,2),Tt=_t[0],At=_t[1];Tt[28]=258,At[258]=28;for(var Pt=St(Mt,0),Et=Pt[0],Lt=Pt[1],It=new bt(32768),Rt=0;Rt<32768;++Rt){var Dt=(43690&Rt)>>>1|(21845&Rt)<<1;Dt=(61680&(Dt=(52428&Dt)>>>2|(13107&Dt)<<2))>>>4|(3855&Dt)<<4,It[Rt]=((65280&Dt)>>>8|(255&Dt)<<8)>>>1}var kt=function(e,t,i){for(var r=e.length,s=0,n=new bt(t);s<r;++s)++n[e[s]-1];var a,o=new bt(t);for(s=0;s<t;++s)o[s]=o[s-1]+n[s-1]<<1;if(i){a=new bt(1<<t);var l=15-t;for(s=0;s<r;++s)if(e[s])for(var h=s<<4|e[s],c=t-e[s],d=o[e[s]-1]++<<c,u=d|(1<<c)-1;d<=u;++d)a[It[d]>>>l]=h}else for(a=new bt(r),s=0;s<r;++s)e[s]&&(a[s]=It[o[e[s]-1]++]>>>15-e[s]);return a},Ft=new yt(288);for(Rt=0;Rt<144;++Rt)Ft[Rt]=8;for(Rt=144;Rt<256;++Rt)Ft[Rt]=9;for(Rt=256;Rt<280;++Rt)Ft[Rt]=7;for(Rt=280;Rt<288;++Rt)Ft[Rt]=8;var Vt=new yt(32);for(Rt=0;Rt<32;++Rt)Vt[Rt]=5;var Bt=kt(Ft,9,0),Ot=kt(Ft,9,1),Nt=kt(Vt,5,0),Ut=kt(Vt,5,1),zt=function(e){for(var t=e[0],i=1;i<e.length;++i)e[i]>t&&(t=e[i]);return t},jt=function(e,t,i){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&i},$t=function(e,t){var i=t/8|0;return(e[i]|e[i+1]<<8|e[i+2]<<16)>>(7&t)},Gt=function(e){return(e/8|0)+(7&e&&1)},qt=function(e,t,i){(null==i||i>e.length)&&(i=e.length);var r=new(e instanceof bt?bt:e instanceof wt?wt:yt)(i-t);return r.set(e.subarray(t,i)),r},Yt=function(e,t,i){var r=e.length;if(!r||i&&!i.l&&r<5)return t||new yt(0);var s=!t||i,n=!i||i.i;i||(i={}),t||(t=new yt(3*r));var a=function(e){var i=t.length;if(e>i){var r=new yt(Math.max(2*i,e));r.set(t),t=r}},o=i.f||0,l=i.p||0,h=i.b||0,c=i.l,d=i.d,u=i.m,p=i.n,m=8*r;do{if(!c){i.f=o=jt(e,l,1);var f=jt(e,l+1,3);if(l+=3,!f){var g=e[(A=Gt(l)+4)-4]|e[A-3]<<8,v=A+g;if(v>r){if(n)throw"unexpected EOF";break}s&&a(h+g),t.set(e.subarray(A,v),h),i.b=h+=g,i.p=l=8*v;continue}if(1==f)c=Ot,d=Ut,u=9,p=5;else{if(2!=f)throw"invalid block type";var y=jt(e,l,31)+257,b=jt(e,l+10,15)+4,w=y+jt(e,l+5,31)+1;l+=14;for(var x=new yt(w),M=new yt(19),C=0;C<b;++C)M[Ct[C]]=jt(e,l+3*C,7);l+=3*b;var S=zt(M),_=(1<<S)-1,T=kt(M,S,1);for(C=0;C<w;){var A,P=T[jt(e,l,_)];if(l+=15&P,(A=P>>>4)<16)x[C++]=A;else{var E=0,L=0;for(16==A?(L=3+jt(e,l,3),l+=2,E=x[C-1]):17==A?(L=3+jt(e,l,7),l+=3):18==A&&(L=11+jt(e,l,127),l+=7);L--;)x[C++]=E}}var I=x.subarray(0,y),R=x.subarray(y);u=zt(I),p=zt(R),c=kt(I,u,1),d=kt(R,p,1)}if(l>m){if(n)throw"unexpected EOF";break}}s&&a(h+131072);for(var D=(1<<u)-1,k=(1<<p)-1,F=l;;F=l){var V=(E=c[$t(e,l)&D])>>>4;if((l+=15&E)>m){if(n)throw"unexpected EOF";break}if(!E)throw"invalid length/literal";if(V<256)t[h++]=V;else{if(256==V){F=l,c=null;break}var B=V-254;if(V>264){var O=xt[C=V-257];B=jt(e,l,(1<<O)-1)+Tt[C],l+=O}var N=d[$t(e,l)&k],U=N>>>4;if(!N)throw"invalid distance";l+=15&N;R=Et[U];if(U>3){O=Mt[U];R+=$t(e,l)&(1<<O)-1,l+=O}if(l>m){if(n)throw"unexpected EOF";break}s&&a(h+131072);for(var z=h+B;h<z;h+=4)t[h]=t[h-R],t[h+1]=t[h+1-R],t[h+2]=t[h+2-R],t[h+3]=t[h+3-R];h=z}}i.l=c,i.p=F,i.b=h,c&&(o=1,i.m=u,i.d=d,i.n=p)}while(!o);return h==t.length?t:qt(t,0,h)},Wt=function(e,t,i){i<<=7&t;var r=t/8|0;e[r]|=i,e[r+1]|=i>>>8},Xt=function(e,t,i){i<<=7&t;var r=t/8|0;e[r]|=i,e[r+1]|=i>>>8,e[r+2]|=i>>>16},Ht=function(e,t){for(var i=[],r=0;r<e.length;++r)e[r]&&i.push({s:r,f:e[r]});var s=i.length,n=i.slice();if(!s)return[ii,0];if(1==s){var a=new yt(i[0].s+1);return a[i[0].s]=1,[a,1]}i.sort((function(e,t){return e.f-t.f})),i.push({s:-1,f:25001});var o=i[0],l=i[1],h=0,c=1,d=2;for(i[0]={s:-1,f:o.f+l.f,l:o,r:l};c!=s-1;)o=i[i[h].f<i[d].f?h++:d++],l=i[h!=c&&i[h].f<i[d].f?h++:d++],i[c++]={s:-1,f:o.f+l.f,l:o,r:l};var u=n[0].s;for(r=1;r<s;++r)n[r].s>u&&(u=n[r].s);var p=new bt(u+1),m=Jt(i[c-1],p,0);if(m>t){r=0;var f=0,g=m-t,v=1<<g;for(n.sort((function(e,t){return p[t.s]-p[e.s]||e.f-t.f}));r<s;++r){var y=n[r].s;if(!(p[y]>t))break;f+=v-(1<<m-p[y]),p[y]=t}for(f>>>=g;f>0;){var b=n[r].s;p[b]<t?f-=1<<t-p[b]++-1:++r}for(;r>=0&&f;--r){var w=n[r].s;p[w]==t&&(--p[w],++f)}m=t}return[new yt(p),m]},Jt=function(e,t,i){return-1==e.s?Math.max(Jt(e.l,t,i+1),Jt(e.r,t,i+1)):t[e.s]=i},Zt=function(e){for(var t=e.length;t&&!e[--t];);for(var i=new bt(++t),r=0,s=e[0],n=1,a=function(e){i[r++]=e},o=1;o<=t;++o)if(e[o]==s&&o!=t)++n;else{if(!s&&n>2){for(;n>138;n-=138)a(32754);n>2&&(a(n>10?n-11<<5|28690:n-3<<5|12305),n=0)}else if(n>3){for(a(s),--n;n>6;n-=6)a(8304);n>2&&(a(n-3<<5|8208),n=0)}for(;n--;)a(s);n=1,s=e[o]}return[i.subarray(0,r),t]},Kt=function(e,t){for(var i=0,r=0;r<t.length;++r)i+=e[r]*t[r];return i},Qt=function(e,t,i){var r=i.length,s=Gt(t+2);e[s]=255&r,e[s+1]=r>>>8,e[s+2]=255^e[s],e[s+3]=255^e[s+1];for(var n=0;n<r;++n)e[s+n+4]=i[n];return 8*(s+4+r)},ei=function(e,t,i,r,s,n,a,o,l,h,c){Wt(t,c++,i),++s[256];for(var d=Ht(s,15),u=d[0],p=d[1],m=Ht(n,15),f=m[0],g=m[1],v=Zt(u),y=v[0],b=v[1],w=Zt(f),x=w[0],M=w[1],C=new bt(19),S=0;S<y.length;++S)C[31&y[S]]++;for(S=0;S<x.length;++S)C[31&x[S]]++;for(var _=Ht(C,7),T=_[0],A=_[1],P=19;P>4&&!T[Ct[P-1]];--P);var E,L,I,R,D=h+5<<3,k=Kt(s,Ft)+Kt(n,Vt)+a,F=Kt(s,u)+Kt(n,f)+a+14+3*P+Kt(C,T)+(2*C[16]+3*C[17]+7*C[18]);if(D<=k&&D<=F)return Qt(t,c,e.subarray(l,l+h));if(Wt(t,c,1+(F<k)),c+=2,F<k){E=kt(u,p,0),L=u,I=kt(f,g,0),R=f;var V=kt(T,A,0);Wt(t,c,b-257),Wt(t,c+5,M-1),Wt(t,c+10,P-4),c+=14;for(S=0;S<P;++S)Wt(t,c+3*S,T[Ct[S]]);c+=3*P;for(var B=[y,x],O=0;O<2;++O){var N=B[O];for(S=0;S<N.length;++S){var U=31&N[S];Wt(t,c,V[U]),c+=T[U],U>15&&(Wt(t,c,N[S]>>>5&127),c+=N[S]>>>12)}}}else E=Bt,L=Ft,I=Nt,R=Vt;for(S=0;S<o;++S)if(r[S]>255){U=r[S]>>>18&31;Xt(t,c,E[U+257]),c+=L[U+257],U>7&&(Wt(t,c,r[S]>>>23&31),c+=xt[U]);var z=31&r[S];Xt(t,c,I[z]),c+=R[z],z>3&&(Xt(t,c,r[S]>>>5&8191),c+=Mt[z])}else Xt(t,c,E[r[S]]),c+=L[r[S]];return Xt(t,c,E[256]),c+L[256]},ti=new wt([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),ii=new yt(0),ri=function(e,t,i,r,s){return function(e,t,i,r,s,n){var a=e.length,o=new yt(r+a+5*(1+Math.ceil(a/7e3))+s),l=o.subarray(r,o.length-s),h=0;if(!t||a<8)for(var c=0;c<=a;c+=65535){var d=c+65535;d<a?h=Qt(l,h,e.subarray(c,d)):(l[c]=n,h=Qt(l,h,e.subarray(c,a)))}else{for(var u=ti[t-1],p=u>>>13,m=8191&u,f=(1<<i)-1,g=new bt(32768),v=new bt(f+1),y=Math.ceil(i/3),b=2*y,w=function(t){return(e[t]^e[t+1]<<y^e[t+2]<<b)&f},x=new wt(25e3),M=new bt(288),C=new bt(32),S=0,_=0,T=(c=0,0),A=0,P=0;c<a;++c){var E=w(c),L=32767&c,I=v[E];if(g[L]=I,v[E]=L,A<=c){var R=a-c;if((S>7e3||T>24576)&&R>423){h=ei(e,l,0,x,M,C,_,T,P,c-P,h),T=S=_=0,P=c;for(var D=0;D<286;++D)M[D]=0;for(D=0;D<30;++D)C[D]=0}var k=2,F=0,V=m,B=L-I&32767;if(R>2&&E==w(c-B))for(var O=Math.min(p,R)-1,N=Math.min(32767,c),U=Math.min(258,R);B<=N&&--V&&L!=I;){if(e[c+k]==e[c+k-B]){for(var z=0;z<U&&e[c+z]==e[c+z-B];++z);if(z>k){if(k=z,F=B,z>O)break;var j=Math.min(B,z-2),$=0;for(D=0;D<j;++D){var G=c-B+D+32768&32767,q=G-g[G]+32768&32767;q>$&&($=q,I=G)}}}B+=(L=I)-(I=g[L])+32768&32767}if(F){x[T++]=268435456|At[k]<<18|Lt[F];var Y=31&At[k],W=31&Lt[F];_+=xt[Y]+Mt[W],++M[257+Y],++C[W],A=c+k,++S}else x[T++]=e[c],++M[e[c]]}}h=ei(e,l,n,x,M,C,_,T,P,c-P,h)}return qt(o,0,r+Gt(h)+s)}(e,null==t.level?6:t.level,null==t.mem?Math.ceil(1.5*Math.max(8,Math.min(13,Math.log(e.length)))):12+t.mem,i,r,!0)},si=function(e){if(31!=e[0]||139!=e[1]||8!=e[2])throw"invalid gzip data";var t=e[3],i=10;4&t&&(i+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[i++]);return i+(2&t)},ni=function(e){var t=e.length;return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0},ai=function(e){if(8!=(15&e[0])||e[0]>>>4>7||(e[0]<<8|e[1])%31)throw"invalid zlib data";if(32&e[1])throw"invalid zlib data: preset dictionaries not supported"};var oi="undefined"!=typeof TextDecoder&&new TextDecoder;try{oi.decode(ii,{stream:!0}),1}catch(qi){}const li="svjs=";function hi(e){const t=JSON.stringify(e),i=(new TextEncoder).encode(t),r=ri(i,{},0,0);return li+function(e){let t="";for(let i=0;i<e.length;i++)t+=String.fromCharCode(e[i]);return btoa(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}(r)}function ci(e){const t=e.startsWith("#")?e.slice(1):e;if(!t.startsWith(li))throw new Error('Invalid state hash: missing "svjs=" prefix');const i=t.slice(5);if(0===i.length)throw new Error("Invalid state hash: empty payload");let r;try{const e=function(e){let t=e.replace(/-/g,"+").replace(/_/g,"/");for(;t.length%4!=0;)t+="=";const i=atob(t),r=new Uint8Array(i.length);for(let s=0;s<i.length;s++)r[s]=i.charCodeAt(s);return r}(i);r=Yt(e,s)}catch(o){throw new Error(`State decode failed: corrupted or invalid data (${o.message})`)}var s;const n=(new TextDecoder).decode(r);let a;try{a=JSON.parse(n)}catch{throw new Error("State decode failed: invalid JSON")}if(!a||"object"!=typeof a)throw new Error("State decode failed: not an object");if(!("version"in a))throw new Error("State decode failed: missing version field");if(a.version>1)throw new Error(`State version ${a.version} is newer than supported (1). Please upgrade surfviewjs to load this state.`);return a.version<1?function(e){let t=e;return t}(a):a}function di(e){return{version:1,camera:ui(e),config:pi(e),surfaces:mi(e),crosshair:gi(e),timeline:vi(e),selection:yi(e)}}function ui(e){var t;const i=e.camera;if(!i)return{position:[0,0,200],quaternion:[0,0,0,1],target:[0,0,0],up:[0,1,0],zoom:1,fov:45};const r=(null==(t=e.controls)?void 0:t.target)??{x:0,y:0,z:0};return{position:[i.position.x,i.position.y,i.position.z],quaternion:[i.quaternion.x,i.quaternion.y,i.quaternion.z,i.quaternion.w],target:[r.x,r.y,r.z],up:[i.up.x,i.up.y,i.up.z],zoom:i.zoom??1,fov:i.fov??45}}function pi(e){const t={};if(e.config&&(void 0!==e.config.backgroundColor&&(t.background=e.config.backgroundColor),void 0!==e.config.rimStrength&&(t.rimStrength=e.config.rimStrength)),t.lighting={},e.ambientLight&&(t.lighting.ambientIntensity=e.ambientLight.intensity),e.directionalLight){t.lighting.directionalIntensity=e.directionalLight.intensity;const i=e.directionalLight.position;t.lighting.directionalPosition=[i.x,i.y,i.z]}return t}function mi(e){var t,i,r,s;const n={},a=e.surfaces;if(!a)return n;for(const[o,l]of a){if("function"==typeof l.toStateJSON){n[o]=l.toStateJSON(),n[o].id=o;continue}const e={id:o,type:(null==(t=l.constructor)?void 0:t.name)??"unknown",visible:(null==(i=l.mesh)?void 0:i.visible)??!0,layers:[],clipPlanes:[]};if(l.hemisphere&&(e.hemisphere=l.hemisphere),l.layerStack){const t=(null==(s=(r=l.layerStack).getAllLayers)?void 0:s.call(r))??[];for(const i of t)e.layers.push(fi(i))}l.clipPlanes&&"function"==typeof l.clipPlanes.toStateJSON&&(e.clipPlanes=l.clipPlanes.toStateJSON()),n[o]=e}return n}function fi(e){var t;return"function"==typeof e.toStateJSON?e.toStateJSON():{id:e.id,type:(null==(t=e.constructor)?void 0:t.name)??"unknown",visible:e.visible??!0,opacity:e.opacity??1,blendMode:e.blendMode??"normal",order:e.order??0}}function gi(e){const t=e.crosshair;return t?"function"==typeof t.toStateJSON?t.toStateJSON():{visible:t.visible??!1,surfaceId:t.surfaceId??null,vertexIndex:t.vertexIndex??null,size:t.size??1.5,color:t.color??16763904,mode:t.mode??null}:{visible:!1,surfaceId:null,vertexIndex:null,size:1.5,color:16763904,mode:null}}function vi(e){var t,i,r,s;const n=e.surfaces;if(!n)return null;for(const[,a]of n)if(a.timelineController){const e=a.timelineController;return"function"==typeof e.toStateJSON?e.toStateJSON():{currentTime:(null==(t=e.getCurrentTime)?void 0:t.call(e))??0,speed:(null==(i=e.getSpeed)?void 0:i.call(e))??1,loopMode:(null==(r=e.getLoopMode)?void 0:r.call(e))??"loop",playing:(null==(s=e.isPlaying)?void 0:s.call(e))??!1}}return null}function yi(e){return{surfaceId:e.selectedSurfaceId??null,layerId:e.selectedLayerId??null}}function bi(e,t){const i={success:!0,warnings:[],surfacesRestored:[],surfacesSkipped:[]};try{!function(e,t){if(!t)return;void 0!==t.background&&e.scene&&(e.scene.background=new class{constructor(e){this.isColor=!0,this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(255&e)/255}}(t.background));if(t.lighting&&(void 0!==t.lighting.ambientIntensity&&e.ambientLight&&(e.ambientLight.intensity=t.lighting.ambientIntensity),void 0!==t.lighting.directionalIntensity&&e.directionalLight&&(e.directionalLight.intensity=t.lighting.directionalIntensity),t.lighting.directionalPosition&&e.directionalLight)){const[i,r,s]=t.lighting.directionalPosition;e.directionalLight.position.set(i,r,s)}}(e,t.config)}catch(r){i.warnings.push(`config: ${r.message}`)}try{!function(e,t){var i,r,s,n;if(!e.camera||!t)return;const a=e.camera;a.position.set(t.position[0],t.position[1],t.position[2]),a.quaternion.set(t.quaternion[0],t.quaternion[1],t.quaternion[2],t.quaternion[3]),a.up.set(t.up[0],t.up[1],t.up[2]),void 0!==t.zoom&&(a.zoom=t.zoom);void 0!==t.fov&&(a.fov=t.fov);null==(i=a.updateProjectionMatrix)||i.call(a),(null==(r=e.controls)?void 0:r.target)&&(e.controls.target.set(t.target[0],t.target[1],t.target[2]),null==(n=(s=e.controls).update)||n.call(s))}(e,t.camera)}catch(r){i.warnings.push(`camera: ${r.message}`)}try{!function(e,t,i){const r=e.surfaces;if(!r||!t)return;for(const[s,n]of Object.entries(t)){const e=r.get(s);e?(i.surfacesRestored.push(s),e.mesh&&void 0!==n.visible&&(e.mesh.visible=n.visible),n.layers&&e.layerStack&&wi(e,n.layers,i),n.clipPlanes&&e.clipPlanes&&xi(e,n.clipPlanes)):(i.surfacesSkipped.push(s),i.warnings.push(`surface "${s}" not found  skipped`))}}(e,t.surfaces,i)}catch(r){i.warnings.push(`surfaces: ${r.message}`)}try{!function(e,t){if(!e.crosshair||!t)return;const i=e.crosshair;if("function"==typeof i.fromStateJSON)return void i.fromStateJSON(t);i.size=t.size??i.size,i.color=t.color??i.color,t.visible||"function"==typeof i.hide&&i.hide()}(e,t.crosshair)}catch(r){i.warnings.push(`crosshair: ${r.message}`)}if(t.timeline)try{!function(e,t){if(!t)return;const i=e.surfaces;if(!i)return;for(const[,r]of i){const e=r.timelineController;if(e)return"function"==typeof e.fromStateJSON?void e.fromStateJSON(t):("function"==typeof e.seek&&void 0!==t.currentTime&&e.seek(t.currentTime),"function"==typeof e.setSpeed&&void 0!==t.speed&&e.setSpeed(t.speed),void(t.playing&&"function"==typeof e.play?e.play():t.playing||"function"!=typeof e.pause||e.pause()))}}(e,t.timeline)}catch(r){i.warnings.push(`timeline: ${r.message}`)}try{!function(e,t){if(!t)return;void 0!==t.surfaceId&&(e.selectedSurfaceId=t.surfaceId);void 0!==t.layerId&&(e.selectedLayerId=t.layerId)}(e,t.selection)}catch(r){i.warnings.push(`selection: ${r.message}`)}return i.success=0===i.warnings.length,"function"==typeof e.emit&&e.emit("state:restored",i),"function"==typeof e.requestRender&&e.requestRender(),i}function wi(e,t,i){var r,s,n,a;const o=e.layerStack;if(o)for(const l of t){const e=null==(r=o.getLayer)?void 0:r.call(o,l.id);if(e){if(void 0!==l.visible&&(null==(s=e.setVisible)||s.call(e,l.visible)),void 0!==l.opacity&&(null==(n=e.setOpacity)||n.call(e,l.opacity)),void 0!==l.blendMode&&(null==(a=e.setBlendMode)||a.call(e,l.blendMode)),void 0!==l.order&&(e.order=l.order),"function"==typeof e.fromStateJSON)e.fromStateJSON(l);else if("function"==typeof e.update){const t={};void 0!==l.colorMapName&&(t.colorMap=l.colorMapName),void 0!==l.range&&(t.range=l.range),void 0!==l.threshold&&(t.threshold=l.threshold),e.update(t)}e.needsUpdate=!0}else i.warnings.push(`layer "${l.id}" not found  skipped`)}}function xi(e,t){var i,r;if("function"!=typeof e.clipPlanes.fromStateJSON){for(const s of t)if("custom"!==s.axis){const t=null==(r=(i=e.clipPlanes).getClipPlane)?void 0:r.call(i,s.axis);t&&(t.setFromAxisDistance(s.axis,s.distance,s.flip),t.enabled=s.enabled)}}else e.clipPlanes.fromStateJSON(t)}const Mi={linear:e=>e,easeIn:e=>e*e,easeOut:e=>e*(2-e),easeInOut:e=>e<.5?2*e*e:(4-2*e)*e-1,easeInCubic:e=>e*e*e,easeOutCubic:e=>--e*e*e+1,easeInOutCubic:e=>e<.5?4*e*e*e:(e-1)*(2*e-2)*(2*e-2)+1};class Ci extends lt{constructor(e,t={}){if(super(e,t),this.morphTargetDictionary={},this.morphTargetNames=[],this.morphTargetCurvatures={},this.animationId=null,this.surfaceSet=null,this.basePositions=new Float32Array(e.vertices),this.mesh&&this.mesh.geometry){this.mesh.geometry.morphAttributes.position=[];const e=this.mesh.material;"morphTargets"in e&&(e.morphTargets=!0),"morphNormals"in e&&(e.morphNormals=!0),e.needsUpdate=!0}if(t.morphTargets)for(const i of t.morphTargets)this.addMorphTarget(i.name,i.positions,i.curvature);de("MorphableSurface created with",this.morphTargetNames.length,"morph targets")}static fromSurfaceSet(e,t={}){const i=e.getPositions(e.defaultVariant),r=e.getCurv(e.defaultVariant),s=new ve(i,e.faces,e.hemi,r),n=new Ci(s,t);n.surfaceSet=e;for(const a of e.getVariantNames())if(a!==e.defaultVariant){const t=e.getPositions(a),i=e.getCurv(a);n.addMorphTarget(a,t,i||void 0)}return de(`MorphableSurface created from SurfaceSet with ${n.morphTargetNames.length} morph targets`),n}addMorphTarget(e,t,i){void 0!==this.morphTargetDictionary[e]&&(console.warn(`MorphableSurface: morph target "${e}" already exists, replacing`),this.removeMorphTarget(e));const s=t instanceof Float32Array?t:new Float32Array(t);if(s.length!==this.basePositions.length)throw new Error(`MorphableSurface: morph target "${e}" has ${s.length/3} vertices, expected ${this.basePositions.length/3}`);if(!this.mesh||!this.mesh.geometry)throw new Error("MorphableSurface: mesh not initialized");const n=this.mesh.geometry,a=new Float32Array(s.length);for(let r=0;r<s.length;r++)a[r]=s[r]-this.basePositions[r];const o=new r.Float32BufferAttribute(a,3);o.name=e;const l=n.morphAttributes.position,h=l.length;l.push(o),this.morphTargetDictionary[e]=h,this.morphTargetNames.push(e),i&&(this.morphTargetCurvatures[e]=i instanceof Float32Array?i:new Float32Array(i)),this.mesh.morphTargetInfluences||(this.mesh.morphTargetInfluences=[]),this.mesh.morphTargetInfluences[h]=0,this.mesh.morphTargetDictionary={...this.morphTargetDictionary},n.computeVertexNormals(),de(`Added morph target "${e}" at index ${h}`)}removeMorphTarget(e){var t;const i=this.morphTargetDictionary[e];if(void 0===i)return!1;if(!this.mesh||!this.mesh.geometry)return!1;this.mesh.geometry.morphAttributes.position.splice(i,1),this.morphTargetNames.splice(this.morphTargetNames.indexOf(e),1),null==(t=this.mesh.morphTargetInfluences)||t.splice(i,1),delete this.morphTargetDictionary[e];for(const[r,s]of Object.entries(this.morphTargetDictionary))s>i&&(this.morphTargetDictionary[r]=s-1);return this.mesh.morphTargetDictionary={...this.morphTargetDictionary},delete this.morphTargetCurvatures[e],de(`Removed morph target "${e}"`),!0}getMorphTargetNames(){return[...this.morphTargetNames]}hasMorphTarget(e){return void 0!==this.morphTargetDictionary[e]}getMorphWeight(e){var t,i;const r=this.morphTargetDictionary[e];return void 0===r?(console.warn(`MorphableSurface: morph target "${e}" not found`),0):(null==(i=null==(t=this.mesh)?void 0:t.morphTargetInfluences)?void 0:i[r])??0}getMorphWeights(){const e={};for(const t of this.morphTargetNames)e[t]=this.getMorphWeight(t);return e}setMorphWeight(e,t){var i;const r=this.morphTargetDictionary[e];void 0!==r?(null==(i=this.mesh)?void 0:i.morphTargetInfluences)&&(this.mesh.morphTargetInfluences[r]=t,this.emit("morph:changed",{surface:this,target:e,weight:t}),this.emit("render:needed",{surface:this})):console.warn(`MorphableSurface: morph target "${e}" not found`)}setMorphWeights(e){var t;for(const[i,r]of Object.entries(e)){const e=this.morphTargetDictionary[i];void 0!==e&&(null==(t=this.mesh)?void 0:t.morphTargetInfluences)&&(this.mesh.morphTargetInfluences[e]=r)}this.emit("morph:changed",{surface:this,weights:e}),this.emit("render:needed",{surface:this})}resetMorphWeights(){var e;if(null==(e=this.mesh)?void 0:e.morphTargetInfluences){for(let e=0;e<this.mesh.morphTargetInfluences.length;e++)this.mesh.morphTargetInfluences[e]=0;this.emit("morph:changed",{surface:this,weights:this.getMorphWeights()}),this.emit("render:needed",{surface:this})}}morphTo(e,t={}){return new Promise((i=>{var r;const s=this.morphTargetDictionary[e];if(void 0===s)return console.warn(`MorphableSurface: morph target "${e}" not found`),void i();this.cancelAnimation();const{duration:n=500,easing:a=Mi.easeInOut,onComplete:o,onProgress:l}=t,h=(null==(r=this.mesh)?void 0:r.morphTargetInfluences)?[...this.mesh.morphTargetInfluences]:[],c=new Array(this.morphTargetNames.length).fill(0);c[s]=1;const d=performance.now(),u=t=>{var r;const s=t-d,p=Math.min(1,s/n),m=a(p);if(null==(r=this.mesh)?void 0:r.morphTargetInfluences)for(let e=0;e<this.morphTargetNames.length;e++){const t=h[e]??0,i=c[e];this.mesh.morphTargetInfluences[e]=t+(i-t)*m}null==l||l(p),this.emit("morph:animating",{surface:this,progress:p}),this.emit("render:needed",{surface:this}),p<1?this.animationId=requestAnimationFrame(u):(this.animationId=null,this.emit("morph:complete",{surface:this,target:e}),null==o||o(),i())};this.animationId=requestAnimationFrame(u)}))}morphToBase(e={}){return new Promise((t=>{var i;this.cancelAnimation();const{duration:r=500,easing:s=Mi.easeInOut,onComplete:n,onProgress:a}=e,o=(null==(i=this.mesh)?void 0:i.morphTargetInfluences)?[...this.mesh.morphTargetInfluences]:[],l=performance.now(),h=e=>{var i;const c=e-l,d=Math.min(1,c/r),u=s(d);if(null==(i=this.mesh)?void 0:i.morphTargetInfluences)for(let t=0;t<this.morphTargetNames.length;t++){const e=o[t]??0;this.mesh.morphTargetInfluences[t]=e*(1-u)}null==a||a(d),this.emit("morph:animating",{surface:this,progress:d}),this.emit("render:needed",{surface:this}),d<1?this.animationId=requestAnimationFrame(h):(this.animationId=null,this.emit("morph:complete",{surface:this,target:"base"}),null==n||n(),t())};this.animationId=requestAnimationFrame(h)}))}morphToWeights(e,t={}){return new Promise((i=>{var r;this.cancelAnimation();const{duration:s=500,easing:n=Mi.easeInOut,onComplete:a,onProgress:o}=t,l=(null==(r=this.mesh)?void 0:r.morphTargetInfluences)?[...this.mesh.morphTargetInfluences]:[],h=this.morphTargetNames.map((t=>e[t]??0)),c=performance.now(),d=t=>{var r;const u=t-c,p=Math.min(1,u/s),m=n(p);if(null==(r=this.mesh)?void 0:r.morphTargetInfluences)for(let e=0;e<this.morphTargetNames.length;e++){const t=l[e]??0,i=h[e];this.mesh.morphTargetInfluences[e]=t+(i-t)*m}null==o||o(p),this.emit("morph:animating",{surface:this,progress:p}),this.emit("render:needed",{surface:this}),p<1?this.animationId=requestAnimationFrame(d):(this.animationId=null,this.emit("morph:complete",{surface:this,weights:e}),null==a||a(),i())};this.animationId=requestAnimationFrame(d)}))}cancelAnimation(){null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null,this.emit("morph:cancelled",{surface:this}))}isAnimating(){return null!==this.animationId}getMorphValue(){var e;if(!(null==(e=this.mesh)?void 0:e.morphTargetInfluences)||0===this.morphTargetNames.length)return 0;let t=0;for(let i=0;i<this.morphTargetNames.length;i++)t+=(i+1)*(this.mesh.morphTargetInfluences[i]??0);return t}setMorphValue(e){var t;if(!(null==(t=this.mesh)?void 0:t.morphTargetInfluences)||0===this.morphTargetNames.length)return;e=Math.max(0,Math.min(this.morphTargetNames.length,e));for(let n=0;n<this.mesh.morphTargetInfluences.length;n++)this.mesh.morphTargetInfluences[n]=0;if(0===e)return this.emit("morph:changed",{surface:this,weights:this.getMorphWeights()}),void this.emit("render:needed",{surface:this});const i=Math.floor(e)-1,r=Math.ceil(e)-1,s=e-Math.floor(e);i>=0&&i<this.morphTargetNames.length&&(this.mesh.morphTargetInfluences[i]=1-s),r>=0&&r<this.morphTargetNames.length&&r!==i?this.mesh.morphTargetInfluences[r]=s:r===i&&r>=0&&(this.mesh.morphTargetInfluences[r]=1),this.emit("morph:changed",{surface:this,weights:this.getMorphWeights()}),this.emit("render:needed",{surface:this})}getInterpolatedCurvature(){var e;if(!(null==(e=this.mesh)?void 0:e.morphTargetInfluences))return this.geometry.vertexCurv;const t=this.geometry.vertexCurv;if(!t&&0===Object.keys(this.morphTargetCurvatures).length)return null;const i=this.vertexCount,r=new Float32Array(i);let s=0;for(const a of this.mesh.morphTargetInfluences)s+=a;const n=Math.max(0,1-s);if(t&&n>0)for(let a=0;a<i;a++)r[a]=t[a]*n;for(let a=0;a<this.morphTargetNames.length;a++){const e=this.morphTargetNames[a],t=this.mesh.morphTargetInfluences[a]??0,s=this.morphTargetCurvatures[e];if(s&&t>0)for(let n=0;n<i;n++)r[n]+=s[n]*t}return r}dispose(){this.cancelAnimation(),this.morphTargetDictionary={},this.morphTargetNames=[],this.morphTargetCurvatures={},this.surfaceSet=null,super.dispose()}}class Si{constructor(e){if(this.faces=new Uint32Array(e.faces),this.hemi=e.hemi,this.defaultVariant=e.defaultVariant,this.variants={},this.curv={},this.meta=e.meta||{},!e.variants[e.defaultVariant])throw new Error(`SurfaceSet: defaultVariant "${e.defaultVariant}" missing in variants map`);if(0!==this.faces.length%3)throw new Error(`SurfaceSet: faces length must be multiple of 3 (got ${this.faces.length})`);const t=new Float32Array(e.variants[e.defaultVariant]);if(t.length%3!=0)throw new Error("SurfaceSet: default variant vertex array length must be multiple of 3");this.vertexCount=t.length/3,this.variants[e.defaultVariant]=t,Object.entries(e.variants).forEach((([e,i])=>{const r=new Float32Array(i);if(r.length!==t.length)throw new Error(`SurfaceSet: variant "${e}" vertex count ${r.length/3} does not match default ${this.vertexCount}`);this.variants[e]=r})),e.curv&&Object.entries(e.curv).forEach((([e,t])=>{const i=new Float32Array(t);i.length===this.vertexCount?this.curv[e]=i:de(`SurfaceSet: ignoring curv for ${e}; expected ${this.vertexCount} values, got ${i.length}`)}))}getVariantNames(){return Object.keys(this.variants)}hasVariant(e){return e in this.variants}getPositions(e){const t=this.variants[e];if(!t)throw new Error(`SurfaceSet: variant "${e}" not found`);return t}getCurv(e){return this.curv[e]||null}}class _i extends ye{constructor(e,t,i,s,n={}){super(e,t,new Float32Array(e.vertices.length/3),n),this.labels=i instanceof Uint32Array?i:new Uint32Array(i),this.labelMap=new Map,s.forEach((e=>{this.labelMap.set(e.id,{name:e.name,color:new r.Color(e.color)})})),this.colors=new Float32Array(this.geometry.vertices.length/3*3),this.createMesh(),this.updateColors()}getLabelName(e){var t;return null==(t=this.labelMap.get(e))?void 0:t.name}setLabelColor(e,t){const i=this.labelMap.get(e);i&&(i.color=new r.Color(t),this.updateColors())}setLabels(e){this.labels=e instanceof Uint32Array?e:new Uint32Array(e),this.updateColors()}addOrUpdateLabel(e){this.labelMap.set(e.id,{name:e.name,color:new r.Color(e.color)}),this.updateColors()}createMesh(){const e=new r.BufferGeometry;e.setAttribute("position",new r.Float32BufferAttribute(this.geometry.vertices,3)),e.setIndex(new r.Uint32BufferAttribute(this.geometry.faces,1));const t=new r.MeshPhongMaterial({vertexColors:!0,transparent:this.config.alpha<1,opacity:this.config.alpha,shininess:this.config.shininess||30,specular:new r.Color(this.config.specularColor||1118481),emissive:new r.Color(this.config.emissive||0),emissiveIntensity:this.config.emissiveIntensity||0,flatShading:this.config.flatShading||!1,side:r.DoubleSide,depthWrite:this.config.alpha>=1});return this.mesh=new r.Mesh(e,t),this.computeNormals(e),this.mesh}updateColors(){if(!this.mesh)return;const e=this.mesh.geometry,t=e.getAttribute("color"),i=this.colors,s=this.labels,n=new r.Color(10066329);for(let r=0,a=0;r<s.length;r++,a+=3){const e=this.labelMap.get(s[r]),t=(null==e?void 0:e.color)||n;i[a]=t.r,i[a+1]=t.g,i[a+2]=t.b}t?(t.array.set(i),t.needsUpdate=!0):e.setAttribute("color",new r.Float32BufferAttribute(i,3)),this.emit("layer:updated",{surface:this}),this.emit("render:needed",{surface:this})}}class Ti{static fromConfig(e){const t=new ve(e.vertices,e.faces,e.hemisphere||"unknown",e.vertexCurv??null);switch(e.type){case"multi-layer":return new lt(t,e.config);case"color-mapped":return new be(t,e.indices??null,e.data??new Float32Array(t.vertices.length/3),e.colorMap||"jet",e.config);case"vertex-colored":if(!e.colors)throw new Error("vertex-colored surface requires colors array");return new we(t,e.indices??null,e.colors,e.config);case"variant":{if(e.surfaceSet)return new ht(e.surfaceSet,e.config);if(!e.variants||!e.defaultVariant)throw new Error("variant surface requires variants and defaultVariant");const t=new Si({faces:e.faces,hemi:e.hemisphere||"unknown",defaultVariant:e.defaultVariant,variants:e.variants,curv:e.curv});return new ht(t,e.config)}case"labeled":if(!e.labels||!e.labelDefs)throw new Error("labeled surface requires labels and labelDefs");return new _i(t,e.indices??null,e.labels,e.labelDefs,e.config);default:throw new Error(`Unsupported surface type: ${e.type}`)}}static create(e){return Ti.fromConfig(e)}}const Ai="\n.neurosurface-root {\n  margin: 0;\n  padding: 0;\n  position: relative;\n}\n.neurosurface-root canvas {\n  display: block;\n}\n";const Pi={width:200,height:80,lineColor:"#00ccff",bgColor:"rgba(0, 0, 0, 0.85)",timeMarkerColor:"#ff4444",padding:8};function Ei(e,t){if(t<=0||t>1)throw new Error(`FDR q must be in (0, 1], got ${t}`);const i=e.length;if(0===i)return{pThreshold:0,survivingMask:new Uint8Array(0),survivingCount:0};const r=new Array(i);for(let l=0;l<i;l++)r[l]=l;r.sort(((t,i)=>{const r=e[t],s=e[i];return isNaN(r)?1:isNaN(s)?-1:r-s}));let s=-1;for(let l=0;l<i;l++){const n=r[l],a=e[n],o=(l+1)/i*t;!isNaN(a)&&a<=o&&(s=l)}let n=0;s>=0&&(n=e[r[s]]);const a=new Uint8Array(i);let o=0;for(let l=0;l<i;l++){const t=e[l];!isNaN(t)&&t<=n&&(a[l]=1,o++)}return{pThreshold:n,survivingMask:a,survivingCount:o}}function Li(e,t){if(t<=0||t>1)throw new Error(`Bonferroni alpha must be in (0, 1], got ${t}`);const i=e.length;if(0===i)return{pThreshold:0,survivingMask:new Uint8Array(0),survivingCount:0};const r=t/i,s=new Uint8Array(i);let n=0;for(let a=0;a<i;a++){const t=e[a];!isNaN(t)&&t<=r&&(s[a]=1,n++)}return{pThreshold:r,survivingMask:s,survivingCount:n}}function Ii(e,t){const i=e.length,r=new Int32Array(i);r.fill(-1);const s=new Map;let n=0;const a=[];for(let o=0;o<i;o++)if(1===e[o]&&-1===r[o]){const i=n;let l=0;for(a.push(o),r[o]=i,l++;a.length>0;){const s=t[a.shift()];if(s)for(const t of s)1===e[t]&&-1===r[t]&&(r[t]=i,l++,a.push(t))}s.set(i,l),n++}return{clusterIds:r,clusterSizes:s,clusterCount:n}}function Ri(e,t,i){const r=e.length,s=new Uint8Array(r);for(let n=0;n<r;n++){const r=e[n];if(r>=0){const e=t.get(r);void 0!==e&&e>=i&&(s[n]=1)}}return s}function Di(e){if(e<0||e>1)throw new Error(`p-value must be in [0, 1], got ${e}`);if(0===e)return 38;if(1===e)return 0;const t=e/2,i=Math.sqrt(-2*Math.log(t));return i-(2.515517+.802853*i+.010328*i*i)/(1+1.432788*i+.189269*i*i+.001308*i*i*i)}function ki(e,t){if(t<1)throw new Error(`Degrees of freedom must be >= 1, got ${t}`);if(t>30){return(1-1/(4*t))*e/Math.sqrt(1+e*e/(2*t))}{const i=e*e/t,r=2/(9*t),s=(Math.pow(i/(1+i),1/3)-(1-r))/Math.sqrt(r);return e>=0?Math.abs(s):-Math.abs(s)}}class Fi extends Te{constructor(e,t,i,r,s={}){super(e,t,i,r,s),this._correctionMethod="none",this._correctionMask=null,this._clusterMask=null,this._clusterResult=null,this._fdrQ=0,this._bonferroniAlpha=0,this._clusterThreshold=0,this._clusterMinSize=0,this._adjacency=null,this._dualThreshold=null,this._negativeColorMap=null,this._statRGBABuffer=null;const n=t instanceof Float32Array?t:new Float32Array(t);if(i)this._statIndices=i instanceof Uint32Array?i:new Uint32Array(i);else{this._statIndices=new Uint32Array(n.length);for(let e=0;e<n.length;e++)this._statIndices[e]=e}if(this._positiveColorMap=Fi._resolveColorMap(r),this._positiveColorMap.setRange(s.range||[0,1]),this._positiveColorMap.setThreshold(s.threshold||[0,0]),this._pValues=s.pValues??null,this._statType=s.statType??"generic",this._degreesOfFreedom=s.degreesOfFreedom??1,this._pValues&&this._pValues.length!==n.length)throw new Error(`pValues length (${this._pValues.length}) must match data length (${n.length})`)}setMeshAdjacency(e,t){if(e instanceof ve)this._adjacency=e.getAdjacency();else{if(void 0===t||t<=0)throw new Error("vertexCount is required when passing raw faces");this._adjacency=ge(e,t)}}applyFDR(e){if(!this._pValues)throw new Error("Cannot apply FDR: p-values not provided. Pass pValues in config.");const t=Ei(this._pValues,e);this._correctionMethod="fdr",this._correctionMask=t.survivingMask,this._clusterMask=null,this._clusterResult=null,this._fdrQ=e,this._invalidateRGBA()}applyBonferroni(e){if(!this._pValues)throw new Error("Cannot apply Bonferroni: p-values not provided. Pass pValues in config.");const t=Li(this._pValues,e);this._correctionMethod="bonferroni",this._correctionMask=t.survivingMask,this._clusterMask=null,this._clusterResult=null,this._bonferroniAlpha=e,this._invalidateRGBA()}applyClusterThreshold(e,t){if(!this._adjacency)throw new Error("Cannot apply cluster threshold: mesh adjacency not set. Call setMeshAdjacency() first.");const i=this.getData();if(!i)throw new Error("No data available for cluster thresholding");const r=this._adjacency.vertexCount,s=new Uint8Array(r),n=this._statIndices;for(let l=0;l<n.length&&l<i.length;l++){const t=n[l];t>=0&&t<r&&isFinite(i[l])&&Math.abs(i[l])>e&&(s[t]=1)}const a=Ii(s,this._adjacency.neighbors),o=Ri(a.clusterIds,a.clusterSizes,t.minClusterSize);this._correctionMethod="cluster",this._correctionMask=null,this._fdrQ=0,this._bonferroniAlpha=0,this._clusterMask=o,this._clusterResult=a,this._clusterThreshold=e,this._clusterMinSize=t.minClusterSize,this._invalidateRGBA()}clearCorrection(){this._correctionMethod="none",this._correctionMask=null,this._clusterMask=null,this._clusterResult=null,this._fdrQ=0,this._bonferroniAlpha=0,this._clusterThreshold=0,this._clusterMinSize=0,this._invalidateRGBA()}setDualThreshold(e){this._dualThreshold=e,this._positiveColorMap=me.fromPreset(e.positiveColorMap),this._positiveColorMap.setRange(e.positiveRange),this._positiveColorMap.setThreshold([0,0]),this._negativeColorMap=me.fromPreset(e.negativeColorMap),this._negativeColorMap.setRange(e.negativeRange),this._negativeColorMap.setThreshold([0,0]),this._invalidateRGBA()}clearDualThreshold(){this._dualThreshold=null,this._negativeColorMap=null,this._positiveColorMap.setRange(this.getRange()),this._positiveColorMap.setThreshold(this.getThreshold()),this._invalidateRGBA()}getCorrectionMethod(){return this._correctionMethod}getFDRQ(){return this._fdrQ}getBonferroniAlpha(){return this._bonferroniAlpha}getClusterMinSize(){return this._clusterMinSize}getClusterThreshold(){return this._clusterThreshold}getVertexStatInfo(e){const t=this.getData();if(!t)return null;const i=this._findDataIndex(e);if(-1===i)return null;const r=t[i],s=this._pValues?this._pValues[i]:null;let n=null;null!==s&&isFinite(s)&&s>0&&s<1?n=Di(s):"tstat"===this._statType&&isFinite(r)?n=ki(r,this._degreesOfFreedom):"zstat"===this._statType&&isFinite(r)&&(n=r);let a=-1,o=0;return this._clusterResult&&(a=this._clusterResult.clusterIds[e]??-1,a>=0&&(o=this._clusterResult.clusterSizes.get(a)??0)),{value:r,pValue:s,zScore:n,clusterIndex:a,clusterSize:o}}setColorMap(e){super.setColorMap(e),this._positiveColorMap=Fi._resolveColorMap(e),this._positiveColorMap.setRange(this.getRange()),this._positiveColorMap.setThreshold(this.getThreshold()),this._invalidateRGBA()}setRange(e){super.setRange(e),this._dualThreshold||this._positiveColorMap.setRange(e),this._invalidateRGBA()}setThreshold(e){super.setThreshold(e),this._dualThreshold||this._positiveColorMap.setThreshold(e),this._invalidateRGBA()}setData(e,t){super.setData(e,t);const i=e instanceof Float32Array?e:new Float32Array(e);if(t)this._statIndices=t instanceof Uint32Array?t:new Uint32Array(t);else{this._statIndices=new Uint32Array(i.length);for(let e=0;e<i.length;e++)this._statIndices[e]=e}this.clearCorrection()}getRGBAData(e){const t=this.getData();if(!t)throw new Error("StatisticalMapLayer: no data set");this._statRGBABuffer&&this._statRGBABuffer.length===4*e||(this._statRGBABuffer=new Float32Array(4*e));const i=this._statRGBABuffer;i.fill(0);const r=this._statIndices,s=this.getThreshold(),n=s[0]!==s[1],a=null!==this._dualThreshold,o=this.opacity;for(let l=0;l<r.length&&l<t.length;l++){const h=r[l],c=t[l];if(h<0||h>=e||!isFinite(c))continue;if(this._correctionMask&&0===this._correctionMask[l])continue;if(this._clusterMask&&0===this._clusterMask[h])continue;if(n&&c>=s[0]&&c<=s[1])continue;let d;if(a)if(c>0)d=this._positiveColorMap.getColor(c);else{if(!(c<0&&this._negativeColorMap))continue;d=this._negativeColorMap.getColor(c)}else d=this._positiveColorMap.getColor(c);const u=4*h;i[u]=d[0],i[u+1]=d[1],i[u+2]=d[2],i[u+3]=(d[3]??1)*o}return i}update(e){void 0!==e.pValues&&(this._pValues=e.pValues),void 0!==e.statType&&(this._statType=e.statType),void 0!==e.degreesOfFreedom&&(this._degreesOfFreedom=e.degreesOfFreedom),super.update(e)}toStateJSON(){return{...super.toStateJSON(),type:"statistical",correctionMethod:this.getCorrectionMethod(),fdrQ:this._fdrQ,bonferroniAlpha:this._bonferroniAlpha,statType:this._statType,degreesOfFreedom:this._degreesOfFreedom,dualThreshold:this._dualThreshold?{...this._dualThreshold}:null}}dispose(){this._pValues=null,this._correctionMask=null,this._clusterMask=null,this._clusterResult=null,this._adjacency=null,this._dualThreshold=null,this._negativeColorMap=null,this._statRGBABuffer=null,this._statIndices=null,super.dispose()}_invalidateRGBA(){this._statRGBABuffer=null,this._notifyChange()}_findDataIndex(e){const t=this._statIndices;if(t.length>e&&t[e]===e)return e;for(let i=0;i<t.length;i++)if(t[i]===e)return i;return-1}static _resolveColorMap(e){return e instanceof me?e:"string"==typeof e?me.fromPreset(e):new me(e)}}const Vi=Se.fromConfig.bind(Se);Se.fromConfig=e=>{if("statistical"===e.type){if(!e.data)throw new Error("StatisticalMapLayer requires data");return new Fi(e.id,e.data,e.indices??null,e.cmap??e.colorMap??"hot",{visible:e.visible,opacity:e.opacity,blendMode:e.blendMode,order:e.order,range:e.range,threshold:e.threshold,pValues:e.pValues,statType:e.statType,degreesOfFreedom:e.degreesOfFreedom})}return Vi(e)};class Bi{static needsScaling(e,t=100){let i=0;for(let r=0;r<e.length;r++)i=Math.max(i,Math.abs(e[r]));return i<.1*t}static calculateScaleFactor(e,t=100){let i=1/0,r=1/0,s=1/0,n=-1/0,a=-1/0,o=-1/0;for(let u=0;u<e.length;u+=3)i=Math.min(i,e[u]),n=Math.max(n,e[u]),r=Math.min(r,e[u+1]),a=Math.max(a,e[u+1]),s=Math.min(s,e[u+2]),o=Math.max(o,e[u+2]);const l=n-i,h=a-r,c=o-s,d=Math.max(l,h,c);return 0===d?1:t/d}static scaleVertices(e,t){for(let i=0;i<e.length;i++)e[i]*=t}static autoScale(e,t=100){if(this.needsScaling(e,t)){const i=this.calculateScaleFactor(e,t);return this.scaleVertices(e,i),i}return 1}}async function Oi(e){var t,i;if(e)return e;if("undefined"!=typeof DOMParser)return DOMParser;if("undefined"!=typeof globalThis&&!!(null==(i=null==(t=globalThis.process)?void 0:t.versions)?void 0:i.node))try{const e="jsdom",t=await import(e);if(null==t?void 0:t.JSDOM)return(new t.JSDOM).window.DOMParser;if(null==t?void 0:t.DOMParser)return t.DOMParser}catch(r){throw new Error("DOMParser not available; install jsdom or pass a DOMParser to parseGIfTISurface. "+r.message)}throw new Error("DOMParser not available; supply one (e.g., from jsdom) to parse GIFTI.")}function Ni(e){if(!e||e.byteLength<15)throw new Error("Invalid FreeSurfer surface: file too small");const t=new DataView(e);let i=0;for(i+=3;i<e.byteLength&&10!==t.getUint8(i);)if(i++,i>=e.byteLength)throw new Error("Invalid FreeSurfer surface: unexpected end of file");if(i++,i++,i+8>e.byteLength)throw new Error("Invalid FreeSurfer surface: missing vertex/face counts");const r=t.getInt32(i,!1);i+=4;const s=t.getInt32(i,!1);if(i+=4,r<=0||r>1e7)throw new Error(`Invalid FreeSurfer surface: vertex count out of range (${r})`);if(s<=0||s>2e7)throw new Error(`Invalid FreeSurfer surface: face count out of range (${s})`);const n=i+3*r*4+3*s*4;if(e.byteLength<n)throw new Error("Invalid FreeSurfer surface: file truncated");const a=new Float32Array(3*r);for(let l=0;l<3*r;l++)a[l]=t.getFloat32(i,!1),i+=4;const o=new Uint32Array(3*s);for(let l=0;l<3*s;l++)o[l]=t.getInt32(i,!1),i+=4;return{vertices:a,faces:o}}function Ui(e,t){if(!e||e.length<20)throw new Error("Invalid GIFTI surface: empty or too small");const i=t||("undefined"!=typeof DOMParser?DOMParser:null);if(!i)throw new Error("GIFTI parsing requires DOMParser; provide one (e.g., from jsdom) when running outside the browser.");const r=(new i).parseFromString(e,"application/xml");if(r.querySelector("parsererror"))throw new Error("Invalid GIFTI surface: XML parse error");let s=null,n=null;const a=r.getElementsByTagName("DataArray");for(let o=0;o<a.length;o++){const e=a[o],t=e.getAttribute("Intent"),i=e.getAttribute("DataType"),r=e.getAttribute("Encoding"),l=e.getAttribute("Endian")||"LittleEndian";if("NIFTI_INTENT_POINTSET"===t){const t=zi(e,i||"",r||"",l);t instanceof Float32Array&&(s=t)}else if("NIFTI_INTENT_TRIANGLE"===t){const t=zi(e,i||"",r||"",l);t instanceof Uint32Array&&(n=t)}}if(!s||!n)throw new Error("Failed to parse GIFTI surface: missing vertices or faces");return{vertices:s,faces:n}}function zi(e,t,i,r){const s=e.getElementsByTagName("Data")[0];if(!s||!s.textContent)return null;const n=s.textContent.trim(),a="BigEndian"!==r;if("ASCII"===i){const e=n.split(/\s+/).filter((e=>e.length>0));if("NIFTI_TYPE_FLOAT32"===t)return new Float32Array(e.map(parseFloat));if("NIFTI_TYPE_INT32"===t||"NIFTI_TYPE_UINT32"===t)return new Uint32Array(e.map((e=>parseInt(e,10))))}else{if("Base64Binary"===i){return $i(ji(n),t,a)}if("GZipBase64Binary"===i)try{const e=function(e){const t=ji(e);return new Uint8Array(t)}(n);let i;try{i=function(e){return Yt(e.subarray(si(e),-8),new yt(ni(e)))}(e)}catch(o){try{i=function(e,t){return Yt((ai(e),e.subarray(2,-4)),t)}(e),console.warn("GZipBase64Binary payload lacked gzip header; unzlib fallback succeeded.")}catch(l){throw console.warn("Failed to decompress GZipBase64Binary GIFTI data array",o,l),l}}const r=new ArrayBuffer(i.byteLength);return new Uint8Array(r).set(i),$i(r,t,a)}catch(h){throw h}}return null}function ji(e){const t=atob(e.replace(/\s+/g,"")),i=new ArrayBuffer(t.length),r=new Uint8Array(i);for(let s=0;s<t.length;s++)r[s]=t.charCodeAt(s);return i}function $i(e,t,i){const r=new DataView(e);if("NIFTI_TYPE_FLOAT32"===t){if(i)return new Float32Array(e);const t=e.byteLength/4,s=new Float32Array(t);for(let e=0;e<t;e++)s[e]=r.getFloat32(4*e,i);return s}if("NIFTI_TYPE_FLOAT64"===t){const t=e.byteLength/8,s=new Float32Array(t);for(let e=0;e<t;e++)s[e]=r.getFloat64(8*e,i);return s}if("NIFTI_TYPE_INT32"===t||"NIFTI_TYPE_UINT32"===t){if(i)return new Uint32Array(e);const t=e.byteLength/4,s=new Uint32Array(t);for(let e=0;e<t;e++)s[e]=r.getUint32(4*e,i);return s}if("NIFTI_TYPE_INT16"===t){const t=e.byteLength/2,s=new Uint32Array(t);for(let e=0;e<t;e++){const t=r.getInt16(2*e,i);s[e]=t}return s}if("NIFTI_TYPE_UINT16"===t){const t=e.byteLength/2,s=new Uint32Array(t);for(let e=0;e<t;e++)s[e]=r.getUint16(2*e,i);return s}if("NIFTI_TYPE_UINT8"===t||"NIFTI_TYPE_INT8"===t){const t=e.byteLength,i=new Uint32Array(t);for(let e=0;e<t;e++)i[e]=r.getUint8(e);return i}return console.warn(`Unsupported GIFTI DataType: ${t}`),null}function Gi(e){if(!e)throw new Error("Invalid PLY surface: no data provided");let t;if(e instanceof ArrayBuffer){if(0===e.byteLength)throw new Error("Invalid PLY surface: empty file");t=(new TextDecoder).decode(e)}else t=e;if(!t.startsWith("ply"))throw new Error("Invalid PLY surface: missing PLY header");const i=t.split("\n");let r=0,s=0,n=0;for(let l=0;l<i.length;l++){const e=i[l].trim();if("end_header"===e){r=l+1;break}if(e.startsWith("element vertex")){const t=e.split(" ");if(t.length>=3&&(s=parseInt(t[2]),isNaN(s)||s<=0))throw new Error("Invalid PLY surface: invalid vertex count")}if(e.startsWith("element face")){const t=e.split(" ");if(t.length>=3&&(n=parseInt(t[2]),isNaN(n)||n<=0))throw new Error("Invalid PLY surface: invalid face count")}}if(0===r)throw new Error("Invalid PLY surface: no end_header found");if(i.length<r+s+n)throw new Error("Invalid PLY surface: insufficient data lines");const a=new Float32Array(3*s);for(let l=0;l<s;l++){const e=i[r+l];if(!e)throw new Error(`Invalid PLY surface: missing vertex data at line ${r+l}`);const t=e.trim().split(" ");if(t.length<3)throw new Error(`Invalid PLY surface: incomplete vertex data at line ${r+l}`);const s=parseFloat(t[0]),n=parseFloat(t[1]),o=parseFloat(t[2]);if(isNaN(s)||isNaN(n)||isNaN(o))throw new Error(`Invalid PLY surface: non-numeric vertex data at line ${r+l}`);a[3*l]=s,a[3*l+1]=n,a[3*l+2]=o}const o=new Uint32Array(3*n);for(let l=0;l<n;l++){const e=i[r+s+l];if(!e)throw new Error(`Invalid PLY surface: missing face data at line ${r+s+l}`);const t=e.trim().split(" ");if(t.length<4)throw new Error(`Invalid PLY surface: incomplete face data at line ${r+s+l}`);if(3!==parseInt(t[0]))throw new Error(`Invalid PLY surface: non-triangular face at line ${r+s+l}`);const n=parseInt(t[1]),a=parseInt(t[2]),h=parseInt(t[3]);if(isNaN(n)||isNaN(a)||isNaN(h))throw new Error(`Invalid PLY surface: non-numeric face indices at line ${r+s+l}`);if(n<0||n>=s||a<0||a>=s||h<0||h>=s)throw new Error(`Invalid PLY surface: face index out of range at line ${r+s+l}`);o[3*l]=n,o[3*l+1]=a,o[3*l+2]=h}return{vertices:a,faces:o}}
/**
   * SurfViewJS - Neuroimaging Surface Visualization Library
   *
   * A comprehensive Three.js-based library for visualizing brain surfaces
   * with support for multiple data layers, colormaps, and interactive controls.
   *
   * @module surfviewjs
   * @see {@link https://github.com/bbuchsbaum/surfviewjs} for documentation
   * @license MIT
   */
Se.registerTemporalLayer(Ue),e.THREE=r,e.AnnotationManager=ut,e.BaseLayer=Ee,e.BoundingBoxHelper=ct,e.CURRENT_VERSION=1,e.ClipPlane=ke,e.ClipPlaneSet=Fe,e.ColorMap=me,e.ColorMap2D=xe,e.ColorMappedNeuroSurface=be,e.ConnectivityLayer=Oe,e.CrosshairManager=vt,e.CurvatureLayer=Re,e.DataLayer=Te,e.Easing=Mi,e.EventEmitter=he,e.GPULayerCompositor=Ve,e.GPUPicker=mt,e.LabelLayer=Le,e.LabeledNeuroSurface=_i,e.LaplacianSmoothing=fe,e.Layer=Se,e.LayerStack=Ie,e.MorphableSurface=Ci,e.MultiLayerNeuroSurface=lt,e.NeuroSurface=ye,e.NeuroSurfaceViewer=class extends he{constructor(e,t,i,s={},n="lateral"){if(super(),this.ssaoPass=null,this.paneMinimizeButtonEl=null,this.layerOpacityBindingState={opacity:1},this.selectedLayerId=null,this.selectedSurfaceId=null,this.gpuPicker=null,this.onControlsChange=()=>{this.requestRender()},this.initializationFailed=!1,this.container=e,"undefined"!=typeof window){"static"===window.getComputedStyle(e).position&&(e.style.position="relative")}return this.hasDOM()?this.isWebGLAvailable()?(this.width=t,this.height=i,this.config={ambientLightColor:11908533,directionalLightColor:16777215,directionalLightIntensity:1.6,rotationSpeed:2,initialZoom:12,ssaoRadius:4,ssaoKernelSize:32,rimStrength:0,metalness:.1,roughness:.6,useShaders:!1,showControls:!1,useControls:!1,allowCDNFallback:!1,backgroundColor:0,controlType:"trackball",preset:"default",linkHemispheres:!1,hoverCrosshair:!1,hoverCrosshairColor:6737151,hoverCrosshairSize:1.2,clickToAddAnnotation:!1,useGPUPicking:!1,...s},this.viewpoint=n,this.surfaces=new Map,this.rimStrengthUniforms=[],this.options=new Map,this.sceneBoundsRadius=0,this.selectedLayerId=null,this.selectedSurfaceId=null,this.raycaster=new r.Raycaster,this.mouse=new r.Vector2,this.intersectionPoint=new r.Vector3,this.scene=new r.Scene,this.environmentMap=null,this.camera=new r.PerspectiveCamera(35,this.width/this.height,.1,1e3),this.renderer=new r.WebGLRenderer({antialias:!0}),this.annotations=new ut(this),this.crosshair=new vt((()=>this.requestRender())),this.setupRenderer(),this.setupContextLossHandling(),this.capabilities=dt(this.renderer),this.setupCamera(),this.setupLighting(),this.setupControls(),this.setupPicking(),this.setupSurfaceClick(),this.setupPostProcessing(),"presentation"===this.config.preset&&this.applyPresentationPreset(),this.handleSurfaceClick=this.onSurfaceClickHandler.bind(this),this.animationId=null,this.paneContainer=null,this.needsRender=!0,this.pane=null,this.paneLoading=!1,this.controlsEnabled=!0,this.paneContentEl=null,this.paneHandleEl=null,this.paneDragState={dragging:!1,offsetX:0,offsetY:0,pointerId:null,minimized:!1},this.viewpointState=null,this.currentViewpointKey="",this.colormapBindingState=null,this.viewBindingState={viewpoint:n},this.variantBindingState=null,this.dataRange={min:0,max:500},this.intensityRange={range:{min:0,max:500}},this.thresholdRange={range:{min:0,max:0}},this.animate=this.animate.bind(this),this.viewpoints={left_lateral:{direction:new r.Vector3(-1,0,0),up:new r.Vector3(0,0,1)},left_medial:{direction:new r.Vector3(1,0,0),up:new r.Vector3(0,0,1)},left_ventral:{direction:new r.Vector3(0,0,-1),up:new r.Vector3(0,1,0)},left_posterior:{direction:new r.Vector3(0,-1,0),up:new r.Vector3(0,0,1)},left_anterior:{direction:new r.Vector3(0,1,0),up:new r.Vector3(0,0,1)},right_lateral:{direction:new r.Vector3(1,0,0),up:new r.Vector3(0,0,1)},right_medial:{direction:new r.Vector3(-1,0,0),up:new r.Vector3(0,0,1)},right_ventral:{direction:new r.Vector3(0,0,-1),up:new r.Vector3(0,1,0)},right_posterior:{direction:new r.Vector3(0,-1,0),up:new r.Vector3(0,0,1)},right_anterior:{direction:new r.Vector3(0,1,0),up:new r.Vector3(0,0,1)},unknown_lateral:{direction:new r.Vector3(1,0,0),up:new r.Vector3(0,0,1)}},this.config.showControls&&this.config.useControls&&setTimeout((()=>this.setupTweakPane()),0),void this.animate()):(this.renderFallback("WebGL is not available in this browser or on this hardware."),void(this.initializationFailed=!0)):(this.renderFallback("NeuroSurfaceViewer requires a browser DOM environment."),void(this.initializationFailed=!0))}setupRenderer(){this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(this.width,this.height),this.renderer.setClearColor(this.config.backgroundColor);const e=this.renderer;"outputColorSpace"in e&&(e.outputColorSpace=r.SRGBColorSpace??"srgb"),this.renderer.toneMapping=r.NoToneMapping,this.renderer.toneMappingExposure=1,this.renderer.shadowMap.enabled=!1,this.renderer.shadowMap.type=r.PCFSoftShadowMap,this.container.appendChild(this.renderer.domElement)}setupContextLossHandling(){const e=this.renderer.domElement;e.addEventListener("webglcontextlost",(e=>{e.preventDefault(),console.warn("surfviewjs: WebGL context lost. Rendering paused."),null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null),this.emit("context:lost")})),e.addEventListener("webglcontextrestored",(()=>{console.info("surfviewjs: WebGL context restored. Resuming rendering."),this.needsRender=!0,this.animate(),this.emit("context:restored")}))}setupCamera(){this.camera.position.set(0,0,this.config.initialZoom),this.camera.lookAt(new r.Vector3(0,0,0)),this.camera.up.set(0,1,0),this.camera.updateProjectionMatrix()}setupLighting(){this.ambientLight=new r.AmbientLight(this.config.ambientLightColor,1.25),this.scene.add(this.ambientLight),this.directionalLight=new r.DirectionalLight(this.config.directionalLightColor,this.config.directionalLightIntensity),this.directionalLight.position.set(1,1,1),this.directionalLight.castShadow=!1,this.scene.add(this.directionalLight);const e=new r.DirectionalLight(16777215,.8);e.position.set(-1,-.5,-1),this.scene.add(e)}setupControls(){"surface"===this.config.controlType?(this.controls=new N(this.camera,this.renderer.domElement),this.controls.rotateSpeed=this.config.rotationSpeed,this.controls.enableDamping=!1,this.controls.dampingFactor=.05,this.controls.zoomSpeed=.8,this.controls.panSpeed=.8,this.controls.minDistance=.05,this.controls.maxDistance=1/0,this.controls.target.set(0,0,0),this.camera.position.z=this.config.initialZoom):(this.controls=new S(this.camera,this.renderer.domElement),this.controls.rotateSpeed=this.config.rotationSpeed,this.controls.zoomSpeed=.8,this.controls.panSpeed=.8,this.controls.keys=["KeyA","KeyS","KeyD"],this.controls.minDistance=.05,this.controls.maxDistance=1/0,this.controls.target.set(0,0,0),this.camera.position.z=this.config.initialZoom,this.controls.update()),this.controls.addEventListener&&this.controls.addEventListener("change",this.onControlsChange)}computeRangeStep(){const e=this.dataRange.max-this.dataRange.min,t=Math.abs(e)/1e3;return isFinite(t)&&0!==t?Math.max(.001,t):.1}getLayerOptions(){const e=this.getActiveMultiLayerEntry();if(!e)return null;const t=e.surface.layerStack.getAllLayers();if(!t.length)return null;const i={};t.forEach((e=>i[e.id]=e.id));const r=this.selectedLayerId&&t.find((e=>e.id===this.selectedLayerId))?this.selectedLayerId:t[0].id;return{options:i,selectedLayerId:r,surfaceId:e.id}}getActiveMultiLayerEntry(){let e=null;if(this.surfaces.forEach(((t,i)=>{t instanceof lt&&(e||(e={id:i,surface:t}))})),!e)return null;if(this.selectedSurfaceId&&this.surfaces.has(this.selectedSurfaceId)){const e=this.surfaces.get(this.selectedSurfaceId);if(e instanceof lt)return{id:this.selectedSurfaceId,surface:e}}return e}getActiveVariantEntry(){let e=null;if(this.surfaces.forEach(((t,i)=>{t instanceof ht&&(e||(e={id:i,surface:t}))})),!e)return null;if(this.selectedSurfaceId&&this.surfaces.has(this.selectedSurfaceId)){const e=this.surfaces.get(this.selectedSurfaceId);if(e instanceof ht)return{id:this.selectedSurfaceId,surface:e}}return e}getActiveLayer(){const e=this.getActiveMultiLayerEntry();if(!e)return null;const t=this.selectedLayerId,i=e.surface.layerStack.getAllLayers(),r=i.find((e=>e.id===t))||i[0];return r?{surface:e.surface,layer:r,surfaceId:e.id}:null}syncLayerBindingsFromSelection(){const e=this.getActiveLayer();if(e){if("getRange"in e.layer&&"getThreshold"in e.layer){const t=e.layer.getRange(),i=e.layer.getThreshold();this.intensityRange.range.min=t[0],this.intensityRange.range.max=t[1],this.thresholdRange.range.min=i[0],this.thresholdRange.range.max=i[1]}if("getColorMapName"in e.layer){const t=e.layer.getColorMapName();this.colormapBindingState?this.colormapBindingState.colormap=t:this.colormapBindingState={colormap:t}}void 0!==e.layer.opacity&&(this.layerOpacityBindingState.opacity=e.layer.opacity),this.pane&&this.pane.refresh()}}applyColormapChange(e){var t,i;const r=this.getActiveLayer();if(r&&"setColorMap"in r.layer)return r.layer.setColorMap(e),null==(i=(t=r.surface).requestColorUpdate)||i.call(t),this.emit("layer:colormap",{surfaceId:r.surfaceId,layerId:r.layer.id,colormap:e}),void this.requestRender();this.surfaces.forEach(((t,i)=>{t instanceof be&&(t.setColorMap(e),this.emit("surface:colormap",{surfaceId:i,colormap:e}))})),this.requestRender()}applyIntensityRangeChange(){var e,t;const i=[this.intensityRange.range.min,this.intensityRange.range.max],r=this.getActiveLayer();if(r&&"setRange"in r.layer)return r.layer.setRange(i),null==(t=(e=r.surface).requestColorUpdate)||t.call(e),this.emit("layer:intensity",{surfaceId:r.surfaceId,layerId:r.layer.id,range:i}),void this.requestRender();this.surfaces.forEach((e=>{e instanceof be&&e.colorMap&&e.colorMap.setRange(i)})),this.requestRender()}applyThresholdChange(){var e,t;const i=[this.thresholdRange.range.min,this.thresholdRange.range.max],r=this.getActiveLayer();if(r&&"setThreshold"in r.layer)return r.layer.setThreshold(i),null==(t=(e=r.surface).requestColorUpdate)||t.call(e),this.emit("layer:threshold",{surfaceId:r.surfaceId,layerId:r.layer.id,threshold:i}),void this.requestRender();this.surfaces.forEach((e=>{e instanceof be&&e.colorMap&&e.colorMap.setThreshold(i)})),this.requestRender()}applyOpacityChange(e){var t,i;const r=this.getActiveLayer();r&&"setOpacity"in r.layer&&(r.layer.setOpacity(e),null==(i=(t=r.surface).requestColorUpdate)||i.call(t),this.emit("layer:opacity",{surfaceId:r.surfaceId,layerId:r.layer.id,opacity:e}),this.requestRender())}setupPostProcessing(){this.composer=new H(this.renderer);const e=new J(this.scene,this.camera);this.composer.addPass(e),this.config.useShaders?(this.ssaoPass=new te(this.scene,this.camera,this.width,this.height),this.ssaoPass.kernelRadius=this.config.ssaoRadius,this.composer.addPass(this.ssaoPass)):this.ssaoPass=null}async setupTweakPane(){if(this.config.useControls&&!this.pane&&!this.paneLoading){this.paneLoading=!0;try{const{Pane:e,essentials:t}=await this.loadTweakpane();await this.buildTweakPane(e,t,null),!this.config.showControls&&this.paneContainer&&(this.paneContainer.style.display="none")}catch(e){console.error("setupTweakPane failed",e),de("setupTweakPane failed",e)}finally{this.paneLoading=!1}}}async loadTweakpane(){const e="undefined"!=typeof window&&(window.tweakpane||window.Tweakpane||window.Pane);if(e&&e.Pane)return{Pane:e.Pane,essentials:e.EssentialsPlugin||null};try{const e=await import("tweakpane"),t=await import("@tweakpane/plugin-essentials").catch((()=>null));return{Pane:e.Pane||e.default||e,essentials:t?t.default??t:null}}catch(t){de("loadTweakpane: bare import failed, trying CDN fallback",t)}if(this.config.allowCDNFallback){const e="https://cdn.jsdelivr.net/npm/tweakpane@4.0.3/dist/tweakpane.min.js",t=await import(e);return{Pane:t.Pane||t.default||t,essentials:null}}throw new Error("Tweakpane not available; install it as a peer or provide a global Pane/Tweakpane.")}async buildTweakPane(e,t,i){var r;this.paneContainer=document.createElement("div"),this.paneContainer.style.position="absolute",this.paneContainer.style.top="10px",this.paneContainer.style.right="10px",this.paneContainer.style.zIndex="1000",this.paneContainer.style.maxHeight="90%",this.paneContainer.style.minWidth="260px",this.paneContainer.style.pointerEvents="auto",this.paneContainer.style.boxShadow="0 4px 12px rgba(0,0,0,0.25)",this.paneContainer.style.borderRadius="6px",this.paneContainer.style.background="rgba(255,255,255,0.92)",this.paneContainer.style.backdropFilter="blur(4px)",this.paneContainer.style.overflow="hidden",this.paneHandleEl=document.createElement("div"),this.paneHandleEl.style.height="14px",this.paneHandleEl.style.cursor="grab",this.paneHandleEl.style.display="flex",this.paneHandleEl.style.alignItems="center",this.paneHandleEl.style.justifyContent="space-between",this.paneHandleEl.style.padding="0 6px",this.paneHandleEl.style.background="linear-gradient(90deg, rgba(0,0,0,0.08), rgba(0,0,0,0.02))",this.paneHandleEl.style.borderBottom="1px solid rgba(0,0,0,0.08)",this.paneHandleEl.style.userSelect="none";const s=document.createElement("span");s.textContent=" drag",s.style.fontSize="10px",s.style.opacity="0.7";const n=document.createElement("button");n.textContent="",n.title="Minimize / restore controls",n.style.border="none",n.style.background="transparent",n.style.cursor="pointer",n.style.fontSize="12px",n.style.lineHeight="12px",n.style.padding="0 4px",this.paneHandleEl.appendChild(s),this.paneHandleEl.appendChild(n),this.paneMinimizeButtonEl=n,this.paneContainer.appendChild(this.paneHandleEl),this.paneContentEl=document.createElement("div"),this.paneContentEl.style.maxHeight="calc(90vh - 40px)",this.paneContentEl.style.overflow="auto",this.paneContainer.appendChild(this.paneContentEl),this.container.appendChild(this.paneContainer),this.pane=new e({container:this.paneContentEl});const a=t?t.default??t:null,o=i?i.default??i:null,l=!!a;if(a)try{this.pane.registerPlugin(a)}catch(M){console.warn("Failed to register Tweakpane essentials plugin:",M),de("Failed to register essentials plugin",M)}if(o)try{this.pane.registerPlugin(o)}catch(M){console.warn("Failed to register Tweakpane interval plugin (may be incompatible with Tweakpane v4):",M)}this.paneContentEl&&n.addEventListener("click",(()=>{this.togglePaneMinimized()})),this.setupPaneDragging();const h=this.pane.addFolder({title:"Layer",expanded:!0}),c=this.getLayerOptions();if(c){this.selectedLayerId||(this.selectedLayerId=c.selectedLayerId,this.selectedSurfaceId=c.surfaceId);const e={layer:this.selectedLayerId||c.selectedLayerId};h.addBinding(e,"layer",{label:"active layer",options:c.options}).on("change",(e=>{this.selectedLayerId=e.value,this.selectedSurfaceId=c.surfaceId,this.syncLayerBindingsFromSelection()}))}const d=this.getActiveVariantEntry();if(d){const e=this.pane.addFolder({title:"Surface",expanded:!0}),t=d.surface.variantNames().reduce(((e,t)=>(e[t]=t,e)),{});this.variantBindingState={variant:d.surface.currentVariant()},e.addBinding(this.variantBindingState,"variant",{label:"variant",options:t}).on("change",(e=>{this.selectedSurfaceId=d.id,this.setSurfaceVariant(d.id,e.value,{animate:!0})}))}else this.variantBindingState=null;const u=this.pane.addFolder({title:"Colormap",expanded:!0}),p=me.getAvailableMaps(),m=(null==(r=this.colormapBindingState)?void 0:r.colormap)||(p.includes("jet")?"jet":p[0]||"jet");this.colormapBindingState={colormap:m};const f=(p.length?p:[m]).reduce(((e,t)=>(e[t]=t,e)),{});u.addBinding(this.colormapBindingState,"colormap",{options:f,label:"colormap"}).on("change",(e=>{this.colormapBindingState.colormap=e.value,this.applyColormapChange(e.value)}));const g=this.computeRangeStep();u.addBinding(this.intensityRange.range,"min",{label:"intensity min",min:this.dataRange.min,max:this.dataRange.max,step:g}).on("change",(()=>{this.intensityRange.range.min>this.intensityRange.range.max&&(this.intensityRange.range.min=this.intensityRange.range.max),this.applyIntensityRangeChange()})),u.addBinding(this.intensityRange.range,"max",{label:"intensity max",min:this.dataRange.min,max:this.dataRange.max,step:g}).on("change",(()=>{this.intensityRange.range.max<this.intensityRange.range.min&&(this.intensityRange.range.max=this.intensityRange.range.min),this.applyIntensityRangeChange()})),u.addBinding(this.thresholdRange.range,"min",{label:"threshold min",min:this.dataRange.min,max:this.dataRange.max,step:g}).on("change",(()=>{this.thresholdRange.range.min>this.thresholdRange.range.max&&(this.thresholdRange.range.min=this.thresholdRange.range.max),this.applyThresholdChange()})),u.addBinding(this.thresholdRange.range,"max",{label:"threshold max",min:this.dataRange.min,max:this.dataRange.max,step:g}).on("change",(()=>{this.thresholdRange.range.max<this.thresholdRange.range.min&&(this.thresholdRange.range.max=this.thresholdRange.range.min),this.applyThresholdChange()})),u.addBinding(this.layerOpacityBindingState,"opacity",{label:"layer opacity",min:0,max:1,step:.01}).on("change",(e=>{this.applyOpacityChange(e.value)}));const v=this.pane.addFolder({title:"Lighting",expanded:!1});v.addBinding({ambientColor:`#${this.config.ambientLightColor.toString(16).padStart(6,"0")}`},"ambientColor",{view:"color"}).on("change",(e=>{const t=parseInt(e.value.replace("#",""),16);this.updateConfig({ambientLightColor:t})})),v.addBinding({directionalColor:`#${this.config.directionalLightColor.toString(16).padStart(6,"0")}`},"directionalColor",{view:"color"}).on("change",(e=>{const t=parseInt(e.value.replace("#",""),16);this.updateConfig({directionalLightColor:t})})),v.addBinding({intensity:this.config.directionalLightIntensity},"intensity",{min:0,max:2,step:.1}).on("change",(e=>{this.updateDirectionalLightIntensity(e.value),this.config.directionalLightIntensity=e.value})),v.addBinding({background:`#${this.config.backgroundColor.toString(16).padStart(6,"0")}`},"background",{view:"color"}).on("change",(e=>{const t=parseInt(e.value.replace("#",""),16);this.updateConfig({backgroundColor:t})}));const y=this.pane.addFolder({title:"Post Processing",expanded:!1});y.addBinding({ssaoRadius:this.config.ssaoRadius},"ssaoRadius",{min:0,max:32,step:.1}).on("change",(e=>{this.ssaoPass&&(this.ssaoPass.kernelRadius=e.value,this.requestRender())})),y.addBinding({ssaoKernelSize:this.config.ssaoKernelSize},"ssaoKernelSize",{min:1,max:128,step:1}).on("change",(e=>{if(this.ssaoPass){const t=Math.max(1,Math.floor(e.value));"function"==typeof this.ssaoPass.generateSampleKernel&&(this.ssaoPass.generateSampleKernel(t),this.requestRender())}}));const b=this.pane.addFolder({title:"Performance",expanded:!1});b.addBinding({gpuCompositing:!1},"gpuCompositing",{label:"GPU Compositing"}).on("change",(e=>{this.surfaces.forEach((t=>{"setCompositingMode"in t&&(t.setCompositingMode(e.value),de(`Surface compositing mode: ${t.getCompositingMode()}`))})),this.requestRender()})),b.addBinding({wideLines:!0},"wideLines",{label:"Wide Lines"}).on("change",(e=>{this.surfaces.forEach((t=>{t instanceof lt&&t.setWideLines(e.value)})),this.requestRender()}));const w=this.pane.addFolder({title:"Material",expanded:!1}),x=this.pane.addFolder({title:"View",expanded:!0});if(this.viewBindingState?this.viewBindingState.viewpoint=this.viewpoint:this.viewBindingState={viewpoint:this.viewpoint},x.addBinding(this.viewBindingState,"viewpoint",{options:{lateral:"lateral",medial:"medial",ventral:"ventral",posterior:"posterior",anterior:"anterior",unknown_lateral:"unknown_lateral"}}).on("change",(e=>{this.setViewpoint(e.value)})),x.addButton({title:"Fit View"}).on("click",(()=>{this.centerCamera()})),w.addBinding({metalness:this.config.metalness},"metalness",{min:0,max:1,step:.01}).on("change",(e=>{this.config.metalness=e.value,this.updateMaterials()})),w.addBinding({roughness:this.config.roughness},"roughness",{min:0,max:1,step:.01}).on("change",(e=>{this.config.roughness=e.value,this.updateMaterials()})),w.addBinding({rimStrength:this.config.rimStrength},"rimStrength",{min:0,max:2,step:.01}).on("change",(e=>{this.config.rimStrength=e.value,this.rimStrengthUniforms.forEach((t=>{t.value=e.value})),this.config.useShaders&&e.value>0&&Object.values(this.surfaces).forEach((e=>{var t;if(e.mesh&&e.mesh.material){const i=e.mesh.material;(null==(t=i.userData)?void 0:t.hasRimShader)||(this.addRimLightingShader(e.mesh),i.userData={...i.userData,hasRimShader:!0})}})),this.requestRender()})),this.resetCameraButton=this.pane.addButton({title:"Reset Camera"}),this.resetCameraButton.on("click",(()=>{this.resetCamera()})),l)try{this.fpsGraph=this.pane.addBlade({view:"fpsgraph",label:"FPS",rows:2})}catch(M){console.warn("Failed to add fpsgraph blade; continuing without it",M),this.fpsGraph=null}else this.fpsGraph=null}setupPaneDragging(){if(!this.paneContainer||!this.paneHandleEl)return;const e=this.paneHandleEl;e.style.touchAction="none",e.addEventListener("pointerdown",(t=>{this.paneDragState.dragging=!0,this.paneDragState.pointerId=t.pointerId,e.setPointerCapture(t.pointerId);const i=this.paneContainer.getBoundingClientRect();this.paneDragState.offsetX=t.clientX-i.left,this.paneDragState.offsetY=t.clientY-i.top,e.style.cursor="grabbing"}));const t=e=>{if(!this.paneDragState.dragging||!this.paneContainer)return;const t=this.container.getBoundingClientRect(),i=this.paneContainer.getBoundingClientRect();let r=e.clientX-this.paneDragState.offsetX-t.left,s=e.clientY-this.paneDragState.offsetY-t.top;r=Math.max(0,Math.min(r,t.width-i.width)),s=Math.max(0,Math.min(s,t.height-i.height)),this.paneContainer.style.left=`${r}px`,this.paneContainer.style.top=`${s}px`,this.paneContainer.style.right="auto",this.paneContainer.style.bottom="auto"},i=t=>{null!==this.paneDragState.pointerId&&t.pointerId!==this.paneDragState.pointerId||(this.paneDragState.dragging=!1,this.paneDragState.pointerId=null,e.releasePointerCapture(t.pointerId),e.style.cursor="grab")};this.handlePanePointerMove=t,this.handlePanePointerUp=i,window.addEventListener("pointermove",t),window.addEventListener("pointerup",i),window.addEventListener("pointercancel",i)}normalizeHemisphere(e){if(!e)return"unknown";const t=e.toLowerCase();return"lh"===t||"l"===t||"left"===t?"left":"rh"===t||"r"===t||"right"===t?"right":t}setViewpoint(e){let t=e;const i=this.surfaces.values().next().value;if(i&&i.hemisphere){const r=this.normalizeHemisphere(i.hemisphere);e.includes("_")||(t=`${r}_${e}`)}if(!this.viewpoints[t]){const i=this.viewpoints[e]?e:"unknown_lateral";de(`Viewpoint ${t} not found, falling back to ${i}`),t=i}const s=this.viewpoints[t];if(!s)return void de(`Viewpoint ${t} still unavailable; skipping update`);const{direction:n,up:a}=s,o=this.config.initialZoom,l=n.clone().normalize().multiplyScalar(o);this.camera.position.copy(l),this.camera.up.copy(a).normalize(),this.camera.lookAt(new r.Vector3(0,0,0)),this.controls&&(this.controls.target.set(0,0,0),this.controls.update()),this.viewpointState={rotation:this.camera.quaternion.clone(),position:this.camera.position.clone(),target:new r.Vector3(0,0,0)},this.currentViewpointKey=t;const h=t.includes("_")?t.split("_")[1]:t;this.viewpoint=h,this.viewBindingState&&this.viewBindingState.viewpoint!==h&&(this.viewBindingState.viewpoint=h,this.pane&&this.pane.refresh()),this.emit("viewpoint:changed",{viewpoint:t}),this.requestRender()}setHemisphereView(e){const t=this.surfaces.values().next().value,i=`${(null==t?void 0:t.hemisphere)||"unknown"}_${"inferior"===e?"ventral":e}`;this.setViewpoint(i)}separateHemispheres(e=20){const t=e/2;this.surfaces.forEach((e=>{e.mesh&&("left"===e.hemisphere?e.mesh.position.x=-t:"right"===e.hemisphere&&(e.mesh.position.x=t))})),this.requestRender()}updateColormap(e){this.applyColormapChange(e)}updateAmbientLight(e){this.ambientLight&&(this.ambientLight.color.setHex(e),this.requestRender())}updateDirectionalLight(e){this.directionalLight&&(this.directionalLight.color.setHex(e),this.requestRender())}updateDirectionalLightIntensity(e){this.directionalLight&&(this.directionalLight.intensity=e,this.requestRender())}updateMaterials(){this.surfaces.forEach((e=>{if(e.mesh)if(e.mesh.material&&e.mesh.material.isMeshPhysicalMaterial){const t=e.mesh.material;t.metalness=this.config.metalness,t.roughness=this.config.roughness,t.envMap=this.environmentMap}else{const t=e.mesh.material,i=new r.MeshPhysicalMaterial({color:t.color||16777215,vertexColors:t.vertexColors||!1,flatShading:t.flatShading||!1,metalness:this.config.metalness,roughness:this.config.roughness,envMap:this.environmentMap,envMapIntensity:1});e.mesh.material=i,t.dispose()}})),this.requestRender()}updateIntensityRange(){this.applyIntensityRangeChange()}updateThresholdRange(){this.applyThresholdChange()}resetCamera(){if(this.camera&&this.controls){const e=this.sceneBoundsRadius>0?Math.max(.05,.6*this.sceneBoundsRadius):.05,t=this.sceneBoundsRadius>0?Math.max(20*this.sceneBoundsRadius,this.config.initialZoom):1/0;this.controls.minDistance=e,this.controls.maxDistance=t,this.camera.position.set(0,0,this.config.initialZoom),this.camera.up.set(0,1,0),this.controls.target.set(0,0,0),this.controls.update(),this.requestRender()}}addSurface(e,t){try{if(de("Adding surface:",e,"with id:",t),!e)return void console.error("Surface is null or undefined");if(t||(t=`surface_${this.surfaces.size}`),e.viewer=this,e.mesh||(de("Surface mesh not created. Creating now."),e.createMesh()),!e.mesh)return void console.error("Failed to create surface mesh");if(e.mesh&&e.mesh.material&&this.config.useShaders&&this.config.rimStrength>0){this.addRimLightingShader(e.mesh);const t=e.mesh.material;t.userData={...t.userData,hasRimShader:!0}}if(e.data&&e.data.length>0?(de("Updating data range for surface with data"),this.updateDataRange(e.data)):de("Surface has no data, using default ranges"),this.surfaces.set(t,e),this.scene.add(e.mesh),e instanceof lt&&e.updateOutlineResolution(this.width,this.height,this.renderer.getPixelRatio()),e.on("render:needed",(()=>this.requestRender())),e.on("visibility:changed",(()=>this.requestRender())),e.on("opacity:changed",(()=>this.requestRender())),e.on("material:updated",(()=>this.requestRender())),e.on("geometry:updated",(()=>this.requestRender())),e.on("layer:added",(()=>this.requestRender())),e.on("layer:removed",(()=>this.requestRender())),e.on("layer:updated",(()=>this.requestRender())),this.emit("surface:added",{surface:e,id:t}),this.centerCamera(),1===this.surfaces.size&&this.setViewpoint(this.viewpoint),e instanceof lt&&!this.selectedLayerId){const i=e.layerStack.getAllLayers();i.length&&(this.selectedLayerId=i[0].id,this.selectedSurfaceId=t)}this.gpuPicker&&e.mesh&&this.gpuPicker.addSurface(t,e.mesh),this.requestRender()}catch(i){console.error("Error adding surface:",i),t&&this.surfaces.has(t)&&this.surfaces.delete(t)}}addVolumeProjectedSurface(e,t,i,r={}){if(!gt.isSupported(this.renderer,{requireLinearFiltering:!0,useHalfFloat:i.useHalfFloat}))return console.warn("GPU volume projection not supported (need WebGL2 + float linear filtering)."),null;const s=new gt(e,{volumeData:i.data,volumeDims:i.dims,affineMatrix:i.affineMatrix,worldToIJK:i.worldToIJK,voxelSize:i.voxelSize,volumeOrigin:i.volumeOrigin,useHalfFloat:i.useHalfFloat,fillValue:i.fillValue??0,colormap:r.colormap??"viridis",intensityRange:r.range??[0,1],threshold:r.threshold??[0,0],overlayOpacity:r.opacity??1,baseColor:r.baseColor??8947848});return this.addSurface(s,t),s}setSurfaceVariant(e,t,i){const r=this.surfaces.get(e);r?r instanceof ht?(r.setVariant(t,i),this.variantBindingState&&(this.variantBindingState.variant=t),this.selectedSurfaceId=e,this.emit("surface:variant",{surfaceId:e,variant:t})):console.warn(`NeuroSurfaceViewer: surface ${e} does not support variants`):console.warn(`NeuroSurfaceViewer: surface ${e} not found`)}updateDataRange(e){if(!e||0===e.length)return void de("No data provided to updateDataRange, using defaults");const t=Array.from(e).filter((e=>isFinite(e)));if(de("Valid data points:",t.length,"out of",e.length),0===t.length)return void de("No valid data points found, using defaults");let i=t[0],r=t[0];for(let s=1;s<t.length;s++){const e=t[s];e<i&&(i=e),e>r&&(r=e)}if(i===r){r=i+Math.max(.1,.01*Math.abs(i)||.1)}de("Data range - Min:",i,"Max:",r),this.dataRange={min:i,max:r},this.intensityRange.range?(this.intensityRange.range.min=i,this.intensityRange.range.max=r):this.intensityRange.range={min:i,max:r},this.thresholdRange.range?(this.thresholdRange.range.min=0,this.thresholdRange.range.max=0):this.thresholdRange.range={min:0,max:0},this.pane&&(this.disposePane(),this.config.showControls&&this.config.useControls&&this.setupTweakPane().catch((e=>{console.error("Failed to reinitialize controls after data range update:",e)})))}removeSurface(e){const t=this.surfaces.get(e);t&&t.mesh&&(t.removeAllListeners(),this.gpuPicker&&this.gpuPicker.removeSurface(e),this.scene.remove(t.mesh),t.dispose(),this.surfaces.delete(e),this.emit("surface:removed",{surface:t,id:e}),this.requestRender())}addLayer(e,t){const i=this.surfaces.get(e);if(i&&i instanceof lt){if(i.addLayer(t),t instanceof Te){const e=t.getData();e&&this.updateDataRange(e)}this.selectedSurfaceId=e,this.selectedLayerId=t.id,this.syncLayerBindingsFromSelection(),this.requestRender()}}updateLayer(e,t,i){const r=this.surfaces.get(e);r&&r instanceof lt&&(r.updateLayer(t,i),this.requestRender())}updateLayerData(e,t,i,r){const s=this.surfaces.get(e);s&&s instanceof lt&&(s.updateLayerData(t,i,r),this.requestRender())}updateLayerVisibility(e,t,i){const r=this.surfaces.get(e);r&&r instanceof lt&&(r.updateLayerVisibility(t,i),this.requestRender())}removeLayer(e,t){const i=this.surfaces.get(e);i&&i instanceof lt&&(i.removeLayer(t),this.requestRender())}clearLayers(e,t){const i=this.surfaces.get(e);i&&i instanceof lt&&(i.clearLayers(t),this.requestRender())}clearSurfaces(){this.crosshair.visible&&this.hideCrosshair(),this.surfaces.forEach(((e,t)=>{e.mesh&&this.scene.remove(e.mesh),e.dispose(),this.annotations.removeBySurface(t)})),this.surfaces.clear(),this.requestRender()}addRimLightingShader(e){const t=e.material,i={value:this.config.rimStrength};this.rimStrengthUniforms.push(i),t.onBeforeCompile=e=>{e.uniforms.rimStrength=i,e.vertexShader=e.vertexShader.replace("#include <common>","\n        #include <common>\n        varying vec3 vViewPosition;\n        varying vec3 vNormal;\n        "),e.vertexShader=e.vertexShader.replace("#include <worldpos_vertex>","\n        #include <worldpos_vertex>\n        vViewPosition = -mvPosition.xyz;\n        vNormal = normalize(normalMatrix * normal);\n        "),e.fragmentShader=e.fragmentShader.replace("#include <common>","\n        #include <common>\n        uniform float rimStrength;\n        varying vec3 vViewPosition;\n        varying vec3 vNormal;\n        "),e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n        #include <dithering_fragment>\n        \n        // Rim lighting\n        vec3 viewDir = normalize(vViewPosition);\n        float rim = 1.0 - abs(dot(viewDir, vNormal));\n        rim = pow(rim, 2.0);\n        gl_FragColor.rgb += rim * rimStrength;\n        ")},t.needsUpdate=!0}setupPicking(){this.config.useGPUPicking&&mt.isSupported(this.renderer)&&(this.gpuPicker=new mt(this.renderer),de("GPU picking enabled")),this.handleMouseMove=e=>{const t=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.clientX-t.left)/t.width*2-1,this.mouse.y=-(e.clientY-t.top)/t.height*2+1,this.config.hoverCrosshair&&"selection"!==this.crosshair.mode&&this.updateHoverCrosshair(e)},this.renderer.domElement.addEventListener("mousemove",this.handleMouseMove)}setupSurfaceClick(){this.handleSurfaceClick||(this.handleSurfaceClick=this.onSurfaceClickHandler.bind(this)),this.renderer.domElement.addEventListener("click",this.handleSurfaceClick)}onSurfaceClickHandler(e){const t=this.pick({x:e.clientX,y:e.clientY});if(t.surfaceId&&null!==t.vertexIndex){if(this.onSurfaceClick&&this.onSurfaceClick({surfaceId:t.surfaceId,point:t.point,vertexIndex:t.vertexIndex}),this.emit("surface:click",{surfaceId:t.surfaceId,vertexIndex:t.vertexIndex,point:t.point}),this.config.clickToAddAnnotation){const e=this.addAnnotation(t.surfaceId,t.vertexIndex);e&&this.activateAnnotation(e,{exclusive:!0})}this.showCrosshair(t.surfaceId,t.vertexIndex,{size:this.crosshair.size,color:this.crosshair.color,mode:"selection"})}}updateHoverCrosshair(e){if(!this.crosshair.canHoverUpdate())return;const t=this.renderer.domElement.getBoundingClientRect(),i=e?e.clientX:t.left+t.width/2,r=e?e.clientY:t.top+t.height/2,s=this.pick({x:i,y:r});s.surfaceId&&null!==s.vertexIndex?(this.showCrosshair(s.surfaceId,s.vertexIndex,{size:this.config.hoverCrosshairSize??1.2,color:this.config.hoverCrosshairColor??6737151,mode:"hover"}),this.emit("vertex:hover",{surfaceId:s.surfaceId,vertexIndex:s.vertexIndex,screenX:i,screenY:r})):"hover"===this.crosshair.mode&&(this.hideCrosshair(),this.emit("vertex:hover",{surfaceId:null,vertexIndex:null,screenX:i,screenY:r}))}pick(e={}){if(void 0!==e.x&&void 0!==e.y){const t=this.renderer.domElement.getBoundingClientRect();this.mouse.x=(e.x-t.left)/t.width*2-1,this.mouse.y=-(e.y-t.top)/t.height*2+1}if((e.useGPU??!0)&&this.gpuPicker&&void 0!==e.x&&void 0!==e.y){const t=this.gpuPicker.pick(e.x,e.y,this.camera);return{surfaceId:t.surfaceId,vertexIndex:t.vertexIndex,point:t.point}}const t=e.opacityThreshold??.1;this.raycaster.setFromCamera(this.mouse,this.camera);const i=[];if(this.surfaces.forEach(((e,r)=>{if(!e.mesh)return;const s=e.mesh.material;if(Array.isArray(s)?s.every((e=>void 0!==e.opacity&&e.opacity<t)):void 0!==s.opacity&&s.opacity<t)return;const n=this.raycaster.intersectObject(e.mesh,!1);n.forEach((e=>{e.surfaceId=r})),i.push(...n)})),0===i.length)return{surfaceId:null,vertexIndex:null,point:null};const s=i[0],n=s.face,a=s.object,o=a.geometry.getAttribute("position");if(!n||!o)return{surfaceId:s.surfaceId||null,vertexIndex:null,point:s.point.clone()};const l=[n.a,n.b,n.c],h=a.matrixWorld;let c=l[0],d=1/0;const u=new r.Vector3;for(const r of l){u.set(o.getX(r),o.getY(r),o.getZ(r)).applyMatrix4(h);const e=u.distanceToSquared(s.point);e<d&&(d=e,c=r)}return{surfaceId:s.surfaceId||null,vertexIndex:c,point:s.point.clone()}}setOption(e,t){this.options.set(e,t)}getOption(e,t){return this.options.has(e)?this.options.get(e):t}enableGPUPicking(){return this.gpuPicker?(this.gpuPicker.setEnabled(!0),!0):mt.isSupported(this.renderer)?(this.gpuPicker=new mt(this.renderer),this.surfaces.forEach(((e,t)=>{e.mesh&&this.gpuPicker.addSurface(t,e.mesh)})),de("GPU picking enabled"),!0):(console.warn("GPU picking not supported on this device"),!1)}disableGPUPicking(){this.gpuPicker&&this.gpuPicker.setEnabled(!1)}isGPUPickingEnabled(){return null!==this.gpuPicker&&this.gpuPicker.isEnabled()}getGPUPicker(){return this.gpuPicker}addAnnotation(e,t,i,r){return this.annotations.add(e,t,i,r)}listAnnotations(e){return this.annotations.list(e)}moveAnnotation(e,t){return this.annotations.move(e,t)}removeAnnotations(e){this.annotations.removeBySurface(e)}removeAnnotation(e){this.annotations.remove(e)}clearAnnotations(){this.annotations.reset()}activateAnnotation(e,t){this.annotations.activate(e,t)}getAnnotation(e){return this.annotations.get(e)}showCrosshair(e,t,i){const r=this.surfaces.get(e);r&&r.mesh?this.crosshair.show(r.mesh,e,t,i):console.warn(`Crosshair: surface ${e} not found or missing mesh`)}hideCrosshair(){this.crosshair.hide()}toggleCrosshair(e,t,i){var r;const s=e??this.crosshair.surfaceId,n=s?(null==(r=this.surfaces.get(s))?void 0:r.mesh)??null:null;this.crosshair.toggle(n,e,t,i)}requestRender(){this.needsRender=!0}animate(){this.initializationFailed||(this.animationId=requestAnimationFrame(this.animate),this.fpsGraph&&this.fpsGraph.begin(),this.controls&&this.controlsEnabled&&this.controls.update(),(this.needsRender||this.controls.enableDamping)&&(this.render(),this.needsRender=!1),this.fpsGraph&&this.fpsGraph.end())}render(){this.initializationFailed||(this.emit("render:before"),this.config.useShaders&&this.composer?this.composer.render():this.renderer.render(this.scene,this.camera),this.emit("render:after"))}startRenderLoop(){this.animationId||this.animate()}start(){this.startRenderLoop()}stop(){null!==this.animationId&&(cancelAnimationFrame(this.animationId),this.animationId=null)}centerCamera(){const e=[];if(this.surfaces.forEach((t=>{t.geometry&&t.geometry.vertices&&e.push({vertices:t.geometry.vertices})})),0===e.length)return this.camera.position.set(0,0,this.config.initialZoom),this.camera.up.set(0,1,0),this.camera.lookAt(0,0,0),void(this.controls&&(this.controls.target.set(0,0,0),this.controls.minDistance=.05,this.controls.maxDistance=1/0,this.controls.update()));let t=1/0,i=1/0,s=1/0,n=-1/0,a=-1/0,o=-1/0;e.forEach((e=>{const r=ct.calculateBounds(e.vertices);t=Math.min(t,r.min.x),i=Math.min(i,r.min.y),s=Math.min(s,r.min.z),n=Math.max(n,r.max.x),a=Math.max(a,r.max.y),o=Math.max(o,r.max.z)}));const l=new r.Vector3((t+n)/2,(i+a)/2,(s+o)/2),h=new r.Vector3(n-t,a-i,o-s).length()/2;this.sceneBoundsRadius=h;const c=ct.calculateCameraDistance(h,this.camera.fov,this.camera.aspect);this.camera.position.copy(l).add(new r.Vector3(0,0,c)),this.camera.up.set(0,1,0),this.camera.lookAt(l),this.controls&&(this.controls.target.copy(l),this.controls.minDistance=Math.max(.6*h,.05),this.controls.maxDistance=Math.max(20*h,2*c),this.controls.update()),this.camera.near=Math.max(c/1e3,.001),this.camera.far=10*c,this.camera.updateProjectionMatrix(),this.config.initialZoom=c,this.requestRender()}setZoom(e,t={}){var i,s;const n=(null==(i=this.controls)?void 0:i.target)??new r.Vector3(0,0,0),a=(new r.Vector3).subVectors(this.camera.position,n).normalize(),o=this.sceneBoundsRadius>0?Math.max(.05,.6*this.sceneBoundsRadius):.05,l=this.sceneBoundsRadius>0?Math.max(20*this.sceneBoundsRadius,e):1/0,h=Math.min(l,Math.max(o,e));this.camera.position.copy(n).addScaledVector(a,h),this.camera.updateProjectionMatrix(),(null==(s=this.controls)?void 0:s.update)&&this.controls.update(),!1!==t.updateInitial&&(this.config.initialZoom=h),this.requestRender()}resize(e,t,i={}){const r=i.dpr??("undefined"!=typeof window?window.devicePixelRatio:1);return this.renderer.setPixelRatio(r),this.width=e,this.height=t,this.camera.aspect=e/t,this.camera.updateProjectionMatrix(),this.renderer.setSize(e,t),this.composer&&this.composer.setSize(e,t),this.ssaoPass&&this.ssaoPass.setSize(e,t),this.surfaces.forEach((i=>{i instanceof lt&&i.updateOutlineResolution(e,t,r)})),this.requestRender(),{width:e,height:t,dpr:r}}toJSON(){return di(this)}fromJSON(e){return bi(this,e)}toURL(e){const t=hi(this.toJSON());return`${e??("undefined"!=typeof window?window.location.href.split("#")[0]:"")}#${t}`}fromURL(e){const t=ci(e??("undefined"!=typeof window?window.location.hash:""));return this.fromJSON(t)}dispose(){this.initializationFailed||(null!==this.animationId&&cancelAnimationFrame(this.animationId),this.clearSurfaces(),this.controls&&("removeEventListener"in this.controls&&this.controls.removeEventListener("change",this.onControlsChange),this.controls.dispose()),this.composer&&this.composer.dispose(),this.gpuPicker&&(this.gpuPicker.dispose(),this.gpuPicker=null),this.environmentMap&&this.environmentMap.dispose(),this.renderer.domElement.removeEventListener("click",this.handleSurfaceClick),this.handleMouseMove&&this.renderer.domElement.removeEventListener("mousemove",this.handleMouseMove),this.handlePanePointerMove&&window.removeEventListener("pointermove",this.handlePanePointerMove),this.handlePanePointerUp&&(window.removeEventListener("pointerup",this.handlePanePointerUp),window.removeEventListener("pointercancel",this.handlePanePointerUp)),this.crosshair.dispose(),this.annotations&&this.annotations.dispose(),this.renderer.dispose(),this.renderer.domElement.parentNode&&this.renderer.domElement.parentNode.removeChild(this.renderer.domElement),this.pane&&this.pane.dispose(),this.paneContainer&&this.paneContainer.parentNode&&this.paneContainer.parentNode.removeChild(this.paneContainer))}hasDOM(){return"undefined"!=typeof window&&"undefined"!=typeof document&&!!document.createElement}isWebGLAvailable(){if(!this.hasDOM())return!1;const e=document.createElement("canvas");return!!(e.getContext("webgl")||e.getContext("experimental-webgl"))}renderFallback(e){if(!this.hasDOM()||!this.container)return void console.warn(e);const t=document.createElement("div");t.textContent=e,t.style.color="#fff",t.style.background="#000",t.style.padding="12px",t.style.fontFamily="sans-serif",t.style.fontSize="14px",t.style.textAlign="center",t.style.width="100%",t.style.height="100%",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.boxSizing="border-box",this.container.innerHTML="",this.container.appendChild(t)}getControlsVisible(){return this.config.showControls}toggleControls(e){const t="boolean"==typeof e?e:!this.config.showControls;this.config.showControls=t,t?!this.paneContainer&&this.config.useControls?this.setupTweakPane().catch((e=>{console.error("Failed to initialize Tweakpane controls:",e),this.emit("controls:error",{error:e})})):this.paneContainer&&(this.paneContainer.style.display="block",this.setPaneMinimized(this.paneDragState.minimized)):this.paneContainer&&(this.paneContainer.style.display="none")}togglePaneMinimized(){this.setPaneMinimized(!this.paneDragState.minimized)}minimizeControlsPane(){this.setPaneMinimized(!0)}restoreControlsPane(){this.setPaneMinimized(!1)}disposePane(){if(this.pane)try{this.pane.dispose()}catch(e){console.warn("Failed to dispose pane",e)}this.paneContainer&&this.paneContainer.parentElement&&this.paneContainer.parentElement.removeChild(this.paneContainer),this.pane=null,this.paneContainer=null,this.paneContentEl=null,this.paneHandleEl=null,this.paneMinimizeButtonEl=null,this.paneLoading=!1}setPaneMinimized(e){this.paneDragState.minimized=e,this.paneContentEl&&(this.paneContentEl.style.display=e?"none":"block"),this.paneMinimizeButtonEl&&(this.paneMinimizeButtonEl.textContent=e?"+":"",this.paneMinimizeButtonEl.title=e?"Restore controls":"Minimize controls")}enableControls(){this.controlsEnabled=!0,this.emit("controls:changed",{enabled:!0})}disableControls(){this.controlsEnabled=!1,this.emit("controls:changed",{enabled:!1})}getIntersectionPoint(){this.raycaster.setFromCamera(this.mouse,this.camera);const e=new r.Vector3(0,0,1);e.applyQuaternion(this.camera.quaternion);const t=new r.Plane(e,0);return this.raycaster.ray.intersectPlane(t,this.intersectionPoint),this.intersectionPoint}getRayDirection(){return this.raycaster.setFromCamera(this.mouse,this.camera),this.raycaster.ray.direction.clone()}updateSurfaceData(e,t,i){const r=this.surfaces.get(e);r instanceof be&&(r.setData(t),this.updateDataRange(t),this.requestRender())}updateColorMap(e,t){const i=this.surfaces.get(e);i instanceof be&&(i.setColorMap(t),this.requestRender())}getSurface(e){return this.surfaces.get(e)}getSurfaceIds(){return Array.from(this.surfaces.keys())}updateConfig(e){this.config={...this.config,...e},void 0!==e.ambientLightColor&&(this.updateAmbientLight(e.ambientLightColor),this.config.ambientLightColor=e.ambientLightColor),void 0!==e.directionalLightColor&&(this.updateDirectionalLight(e.directionalLightColor),this.config.directionalLightColor=e.directionalLightColor),void 0!==e.directionalLightIntensity&&(this.updateDirectionalLightIntensity(e.directionalLightIntensity),this.config.directionalLightIntensity=e.directionalLightIntensity),void 0!==e.backgroundColor&&this.renderer&&(this.renderer.setClearColor(e.backgroundColor),this.config.backgroundColor=e.backgroundColor),void 0===e.metalness&&void 0===e.roughness||this.updateMaterials(),void 0!==e.ssaoRadius&&this.ssaoPass&&(this.ssaoPass.kernelRadius=e.ssaoRadius),void 0!==e.rimStrength&&this.rimStrengthUniforms.forEach((t=>{t.value=e.rimStrength})),"presentation"===e.preset&&this.applyPresentationPreset(),this.requestRender()}applyPresentationPreset(){this.container&&(this.container.style.background="linear-gradient(135deg, #f7f7f9 0%, #e3e7ed 100%)"),this.renderer.setClearColor(0,0),this.updateAmbientLight(11579568),this.updateDirectionalLightIntensity(1),this.updateConfig({metalness:.05,roughness:.35,rimStrength:Math.max(this.config.rimStrength,.35),ssaoRadius:Math.max(this.config.ssaoRadius,6)}),this.requestRender()}takeScreenshot(e="neurosurface.png"){this.render(),this.renderer.domElement.toBlob((t=>{if(t){const i=URL.createObjectURL(t),r=document.createElement("a");r.href=i,r.download=e,r.click(),URL.revokeObjectURL(i)}}))}getCameraState(){return{position:this.camera.position.toArray(),rotation:this.camera.rotation.toArray(),target:this.controls.target.toArray()}}setCameraState(e){e.position&&this.camera.position.fromArray(e.position),e.rotation&&this.camera.rotation.fromArray(e.rotation),e.target&&this.controls.target.fromArray(e.target),this.controls.update(),this.requestRender()}},e.NoopNeuroSurfaceViewer=class extends he{constructor(e){super(),this.container=e}render(){}addSurface(){}clearSurfaces(){}resize(){}dispose(){}},e.OutlineLayer=Be,e.RGBALayer=_e,e.SparklineOverlay=class{constructor(e,t){this.lastTimeSeries=null,this.lastTimes=null,this.lastCurrentTime=0,this.lastFactor=null,this.container=e,this.opts={...Pi,...t},this.canvas=document.createElement("canvas"),this.canvas.width=this.opts.width,this.canvas.height=this.opts.height,this.canvas.style.cssText="\n      position: absolute;\n      pointer-events: none;\n      display: none;\n      z-index: 10000;\n      border-radius: 4px;\n      box-shadow: 0 2px 8px rgba(0,0,0,0.5);\n    ",this.ctx=this.canvas.getContext("2d"),this.container.appendChild(this.canvas)}show(e,t,i,r,s,n){this.lastTimeSeries=e,this.lastTimes=t,this.lastCurrentTime=i,this.lastFactor=n??null,this.drawFull(e,t,i,n??null),this.position(r,s),this.canvas.style.display="block"}hide(){this.canvas.style.display="none",this.lastTimeSeries=null,this.lastTimes=null}updateTimeMarker(e){this.lastTimeSeries&&this.lastTimes&&(this.lastCurrentTime=e,this.drawFull(this.lastTimeSeries,this.lastTimes,e,this.lastFactor))}dispose(){this.canvas.parentElement&&this.canvas.parentElement.removeChild(this.canvas),this.lastTimeSeries=null,this.lastTimes=null}position(e,t){const i=this.container.getBoundingClientRect();let r=e-i.left+12,s=t-i.top+12;r+this.opts.width>i.width&&(r=e-i.left-this.opts.width-12),s+this.opts.height>i.height&&(s=t-i.top-this.opts.height-12),r<0&&(r=0),s<0&&(s=0),this.canvas.style.left=`${r}px`,this.canvas.style.top=`${s}px`}drawFull(e,t,i,r){const{width:s,height:n,padding:a,bgColor:o,lineColor:l,timeMarkerColor:h}=this.opts,c=this.ctx;if(!c)return;c.clearRect(0,0,s,n),c.fillStyle=o,c.beginPath(),c.roundRect(0,0,s,n,4),c.fill();const d=a,u=a,p=s-2*a,m=n-2*a;if(0===e.length||0===t.length)return;let f=1/0,g=-1/0;for(let S=0;S<e.length;S++){const t=e[S];isFinite(t)&&(t<f&&(f=t),t>g&&(g=t))}isFinite(f)||(f=0,g=1),g===f&&(g=f+1);const v=t[0],y=t[t.length-1],b=y-v||1,w=g-f,x=e=>d+(e-v)/b*p,M=e=>u+m-(e-f)/w*m;if(r&&r.levels.length>1){const e=["rgba(70,130,180,0.2)","rgba(180,100,70,0.2)","rgba(70,180,100,0.2)","rgba(180,70,180,0.2)"];for(let i=0;i<t.length-1;i++){const s=r.assignment[i];c.fillStyle=e[s%e.length];const n=x(t[i]),a=x(t[i+1]);c.fillRect(n,u,a-n,m)}}c.strokeStyle=l,c.lineWidth=1.5,c.lineJoin="round",c.beginPath();let C=!1;for(let S=0;S<e.length;S++){const i=e[S];if(!isFinite(i))continue;const r=x(t[S]),s=M(i);C?c.lineTo(r,s):(c.moveTo(r,s),C=!0)}if(c.stroke(),i>=v&&i<=y){const e=x(i);c.strokeStyle=h,c.lineWidth=1.5,c.setLineDash([3,3]),c.beginPath(),c.moveTo(e,u),c.lineTo(e,u+m),c.stroke(),c.setLineDash([])}}},e.StatisticalMapLayer=Fi,e.SurfaceControls=N,e.SurfaceFactory=Ti,e.SurfaceGeometry=ve,e.SurfaceSet=Si,e.TemporalDataLayer=Ue,e.TimelineController=class extends he{constructor(e,t={}){if(super(),!e||0===e.length)throw new Error("TimelineController requires a non-empty times array");this.times=e.slice(),this.currentTime=e[0],this.playing=!1,this.speed=t.speed??1,this.loopMode=t.loop??"loop",this.direction=1,this.rafId=null,this.lastTimestamp=0,t.autoPlay&&this.play()}play(){this.playing||(this.playing=!0,this.lastTimestamp=0,this.rafId=requestAnimationFrame((e=>this.tick(e))),this.emit("play"))}pause(){this.playing&&(this.playing=!1,null!==this.rafId&&(cancelAnimationFrame(this.rafId),this.rafId=null),this.emit("pause"))}stop(){this.pause(),this.currentTime=this.times[0],this.direction=1,this.emitTimeChange(),this.emit("stop")}toggle(){this.playing?this.pause():this.play()}seek(e){const t=this.times[0],i=this.times[this.times.length-1];this.currentTime=Math.max(t,Math.min(i,e)),this.emitTimeChange()}setSpeed(e){this.speed=Math.max(.01,e)}setLoop(e){this.loopMode=e,"bounce"!==e&&(this.direction=1)}getState(){const{frameA:e,frameB:t,alpha:i}=this.resolveFrame(this.currentTime);return{currentTime:this.currentTime,playing:this.playing,speed:this.speed,loopMode:this.loopMode,frameA:e,frameB:t,alpha:i}}resolveFrame(e){const t=this.times.length;if(1===t)return{frameA:0,frameB:0,alpha:0};if(e<=this.times[0])return{frameA:0,frameB:0,alpha:0};if(e>=this.times[t-1])return{frameA:t-1,frameB:t-1,alpha:0};let i=0,r=t-1;for(;r-i>1;){const t=i+r>>>1;this.times[t]<=e?i=t:r=t}const s=this.times[i],n=this.times[r]-s,a=n>0?(e-s)/n:0;return a<1e-10?{frameA:i,frameB:i,alpha:0}:{frameA:i,frameB:r,alpha:a}}tick(e){if(!this.playing)return;0===this.lastTimestamp&&(this.lastTimestamp=e);const t=e-this.lastTimestamp;this.lastTimestamp=e;const i=this.times[this.times.length-1]-this.times[0];if(i<=0)return void(this.rafId=requestAnimationFrame((e=>this.tick(e))));const r=t/1e3*this.speed*i*this.direction;this.currentTime+=r;const s=this.times[0],n=this.times[this.times.length-1];if(this.currentTime>n)switch(this.loopMode){case"loop":this.currentTime=s+(this.currentTime-n);break;case"bounce":this.currentTime=n-(this.currentTime-n),this.direction=-1;break;case"none":this.currentTime=n,this.pause()}else if(this.currentTime<s)switch(this.loopMode){case"loop":this.currentTime=n-(s-this.currentTime);break;case"bounce":this.currentTime=s+(s-this.currentTime),this.direction=1;break;case"none":this.currentTime=s,this.pause()}this.emitTimeChange(),this.playing&&(this.rafId=requestAnimationFrame((e=>this.tick(e))))}emitTimeChange(){const{frameA:e,frameB:t,alpha:i}=this.resolveFrame(this.currentTime),r={time:this.currentTime,frameA:e,frameB:t,alpha:i};this.emit("timechange",r)}toStateJSON(){return{currentTime:this.currentTime,speed:this.speed,loopMode:this.loopMode,playing:this.playing}}fromStateJSON(e){void 0!==e.currentTime&&this.seek(e.currentTime),void 0!==e.speed&&this.setSpeed(e.speed),void 0!==e.loopMode&&this.setLoop(e.loopMode),!0===e.playing?this.play():!1===e.playing&&this.pause()}dispose(){this.pause(),this.removeAllListeners()}},e.TwoDataLayer=Pe,e.VariantSurface=ht,e.VertexColoredNeuroSurface=we,e.VolumeProjectedSurface=gt,e.VolumeProjectionLayer=Ae,e.VolumeProjectionMaterial=ft,e.VolumeTexture3D=Me,e.applyEmbedStyles=function(e){if(!e||"undefined"==typeof window||!window.document)return;e.classList.add("neurosurface-root");const t="neurosurface-embed-styles";if(!document.getElementById(t)){const e=document.createElement("style");e.id=t,e.textContent=Ai,document.head.appendChild(e)}},e.buildVertexAdjacency=ge,e.computeBonferroniThreshold=Li,e.computeFDRThreshold=Ei,e.computeMeanCurvature=function(e){const t=e.vertices,i=e.faces,s=t.length/3,n=ge(i,s),a=n.neighbors,o=n.vertexFaces,l=new Float32Array(s),h=new r.Vector3,c=new r.Vector3,d=new r.Vector3,u=new r.Vector3,p=new r.Vector3,m=new r.Vector3,f=new r.Vector3,g=new r.Vector3,v=new r.Vector3,y=new r.Vector3;for(let r=0;r<s;r++){h.set(t[3*r],t[3*r+1],t[3*r+2]);const e=a[r];if(0===e.size){l[r]=0;continue}let s=0,n=0,b=0;for(const i of e)s+=t[3*i],n+=t[3*i+1],b+=t[3*i+2];const w=e.size;c.set(s/w,n/w,b/w),d.subVectors(c,h),y.set(0,0,0),u.copy(h);let x=0;for(const a of o[r]){const e=i[3*a],s=i[3*a+1],n=i[3*a+2];let o,l;e===r?(o=s,l=n):s===r?(o=n,l=e):(o=e,l=s),p.set(t[3*o],t[3*o+1],t[3*o+2]),m.set(t[3*l],t[3*l+1],t[3*l+2]),f.subVectors(p,u),g.subVectors(m,u),v.crossVectors(f,g),v.lengthSq()>0&&(v.normalize(),y.add(v),x++)}x>0&&(y.divideScalar(x),y.normalize());const M=d.length(),C=d.dot(y)>0?1:-1;l[r]=C*M}return l},e.computePickInfo=function(e,t){const i=e.intersectObject(t,!1);if(!i||0===i.length)return{point:null,faceIndex:null,distance:null};const r=i[0];return{point:r.point?r.point.clone():null,faceIndex:r.faceIndex??null,distance:r.distance??null,uv:r.uv?r.uv.clone():void 0}},e.createColormapTexture=Ce,e.curvatureToGrayscale=function(e,t={}){const{brightness:i=.5,contrast:r=.5,smoothness:s=1}=t,n=new Float32Array(e.length);for(let a=0;a<e.length;a++){const t=Math.max(-.5,Math.min(.5,e[a]/s))*r+i;n[a]=Math.max(0,Math.min(1,t))}return n},e.debugLog=de,e.decode=ci,e.deserialize=bi,e.detectCapabilities=dt,e.embedStyles=Ai,e.encode=hi,e.filterClustersBySize=Ri,e.findClusters=Ii,e.getDomParser=Oi,e.hasDOM=function(){return"undefined"!=typeof window&&"undefined"!=typeof document&&!!document.createElement},e.loadSurface=async function(e,t="auto",i="unknown",r=3e4,s=!1,n=100){const a=new AbortController,o=setTimeout((()=>a.abort()),r);try{const r=await fetch(e,{signal:a.signal});if(clearTimeout(o),!r.ok)throw new Error(`HTTP ${r.status}: ${r.statusText}`);let l,h=t;switch("auto"===t&&(e.endsWith(".gii")?h="gifti":e.endsWith(".ply")?h="ply":(e.includes("lh.")||e.includes("rh."))&&(h="freesurfer")),h){case"freesurfer":l=Ni(await r.arrayBuffer());break;case"gifti":l=Ui(await r.text(),await Oi());break;case"ply":l=Gi(await r.text());break;default:throw new Error(`Unsupported format: ${h}`)}if(!l.vertices||!l.faces)throw new Error("Invalid surface data: missing vertices or faces");if(s){const e=Bi.autoScale(l.vertices,n);1!==e&&console.log(`Auto-scaled surface by factor of ${e}`)}const c="unknown"!==i&&i?i:"left";return new ve(l.vertices,l.faces,c)}catch(l){if(l instanceof Error){if("AbortError"===l.name)throw new Error(`Request timeout after ${r}ms`);throw l}throw new Error("Failed to load surface")}},e.loadSurfaceFromFile=async function(e,t="auto",i="unknown",r=!1,s=100){if(!e)throw new Error("No file provided");if(0===e.size)throw new Error("File is empty");if(e.size>524288e3)throw new Error("File too large (max 500MB)");let n,a=t;switch("auto"===t&&(e.name.endsWith(".gii")?a="gifti":e.name.endsWith(".ply")?a="ply":(e.name.includes("lh.")||e.name.includes("rh."))&&(a="freesurfer")),a){case"freesurfer":n=Ni(await e.arrayBuffer());break;case"gifti":n=Ui(await e.text(),await Oi());break;case"ply":n=Gi(await e.text());break;default:throw new Error(`Unsupported format: ${a}`)}if(!n.vertices||!n.faces)throw new Error("Invalid surface data: missing vertices or faces");if(0===n.vertices.length||0===n.faces.length)throw new Error("Invalid surface data: empty vertices or faces");let o=i;if("unknown"===i&&(o=e.name.includes("lh.")||e.name.includes("left")?"left":e.name.includes("rh.")||e.name.includes("right")?"right":"left"),r){const e=Bi.autoScale(n.vertices,s);1!==e&&console.log(`Auto-scaled surface by factor of ${e}`)}return new ve(n.vertices,n.faces,o)},e.normalizeCurvature=function(e,t=98){const i=Array.from(e).map(Math.abs).sort(((e,t)=>e-t)),r=i[Math.floor(i.length*t/100)]||1,s=new Float32Array(e.length);for(let n=0;n<e.length;n++)s[n]=Math.max(-1,Math.min(1,e[n]/r));return s},e.pToZ=Di,e.parseFreeSurferCurvature=function(e){let t;if("string"==typeof e){t=(new TextEncoder).encode(e).buffer}else t=e;if(!t||t.byteLength<16)throw new Error("Invalid FreeSurfer curvature: file too small");const i=new DataView(t);let r=0;r+=3;const s=i.getInt32(r,!1);if(r+=4,s<=0||s>1e7)throw new Error(`Invalid FreeSurfer curvature: vertex count out of range (${s})`);const n=r+8+4*s;if(t.byteLength<n)throw new Error("Invalid FreeSurfer curvature: file truncated");r+=4,r+=4;const a=new Float32Array(s);for(let o=0;o<s;o++)a[o]=i.getFloat32(r,!1),r+=4;return a},e.parseFreeSurferSurface=Ni,e.parseGIfTISurface=Ui,e.parsePLY=Gi,e.serialize=di,e.setDebug=function(e){ce=e},e.tToZ=ki,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=surfview.umd.js.map
